// StateMachine.cpp : Implementation of CStateMachine
#include "stdafx.h"
#include "StateMachineProj.h"
#include "StateMachine.h"

state::~state()
{
	int i;
	for(i=0;i<transitions.GetSize();i++)
		delete transitions.GetAt(i);
	transitions.RemoveAll();
	for(i=0;i<commands.GetSize();i++)
		delete commands.GetAt(i);
	commands.RemoveAll();
}

state::state(CString inname, int id)
{
	conn* trans;
	shapeid=id;
	if(inname!="Stop")
	{
		trans=new conn;
		trans->shapeid=-1;
		trans->trigger="Stop";
		trans->startnum=id;
		transitions.Add(trans);
		trans=new conn;
		trans->shapeid=-1;
		trans->trigger="Reset";
		trans->startnum=id;
		transitions.Add(trans);
	}
	commands.RemoveAll();
	name=inname;
}

state::state(conn* intrans, int id)
{
	conn* trans;
	shapeid=id;
	trans=new conn;
	trans->shapeid=-1;
	trans->trigger="Stop";
	trans->startnum=id;
	transitions.Add(trans);
	trans=new conn;
	trans->shapeid=-1;
	trans->trigger="Reset";
	trans->startnum=id;
	transitions.Add(trans);
	if(intrans->trigger.Find("Stop")==0)
		transitions[0]->trigger=intrans->trigger;
	else if(intrans->trigger.Find("Reset")==0)
		transitions[1]->trigger=intrans->trigger;
	else
		transitions.Add(intrans);
	commands.RemoveAll();
	name="";
}

command::command(CString txt)
{
	componentname="\\\\"+txt.SpanExcluding(".");
	function=txt.Mid(txt.Find(".")+1);
}

command::~command()
{
	//do something???
}

/////////////////////////////////////////////////////////////////////////////
// CStateMachine

STDMETHODIMP CStateMachine::OnConstruct()
{

	m_currstate=-1;
	m_reset=FALSE;
	m_wait=FALSE;
	m_vars=new CMapStringToPtr;
	m_idxs=new int[1];
	m_firstconn=new conn;
	m_stopstate=-1;
	m_signal="";

	return S_OK;
}

STDMETHODIMP CStateMachine::OnDestruct()
{
	int i;

	DeleteVars();

	m_filename.Empty();
	for(i=0;i<m_fsm.GetSize();i++)
		delete m_fsm.GetAt(i);
	m_fsm.RemoveAll();
	delete m_firstconn;

	delete[] m_idxs;


	return S_OK;
}

void CStateMachine::DeleteVars()
{
	POSITION t;
	CString key;
	variant_t *val;

	t=m_vars->GetStartPosition();
	while(t!=NULL)
	{
		m_vars->GetNextAssoc(t,key,(void *&)val);
		if(val->vt==(VT_BSTR))
			SysFreeString(val->bstrVal);
		else if(val->vt>=VT_BYREF)
		{
			switch(val->vt)
			{
			case VT_BYREF|VT_I2:
				delete val->piVal;
				break;
			case VT_BYREF|VT_I4:
				delete val->plVal;
				break;
			case VT_BYREF|VT_R4:
				delete val->pfltVal;
				break;
			case VT_BYREF|VT_R8:
				delete val->pdblVal;
				break;
			}
		}
		delete val;
	}
	m_vars->RemoveAll();

	delete m_vars;
}

STDMETHODIMP CStateMachine::Load(VARIANT Data)
{
			BSTR					ItemName1 = NULL;	// Holds the name of a given item to be writen into a PropertyBag
			_PropertyBagWrapper*	pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
			HRESULT					hRes;			// The HRESULT value we get back from COM calls.
			variant_t*				var;
			bstr_t					temp;

			// (1) Create the property bag wrapper class
			// (2) Have the class point to the interface 
			hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
			{
				var=new variant_t;
				if (pIPB == NULL)	
					return !S_OK;
				
				// Pass Data to PropertyBag
				hRes = pIPB->SetPropertyBag(&Data);

				// Define strings
				ItemName1 = SysAllocString(L"StateMachineFile");	// Assign to Item1 the name of your variable

				// Read Data from the property bag
				hRes = pIPB->GetFromPropertyBag(&ItemName1,var);
				m_filename=((bstr_t)(*var)).copy();
			}
				// Decrement the pointer reference count from our member variable. 
				VariantClear(&m_VBPropertyBag);
				
				// Release
				pIPB->Release();

			return S_OK;
}

STDMETHODIMP CStateMachine::Save(VARIANT *Data)
{
			BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
			VARIANT					ItemValue;

			HRESULT					hRes;			// The HRESULT value we get back from COM calls.
			_PropertyBagWrapper*	pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class


			// Create Class with CoCreateInstance (definition can be found in MSDN).
			// Create the property bag wrapper class, put pointer to the Interface in pIPB
			hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
	
			{
				
				ItemName = SysAllocString(L"StateMachineFile");		// Allocate the string and cast it with L to a 2 byte char (look up ANSI and Unicode strings)
				VariantInit(&ItemValue);						// Initialize our variant (does not free existing one)

				ItemValue.vt=VT_BSTR;
				ItemValue.bstrVal=m_filename.AllocSysString();

				// Add an item to the property bag via the wrapper class.
				hRes = pIPB->AddToPropertyBag(&ItemName, &ItemValue);

				// Release the string
				SysFreeString(ItemName);

			}

			// Get the pointer to the real VB property bag (the VB object (defined in msvbvm60.dll (aka VBRUN)) that our wrapper class created)
			hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
			
			// Copy the value VB gave to us into the return value of this function (which will be returned to whatever's calling our save function)
			VariantCopy(Data, &m_VBPropertyBag);

			// Decrement the pointer reference count from our member variable. 
			VariantClear(&m_VBPropertyBag);

			// Release
			pIPB->Release();

			return S_OK;
}

void CStateMachine::LoadFile()
{
	CStdioFile *filein;
	CString tline;
	CString txt;
	int i;

	BOOL ok=TRUE;

	for(i=0;i<m_fsm.GetSize();i++)
		delete m_fsm.GetAt(i);
	m_fsm.RemoveAll();
	m_numstates=0;
	DeleteVars();
	m_vars=new CMapStringToPtr;

	filein=new CStdioFile;
	if(!filein->Open(m_filename,CFile::modeRead|CFile::typeText))
	{
		AfxMessageBox("Error opening file");
		delete filein;
		return;
	}
	filein->ReadString(tline);
	while(tline.Find("Stateflow")!=0) //At start of a line
	{
		if(!filein->ReadString(tline))
		{
			AfxMessageBox("No Stateflow information found.",MB_OK);
			filein->Close();
			delete filein;
			return;
		}
	}

	while(filein->ReadString(tline)&&ok)
	{
		tline.TrimLeft();
		if(tline.Find("state {")==0)
		{
			ok=ReadState(filein);
		}
		else if(tline.Find("transition {")==0)
		{
			ok=ReadConn(filein);
		}
		else if(tline.Find("data {")==0)
		{
			ok=ReadData(filein);
		}
	
	}

	filein->Close();
	delete filein;

	if(!ok)
	{
		AfxMessageBox("File Read Error or Incorrect Format");
		for(i=0;i<m_fsm.GetSize();i++)
			delete m_fsm.GetAt(i);
		m_fsm.RemoveAll();
		DeleteVars();
		m_numstates=0;

		return;
	}	

	HiddenSetup();
}

void CStateMachine::HiddenSetup()
{
	state *astate;
	int i;
	int maxid;
	BOOL nostop=TRUE;

	if(m_stopstate==-1)
	{
		maxid=-1;
		for(i=0;i<m_fsm.GetSize();i++)
		{
			if(m_fsm[i]->shapeid>maxid)
				maxid=m_fsm[i]->shapeid;
		}
		maxid++;
		astate=new state("Stop",maxid);
		m_fsm.Add(astate);
		m_stopstate=maxid;
		m_numstates++;
	}

	for(i=0;i<m_fsm.GetSize();i++)
	{
		if(m_fsm[i]->name!="Stop")
		{
			m_fsm[i]->transitions[0]->endnum=m_stopstate;
			m_fsm[i]->transitions[1]->endnum=m_firstconn->endnum;
		}
	}
}

BOOL CStateMachine::ReadState(CStdioFile*filein)
{
	CString tline,txt;
	int tidx;
	state *newstate;
	command *newcommand;
	int id=-1;
	CString name;
	int done=0;
	BOOL makecomm;


	while(filein->ReadString(tline) && done!=2)
	{
		tline.TrimLeft();
		if(tline.Find("id")==0)
		{
			txt=tline.Mid(tline.FindOneOf("1234567890"));
			if(id==-2)
			{
				id=atoi(txt.SpanIncluding("1234567890"));
				newstate->shapeid=id;
			}
			else
				id=atoi(txt.SpanIncluding("1234567890"));
			done++;
		}
		else if(tline.Find("labelString")==0)
		{
			name=tline.Mid(tline.Find('"')+1);
			name.TrimRight('"');
			tidx=name.Find("\\n");
			if(tidx!=-1)
				name.Delete(tidx,2);

			newstate=new state(name,id);
			id=-2;

			filein->ReadString(tline);
			tline.TrimLeft();

			txt.Empty();
			makecomm=FALSE;
			while(tline[0]=='"')
			{
				txt=txt+tline.Mid(1);
				txt.TrimRight('"');

				//turns the string "\n" to the newline-return that it is meant to be. 
				tidx=txt.Find("\\n");
				while(tidx!=-1)
				{
					txt.SetAt(tidx,'\r');
					txt.SetAt(tidx+1,'\n');
					tidx=txt.Find("\\n");
					makecomm=TRUE;
				}

				//Stateflow records a " as \" (uses an escape sequence)
				//this eliminates the preceding slash.
				tidx=txt.Find("\\\"");
				while(tidx!=-1)
				{
					txt.Delete(tidx);
					tidx=txt.Find("\\\"");
				}

				//Stateflow record a \ as \\ (uses and escape sequence)
				//this turns it into one slash
				tidx=txt.Find("\\\\");
				while(tidx!=-1)
				{
					txt.Delete(tidx);
					tidx=txt.Find("\\\\");
				}

				if(makecomm==TRUE)
				{
					newcommand=new command(txt);
//					m_Locator->Locate(newcommand->componentname.AllocSysString(),&(newcommand->component));
					newstate->commands.Add(newcommand);
					makecomm=FALSE;
					txt.Empty();
				}

				filein->ReadString(tline);
				tline.TrimLeft();
			}

			if(!txt.IsEmpty())
			{
				newcommand=new command(txt);
//				m_Locator->Locate(newcommand->componentname.AllocSysString(),&(newcommand->component));
				newstate->commands.Add(newcommand);
				txt.Empty();
			}

			done++;
		}
	}

	if(done<2)
		return FALSE;

	if(name=="Stop")
		m_stopstate=id;

	tidx=FindState(newstate->shapeid);
	if(tidx==-1)
	{
		m_fsm.Add(newstate);
		m_numstates++;
	}
	else
	{
		if(newstate->name!="")
			m_fsm[tidx]->name=newstate->name;
		if(newstate->commands.GetSize()>0)
			m_fsm[tidx]->commands.Copy(newstate->commands);
		delete newstate;
	}
	return TRUE;

}

BOOL CStateMachine::ReadConn(CStdioFile*filein)
{
	CString tline,txt;
	int tidx;
	int done=0;
	conn *newconn;
	state *newstate;
	int opt=0;

	newconn=new conn;

	newconn->shapeid=-1;
	newconn->startnum=-1;
	newconn->endnum=-1;
	newconn->trigger="";

	while(filein->ReadString(tline)&&done!=4)
	{
		tline.TrimLeft();
		if(tline.Find("id")==0)
		{
			switch(opt)
			{
			case 0:
				txt=tline.Mid(tline.FindOneOf("1234567890"));
				newconn->shapeid=atoi(txt.SpanIncluding("1234567890"));
				done++;
				break;
			case 1:
				//src
				txt=tline.Mid(tline.FindOneOf("1234567890"));
				newconn->startnum=atoi(txt.SpanIncluding("1234567890"));
				done++;
				break;
			case 2:
				//dst
				txt=tline.Mid(tline.FindOneOf("1234567890"));
				newconn->endnum=atoi(txt.SpanIncluding("1234567890"));
				done++;
				break;
			}
			opt=0;
		}
		else if(tline.Find("labelString")==0)
		{
			newconn->trigger=tline.Mid(tline.Find('"')+1);
			newconn->trigger.TrimRight('"');
			filein->ReadString(tline);
			tline.TrimLeft();
			while(tline[0]=='"')
			{
				newconn->trigger+=tline.Mid(1);
				newconn->trigger.TrimRight('"');
				filein->ReadString(tline);
				tline.TrimLeft();
			}

			//There is no need for a newline-return in the trigger.
			tidx=newconn->trigger.Find("\\n");
			while(tidx!=-1)
			{
				newconn->trigger.Delete(tidx,2);
				tidx=newconn->trigger.Find("\\n");
			}
			
			//Stateflow records a " as \" (uses an escape sequence)
			//this eliminates the preceding slash.
			tidx=newconn->trigger.Find("\\\"");
			while(tidx!=-1)
			{
				newconn->trigger.Delete(tidx);
				tidx=newconn->trigger.Find("\\\"");
			}

			//Stateflow record a \ as \\ (uses and escape sequence)
			//this turns it into one slash
			tidx=newconn->trigger.Find("\\\\");
			while(tidx!=-1)
			{
				newconn->trigger.Delete(tidx);
				tidx=newconn->trigger.Find("\\\\");
			}
			
			done++;
		}
		else if(tline.Find("src")==0)
		{
			opt=1;
		}
		else if(tline.Find("dst")==0)
		{
			opt=2;
		}

		if(opt==1 && tline.Find("}")!=-1)
		{	
			//no source id--this is the initial transition.
			done++;
		}
	}

	if(done<4)
		return FALSE;

	if(newconn->startnum==-1)
	{
		delete m_firstconn;
		m_firstconn=newconn;
	}
	else
	{
		tidx=FindState(newconn->startnum);
		if(tidx==-1)
		{
			newstate=new state(newconn,newconn->startnum);
			tidx=m_fsm.Add(newstate);
		}
		else
		{
			if(newconn->trigger.Find("Stop")==0)
				m_fsm[tidx]->transitions[0]->trigger=newconn->trigger;
			else if(newconn->trigger.Find("Reset")==0)
				m_fsm[tidx]->transitions[1]->trigger=newconn->trigger;
			else
				m_fsm[tidx]->transitions.Add(newconn);
		}
		
	}	

	return TRUE;
}

BOOL CStateMachine::ReadData(CStdioFile*filein)
{
	CString tline,txt;
	int done=0;
	int done2=0;
	int opt=0;
	int i,j,arraycount=0;
	variant_t *val;
	CString key;

	val=new variant_t;
	val->vt=VT_EMPTY;

	while(filein->ReadString(tline)&&done<3)
	{
		tline.TrimLeft();
		if(tline.Find("name")==0)
		{
			key=tline.Mid(tline.Find('"')+1);
			key=key.SpanExcluding("\"");
			done++;
		}
		else if(tline.Find("dataType")==0)
		{
			txt=tline.Mid(tline.Find('"')+1);
			txt=txt.SpanExcluding("\"");
			if(txt=="int16")
			{
				val->vt=VT_I2;
				val->iVal=(short)0;
			}
			else if(txt=="int32")
			{
				val->vt=VT_I4;
				val->lVal=(long)0;
 			}
			else if(txt=="single")
			{
				val->vt=VT_R4;
				val->fltVal=0.0f;
			}
			else if(txt=="double")
			{
				val->vt=VT_R8;
				val->dblVal=0.0;
			}
			else if(txt=="char"||txt=="string"||txt=="uint8")
			{
				val->vt=VT_BSTR;
				val->bstrVal=SysAllocString(L"?");
			}
			else
			{
				delete val;
				return FALSE;
			}
			done++;
		}
		//this is a method of inputting arrays.
		//I have't gottent it entirely working yet.
		else if(tline.Find("props")==0)
		{
			if(tline.Find("{")!=-1)
				done2++;
			while(filein->ReadString(tline) && done2!=0)
			{
				if(tline.Find("{")!=-1)
					done2++;
				if(tline.Find("}")!=-1)
					done2--;
				if(tline.Find("array")!=-1)
				{
					done2=0;
					while(filein->ReadString(tline)&&done2<1)
					{
						if(tline.Find("size")!=-1)
						{	
							txt=tline.Mid(tline.Find('"')+1);
							txt=txt.SpanExcluding("\"");
							j=atoi(txt);
							val->vt=VT_BYREF|val->vt;
							
							switch(val->vt)
							{
							case VT_BYREF|VT_I2:
								val->piVal=new short[j];
								for(i=0;i<j;i++)
									val->piVal[i]=0;
								break;
							case VT_BYREF|VT_I4:
								val->plVal=new long[j];
								for(i=0;i<j;i++)
									val->plVal[i]=0;
								break;
							case VT_BYREF|VT_R4:
								val->pfltVal=new float[j];
								for(i=0;i<j;i++)
									val->pfltVal[i]=0.0f;
								break;
							case VT_BYREF|VT_R8:
								val->pdblVal=new double[j];
								for(i=0;i<j;i++)
									val->pdblVal[i]=0.0;
								break;
							}
							arraycount=j;
							
							done2++;
						}
					}
				}

				if(done2==0)
					break;
			}
			done2=0;
			done++;
		}
	}

	if(done<2)
		return FALSE;

	m_vars->SetAt(key,(void*)val);
	if(val->vt>VT_BYREF)
	{
		key+="_arraycount";
		val=new variant_t;
		val->vt=VT_I4;
		val->lVal=arraycount;
		m_vars->SetAt(key,(void*)val);
	}

	return TRUE;
}

void CStateMachine::ReadOneVar(VARIANT& val, CString txt, VARTYPE vt,int& arraycount)
{
	variant_t var;
	var.vt=val.vt;
	ReadOneVar(&var, txt, vt,arraycount);
	val=var;
}

void CStateMachine::ReadOneVar(variant_t *val, CString txt, VARTYPE vt, int& arraycount)
{
	double v[1];
	CString *sepvars;
	int i,idx,count;

	switch(vt)
	{
	case VT_I2:
		sscanf(txt,"%sd",(short*)v);
		*val=((short*)v)[0];
		break;
	case VT_I4:
		sscanf(txt,"%ld",(long*)v);
		*val=((long*)v)[0];
		break;
	case VT_R4:
		sscanf(txt,"%f",(float*)v);
		*val=((float*)v)[0];
		break;
	case VT_R8:
		sscanf(txt,"%lf",v);
		*val=v[0];
		break;
	case VT_BSTR:
		SysFreeString(val->bstrVal);
		val->bstrVal=txt.AllocSysString();
		break;
	case VT_BYREF|VT_I2:
		txt=txt.SpanExcluding("]");
		idx=txt.Find("[");
		txt=txt.Mid(idx+1);
		sepvars=SeparateVars(txt,count);
		val->piVal=new short[count];
		for(i=0;i<count;i++)
			val->piVal[i]=(short)atoi(sepvars[i]);
		arraycount=count;
		break;
	case VT_BYREF|VT_I4:
		txt=txt.SpanExcluding("]");
		idx=txt.Find("[");
		txt=txt.Mid(idx+1);
		sepvars=SeparateVars(txt,count);
		val->plVal=new long[count];
		for(i=0;i<count;i++)
			val->plVal[i]=atoi(sepvars[i]);
		arraycount=count;
		break;
	case VT_BYREF|VT_R4:
		txt=txt.SpanExcluding("]");
		idx=txt.Find("[");
		txt=txt.Mid(idx+1);
		sepvars=SeparateVars(txt,count);
		val->pfltVal=new float[count];
		for(i=0;i<count;i++)
			val->pfltVal[i]=(float)atof(sepvars[i]);
		arraycount=count;
		break;
	case VT_BYREF|VT_R8:
		txt=txt.SpanExcluding("]");
		idx=txt.Find("[");
		txt=txt.Mid(idx+1);
		sepvars=SeparateVars(txt,count);
		val->pdblVal=new double[count];
		for(i=0;i<count;i++)
			val->pdblVal[i]=atof(sepvars[i]);
		arraycount=count;
		break;
	default:
		break;			
	}


}

int CStateMachine::FindNextState()
{
	int i,j,deflt,tidx,next;
	state* stt;
	conn *cn;
	CString txt;
	
	deflt=-1;
	tidx=FindState(m_currstate);
	stt=m_fsm[tidx];
	for(i=0;i<stt->transitions.GetSize();i++)
	{
		cn=stt->transitions[i];
		j=cn->trigger.Find(";");
		if(j==-1)
			txt=cn->trigger;
		else
			txt=cn->trigger.Left(j);
		txt.TrimLeft();
		txt.TrimRight();

		if(txt=="Stop")
		{
			if(m_signal=="Stop")
			{
				if(j==-1)
					ResetVars();
				else
					UpdateVars(cn);
				m_signal="";
				return cn->endnum;
			}
		}
		else if(txt=="Reset")
		{
			if(m_signal=="Reset")
			{
				if(j==-1)
				{
					ResetVars();
					UpdateVars(m_firstconn);
				}
				else
					UpdateVars(cn);
				m_signal="";
				return cn->endnum;
			}
		}
		else if(txt=="Always")
		{
			UpdateVars(cn);
			return cn->endnum;
		}
		else if(txt=="Default")
			deflt=i;
		else
		{
			next=FindNext(cn);
			if(next!=-1)
			{
				if(txt.Find("Signal")==0 || txt.Find("signal")==0)
					m_signal="";
				return next;
			}
		}
	}

	if(deflt!=-1)
	{
		cn=stt->transitions[deflt];
		UpdateVars(cn);
		return cn->endnum;
	}
	
	//if this state only has the stop and reset transitions,
	//then the only way out is to take the stop transition,
	//even though the signal isn't to stop.
	if(stt->transitions.GetSize()==2)
	{
		cn=stt->transitions[0];
		j=cn->trigger.Find(";");
		if(j==-1)
			ResetVars();
		else
			UpdateVars(cn);
		m_signal="";
		return cn->endnum;		
	}

	return -1;
}

int CStateMachine::FindNext(conn* cn)
{
	int i,comptype;
	CString line,txt,txt2;
	CString key1,key2;
	variant_t *val1, *val2;
	VARTYPE vt,vt2;
	BOOL match,flag=FALSE;
	int j=0,idx,k;
	CString *sepvars;
	int count;

	//the first part of the transition line is the (set) of things that must match
	//these are all put before a semi-colon.
	line=cn->trigger.SpanExcluding(";");
	sepvars=SeparateVars(line,count);

	//only valid matches (with ISAC) are variable (in)equalities,
	//separated by commas. No arrays are allowed in the transition tests.
	//Using strings with less than/greater than works like strcmp.
	for(idx=0;idx<count;idx++)
	{
		match=FALSE;
		txt=sepvars[idx];

		//find the test symbol
		i=txt.FindOneOf("!=<>~");

		//the lhs will be before the test symbol
		key1=txt.SpanExcluding("!=<>~");
		key1.TrimLeft();
		key1.TrimRight();
		if(key1[0]=='?')
			key1=key1.Mid(1);

		//find the variable to match
		if(key1=="signal" || key1=="Signal")
		{
			val1=new variant_t;
			val1->vt=VT_BSTR;
			val1->bstrVal=m_signal.AllocSysString();
		}
		else if(!m_vars->Lookup(key1,(void*&)val1))
		{		
			txt2.Format("Invalid variable in transition test (lhs): %s, continuing",key1);
			AfxMessageBox(txt2);
			continue;
		}
		
		vt=val1->vt;
		if(vt>=VT_BYREF)
		{
			txt2.Format("No arrays allowed in transition test (lhs): %s, continuing",key1);
			AfxMessageBox(txt2);
			continue;
		}

		//the rhs will be after the test symbol (which might be two characters long
		txt2=line.Mid(i+1);
		if(txt2.FindOneOf("!=<>~")==0)
			txt2=txt2.Mid(1);
		txt2.TrimLeft();
		txt2.TrimRight();

		//this may or may not be an internal variable. If it is, find it, if not, read the variable from the text.
		if(txt2[0]=='?')
		{
			key2=txt2.Mid(1);
			if(!m_vars->Lookup(key2,(void*&)val2))
			{
				txt2.Format("Invalid variable in transition test (rhs): %s, continuing",key2);
				continue;
			}
			vt2=val2->vt;
			if(vt2>=VT_BYREF)
			{
				txt2.Format("No arrays allowed in transition test (rhs): %s, continuing",key2);
				continue;
			}
		}
		else
		{
			val2=new variant_t;
			if(val1->vt==VT_BSTR)
			{
				k=txt2.Find("\"");
				txt2=txt2.Mid(k+1);
				txt2=txt2.SpanExcluding("\"");
				val2->vt=VT_BSTR;
				val2->bstrVal=txt2.AllocSysString();
			}
			else
				ReadOneVar(val2,txt2,val1->vt,j);
			vt2=val2->vt;
			flag=TRUE;
		}

		//Now sort out the type of comparison by looking at the test symbol itself.
		txt2=txt.Mid(i);
		txt=txt2.SpanIncluding("!=<>~");
		if(txt=="="||txt=="==")
			comptype=1;
		else if(txt=="!="||txt=="~="||txt=="<>")
			comptype=0;
		else if(txt=="<="||txt=="=<")
			comptype=2;
		else if(txt==">="||txt=="=>")
			comptype=3;
		else if(txt=="<")
			comptype=4;
		else if(txt==">")
			comptype=5;
		else
			continue;

		//this actually performs the comparison
		switch(vt)
		{
		case VT_BSTR:  
			if(vt2==vt)
			{ 
				j=strcmp((bstr_t)val1,(bstr_t)val2);
				switch(comptype)
				{
				case 0:
					match=(j!=0);
					break;
				case 1:
					match=(j==0);
					break;
				case 2:
					match=(j<=0);
					break;
				case 3:
					match=(j>=0);
					break;
				case 4:
					match=(j<0);
					break;
				case 5:
					match=(j>0);
					break;
				}
			}
			break;
		case VT_I2:
			switch(comptype)
			{
			case 0:
				match=((short)(*val1)!=(short)(*val2));
				break;
			case 1:
				match=((short)(*val1)==(short)(*val2));
				break;
			case 2:
				match=((short)(*val1)<=(short)(*val2));
				break;
			case 3:
				match=((short)(*val1)>=(short)(*val2));
				break;
			case 4:
				match=((short)(*val1)<(short)(*val2));
				break;
			case 5:
				match=((short)(*val1)>(short)(*val2));
				break;
			}
			break;
		case VT_I4:
			switch(comptype)
			{
			case 0:
				match=((long)(*val1)!=(long)(*val2));
				break;
			case 1:
				match=((long)(*val1)==(long)(*val2));
				break;
			case 2:
				match=((long)(*val1)<=(long)(*val2));
				break;
			case 3:
				match=((long)(*val1)>=(long)(*val2));
				break;
			case 4:
				match=((long)(*val1)<(long)(*val2));
				break;
			case 5:
				match=((long)(*val1)>(long)(*val2));
				break;
			}
			break;
		case VT_R4:						
			switch(comptype)
			{
			case 0:
				match=((float)(*val1)!=(float)(*val2));
				break;
			case 1:
				match=((float)(*val1)==(float)(*val2));
				break;
			case 2:
				match=((float)(*val1)<=(float)(*val2));
				break;
			case 3:
				match=((float)(*val1)>=(float)(*val2));
				break;
			case 4:
				match=((float)(*val1)<(float)(*val2));
				break;
			case 5:
				match=((float)(*val1)>(float)(*val2));
				break;
			}
			break;
		case VT_R8:
			switch(comptype)
			{
			case 0:
				match=((double)(*val1)!=(double)(*val2));
				break;
			case 1:
				match=((double)(*val1)==(double)(*val2));
				break;
			case 2:
				match=((double)(*val1)<=(double)(*val2));
				break;
			case 3:
				match=((double)(*val1)>=(double)(*val2));
				break;
			case 4:
				match=((double)(*val1)<(double)(*val2));
				break;
			case 5:
				match=((double)(*val1)>(double)(*val2));
				break;
			}
			break;
		}
							
		//if an incorrect match was found, this isn't the right transition.
		//we might as well stop.
		if(match!=TRUE)
			break;
	}

	if(sepvars!=NULL)
		delete[] sepvars;

	//if we didn't stop early, then we've found the right transition. Update the variables,
	//then return the ending state. Otherwise, return -1.
	if(match==TRUE)
	{
		UpdateVars(cn);
		return cn->endnum;
	}
	else
		return -1;
}

variant_t CStateMachine::MakeString(CString eqn)
{
	variant_t retval;
	variant_t *val1;
	CString key1;
	CString txt;
	CString ret;
	int i,count;
	CString *sepvars;

	txt=eqn;
	txt.TrimLeft();
	txt.TrimRight();
	if(txt.IsEmpty())
	{
		retval.vt=VT_EMPTY;
		return retval;
	}

	retval.vt=VT_BSTR;
	ret.Empty();
	sepvars=SeparateVars(eqn,count,"+");
	for(i=0;i<count;i++)
	{
		key1=sepvars[i];
		if(key1[0]=='?')
		{
			key1=key1.Mid(1);
			if(m_vars->Lookup(key1,(void*&)val1))
			{
				if(val1->vt!=VT_BSTR)
				{
					retval.vt=VT_EMPTY;
					return retval;
				}
				ret+=val1->bstrVal;
			}
			else
			{
				retval.vt=VT_EMPTY;
				return retval;
			}
		}
		else
		{
			key1=key1.Mid(1);
			key1=key1.SpanExcluding("\"");
			ret+=key1;
		}

	}

	retval.bstrVal=ret.AllocSysString();
	return retval;
}

variant_t CStateMachine::TextToMath(CString equ,VARTYPE vt)
{
	variant_t retval;
	variant_t *val1;
	CString key1;
	CString txt;
	int i,j,k,idx,count;
	CString *sepvars;

	txt=equ;
	txt.TrimRight();
	txt.TrimLeft();
	if(txt.IsEmpty())
	{
		retval.vt=VT_EMPTY;
		return retval;
	}

	//Parse for parentheses
	txt=equ;
	i=txt.Find("(");
	j=txt.Find(")");
	k=-1;
	while(i!=-1)
	{
		//find an inner set of parentheses
		txt=txt.SpanExcluding(")");
		i=txt.ReverseFind('(');
		txt=txt.Mid(i+1);

		//find the result of that set
		k++;
		val1=new variant_t;
		key1.Format("tempvar%d",k);
		*val1=TextToMath(txt,vt);
		m_vars->SetAt(key1,val1);

		//put the variable name in place of the text
		equ=equ.Left(i)+"?"+key1+equ.Mid(j+1);
		txt=equ;
		i=txt.Find("(");
		j=txt.Find(")");
	}

	retval.vt=vt;
	sepvars=SeparateVars(equ,count,"+");
	if(count==1)
	{
		delete[] sepvars;
		sepvars=SeparateVars(equ,count,"-");
		if(count==1)
		{
			delete[] sepvars;
			sepvars=SeparateVars(equ,count,"*");
			if(count==1)
			{
				delete[] sepvars;
				sepvars=SeparateVars(equ,count,"/");
				if(count==1)
				{
					key1=sepvars[0];
					if(key1[0]=='?')
					{
						key1=key1.Mid(1);
						if(m_vars->Lookup(key1,(void*&)val1))
						{
							if(val1->vt!=vt)
							{
								ChangeType(val1,vt);
							}
							retval=*val1;
						}
						else
						{
							retval.vt=VT_EMPTY;
						}
					}
					else
					{
						ReadOneVar(&retval,key1,vt,i);
					}
				}
				else
				{
					retval=TextToMath(sepvars[0],vt);
					for(idx=1;idx<count;idx++)
					{
						switch(vt)
						{
						case VT_I2:
							retval=(short)((short)retval/(short)TextToMath(sepvars[idx],vt));
							break;
						case VT_I4:
							retval=(long)retval/(long)TextToMath(sepvars[idx],vt);
							break;
						case VT_R4:
							retval=(float)retval/(float)TextToMath(sepvars[idx],vt);
							break;
						case VT_R8:
							retval=(double)retval/(double)TextToMath(sepvars[idx],vt);
							break;
						}
					}
				}
				delete[] sepvars;
			}
			else
			{
				retval=TextToMath(sepvars[0],vt);
				for(idx=1;idx<count;idx++)
				{
					switch(vt)
					{
					case VT_I2:
						retval=(short)((short)retval*(short)TextToMath(sepvars[idx],vt));
						break;
					case VT_I4:
						retval=(long)retval*(long)TextToMath(sepvars[idx],vt);
						break;
					case VT_R4:
						retval=(float)retval*(float)TextToMath(sepvars[idx],vt);
						break;
					case VT_R8:
						retval=(double)retval*(double)TextToMath(sepvars[idx],vt);
						break;
					}
				}
				delete[] sepvars;
			}
		}
		else
		{
			retval=TextToMath(sepvars[0],vt);
			for(idx=1;idx<count;idx++)
			{
				switch(vt)
				{
				case VT_I2:
					retval=(short)((short)retval-(short)TextToMath(sepvars[idx],vt));
					break;
				case VT_I4:
					retval=(long)retval-(long)TextToMath(sepvars[idx],vt);
					break;
				case VT_R4:
					retval=(float)retval-(float)TextToMath(sepvars[idx],vt);
					break;
				case VT_R8:
					retval=(double)retval-(double)TextToMath(sepvars[idx],vt);
					break;
				}
			}
			delete[] sepvars;
		}
	}
	else
	{
		retval=TextToMath(sepvars[0],vt);
		for(idx=1;idx<count;idx++)
		{
			switch(vt)
			{
			case VT_I2:
				retval=(short)((short)retval+(short)TextToMath(sepvars[idx],vt));
				break;
			case VT_I4:
				retval=(long)retval+(long)TextToMath(sepvars[idx],vt);
				break;
			case VT_R4:
				retval=(float)retval+(float)TextToMath(sepvars[idx],vt);
				break;
			case VT_R8:
				retval=(double)retval+(double)TextToMath(sepvars[idx],vt);
				break;
			}
		}
		delete[] sepvars;
	}
	
	for(i=0;i<k;i++)
	{
		txt.Format("tempvar%d",i);
		m_vars->RemoveKey(txt);
	}

	return retval;
}			

//separate variables separated by the character(s) in sep (default ","), returning a CString 
//array and the number of variables (in count). Note: the returnval is declared "new" and must
//be deleted later to prevent memory leaks!
CString *CStateMachine::SeparateVars(CString in, int& count, CString sep)
{
	CString *retval=NULL;
	int i,j,k,idx;
	CString txt,txt2;

	count=0;
	txt=in;
	txt.TrimLeft();
	txt.TrimRight();
	if(txt.IsEmpty())
	{
		return retval;
	}

	i=txt.FindOneOf(sep);
	while(i!=-1)
	{
		j=txt.Find("\"");
		if(j!=-1 && j<i)
		{
			k=txt.Find("\"",j+1);
			txt=txt.Mid(k+1);
			i=txt.FindOneOf(sep);
		}
		else
		{
			j=txt.Find("[");
			if(j!=-1 && j<i)
			{
				k=txt.Find("]",j);
				txt=txt.Mid(k+1);
				i=txt.FindOneOf(sep);
			}
			else
			{
				count++;
				txt=txt.Mid(i+1);
				i=txt.FindOneOf(sep);
			}
		}
	}
	count++;

	retval=new CString[count];

	txt=in;
	txt.TrimLeft();
	txt.TrimRight();
	i=txt.FindOneOf(sep);
	idx=0;
	while(i!=-1)
	{
		j=txt.Find("\"");
		if(j!=-1 && j<i)
		{
			retval[idx].Empty();
			while(j!=-1 && j<i)
			{
				k=txt.Find("\"",j+1);
				retval[idx]+=txt.Left(k+1);
				txt=txt.Mid(k+1);
				i=txt.FindOneOf(sep);
				j=txt.Find("\"");
			}

			if(i!=-1)
			{
				txt=txt.Mid(i+1);
				i=txt.FindOneOf(sep);
			}
			else
				txt.Empty();
		
			idx++;
		}
		else
		{
			j=txt.Find("[");
			if(j!=-1 && j<i)
			{
				k=txt.Find("]",j+1);
				retval[idx]=txt.Left(k+1);
				txt=txt.Mid(k+1);
				i=txt.FindOneOf(sep);
				if(i!=-1)
				{
					txt=txt.Mid(i+1);
					i=txt.FindOneOf(sep);
				}
				else
					txt.Empty();
				idx++;
			}
			else
			{
				retval[idx]=txt.Left(i);
				txt=txt.Mid(i+1);
				i=txt.FindOneOf(sep);
				idx++;
			}
		}	
	}
	if(idx<count)
	{
		retval[idx]=txt;
	}

	for(idx=0;idx<count;idx++)
	{
		retval[idx].TrimLeft();
		retval[idx].TrimRight();
	}

	return retval;
}

void CStateMachine::UpdateVars(conn* cn)
{
	CString key,key1,key2;
	variant_t *val;
	variant_t inval;
	CString line,txt;
	int idx;
	int i,arraycount=0;
	CString *sepvars;
	int count;

	i=cn->trigger.Find(";");
	txt=cn->trigger.Mid(i+1);
	sepvars=SeparateVars(txt,count,";");

	for(idx=0;idx<count;idx++)
	{
		line=sepvars[idx];   //line is the full equation

		i=line.Find("=");

		//there must be a variable on the lhs
		key=line.SpanExcluding("=");
		key.TrimRight();
		key.TrimLeft();
		if(key[0]=='?')
			key=key.Mid(1);

		//There are several reasons why this next would fail, (including an increment/decrement) 
		//which is why the failure is handled later.
		if(m_vars->Lookup(key,(void*&)val))
		{
			txt=line.Mid(i+1);  //txt is the rhand-side
			txt.TrimLeft();
			if(val->vt==VT_BSTR)
			{
				inval=MakeString(txt);
			}
			else if(val->vt>VT_BYREF)
			{
				inval.vt=val->vt;
				ReadOneVar(&inval,txt,val->vt,arraycount);
			}
			else
				inval=TextToMath(txt,val->vt);

			if(inval.vt==VT_EMPTY)
			{
				continue;
			}
			else
			{
				if(val->vt==VT_BSTR)
					SysFreeString(val->bstrVal);
				else if(val->vt>=VT_BYREF)
				{
					switch(val->vt)
					{
					case VT_BYREF|VT_I2:
						delete val->piVal;
						break;
					case VT_BYREF|VT_I4:
						delete val->plVal;
						break;
					case VT_BYREF|VT_R4:
						delete val->pfltVal;
						break;
					case VT_BYREF|VT_R8:
						delete val->pdblVal;
						break;
					}
				}
					
				*val=inval;
				if(arraycount>0)
				{
					key=key+"_arraycount";
					m_vars->Lookup(key,(void* &)val);
					val->lVal=arraycount;
					arraycount=0;
				}
			}
		}
		else
		{
			i=line.Find("++");
			if(i!=-1)
			{
				key=line.SpanExcluding("+");
				if(m_vars->Lookup(key,(void*&)val))
				{
					if(val->vt==VT_I2)
						*val=(short)(((short)(*val))+1);
					else if(val->vt==VT_I4)
						*val=(long)(((long)(*val))+1);
				}
			}
			else
			{
				i=line.Find("--");
				if(i!=-1)
				{
					key=line.SpanExcluding("-");
					if(m_vars->Lookup(key,(void*&)val))
					{
						if(val->vt==VT_I2)
							*val=(short)(((short)(*val))-1);
						else if(val->vt==VT_I4)
							*val=(long)(((long)(*val))-1);
					}
				}
			}
		}
	}	
}

//implement this for arrays!
void CStateMachine::UpdateReturnVars(CString incomm, DISPPARAMS params, variant_t returnval)
{
	CString txt,txt2;
	int i,j;
	VARIANTARG *retval;
	variant_t *val;

	txt=incomm.Mid(incomm.ReverseFind(')')+1);
	if(!txt.IsEmpty())
	{
		txt.TrimRight();
		txt.TrimLeft();
		if(txt.Find("=>")==0)
		{
			txt2=txt.Mid(2);
			txt2.TrimLeft();
			if(txt2[0]=='?')
			{
				txt2=txt2.Mid(1);
				if(m_vars->Lookup(txt2,(void *&)val))
				{
					switch(returnval.vt)
					{
					case VT_EMPTY:
						val->vt=VT_EMPTY;
						break;
					case VT_I2:
						*val=(short)returnval;
						break;
					case VT_I4:
						*val=(long)returnval;
						break;
					case VT_R4:
						*val=(float)returnval;
						break;
					case VT_R8:
						*val=(double)returnval;
						break;
					default:
						val->vt=returnval.vt;
						val->pbVal=returnval.pbVal;
					}
				}
			}
			else
			{
				AfxMessageBox("Improper Syntax in command string (return variable)",MB_OK);
			}
		}
		
	}

	i=incomm.Find("(");
	txt=incomm.Mid(i+1);
	txt.TrimRight();
	txt=txt.Left(txt.GetLength()-1);
	txt.TrimRight();
	txt.TrimLeft();

	for(j=params.cArgs-1;j>=0;j--)
	{
		retval=&params.rgvarg[j];
		i=txt.ReverseFind(',');

		if(i==-1)
		{
			txt2=txt;
		}
		else
		{
			txt2=txt.Mid(i+1);
			txt2=txt2.SpanExcluding(",");
			txt=txt.Left(i);
		}

		txt2.TrimRight();
		txt2.TrimLeft();
		if(txt2[0]=='?')
		{
			txt2=txt2.Mid(1);
			if(txt2.Find("in")==0 || txt2.Find("retval")==0)
			{
				if(retval->vt==(VT_BYREF|VT_I4) && m_vars->Lookup(txt2,(void *&)val))
				{
					val->lVal=*retval->plVal;
				}
				else
					AfxMessageBox("Unreadable Return Variable",MB_OK);
			}
		}
	}
}

void CStateMachine::ResetVars()
{
	variant_t *val,*val2;
	VARTYPE vt;
	POSITION t;
	CString key,key2;
	int i,arraycount;
	
	t=m_vars->GetStartPosition();
	while(t!=NULL)
	{
		m_vars->GetNextAssoc(t,key,(void *&)val);
		vt=val->vt;
		if(key.Find("_arraycount")==-1)
		{
			if(vt>VT_BYREF)
			{
				key2=key+"_arraycount";
				m_vars->Lookup(key2,(void *&)val2);
				arraycount=val2->lVal;
			}

			switch(vt)
			{
			case VT_I2:
				val->iVal=0;
				break;
			case VT_I4:
				val->lVal=0;
				break;
			case VT_R4:
				val->fltVal=0.0f;
				break;
			case VT_R8:
				val->dblVal=0.0;
				break;
			case VT_BSTR:
				SysFreeString(val->bstrVal);
				val->bstrVal=SysAllocString(L"?");
				break;
			case VT_BYREF|VT_I2:
				for(i=0;i<arraycount;i++)
					val->piVal[i]=0;
				break;
			case VT_BYREF|VT_I4:
				for(i=0;i<arraycount;i++)
					val->plVal[i]=0;
				break;
			case VT_BYREF|VT_R4:
				for(i=0;i<arraycount;i++)
					val->pfltVal[i]=0.0f;
				break;
			case VT_BYREF|VT_R8:
				for(i=0;i<arraycount;i++)
					val->pdblVal[i]=0.0;
				break;				
			}
		}
	}
}

//implement this for arrays!
CString CStateMachine::InsertVars(CString in,int flag)
{
	CString out;
	int i;
	CString txt;
	CString key;
	variant_t *val;

	i=in.Find("?");
	if(i==-1)
		return in;


	out="";
	while(i!=-1)
	{
		out+=in.Left(i);
		key=in.Mid(i+1);
		key=key.SpanExcluding(" ';:.");
		in=in.Mid(i+key.GetLength()+1);

		if(key.Find("in")==0 && flag==1)
		{
			txt="?"+key;
		}
		else if(m_vars->Lookup(key,(void *&)val))
		{
			switch(val->vt)
			{
			case VT_BSTR:
				txt=val->bstrVal;
				break;
			case VT_I2:
				txt.Format("%d",val->iVal);
				break;
			case VT_I4:
				txt.Format("%d",val->lVal);
				break;
			case VT_R4:
				txt.Format("%.4g",val->fltVal);
				break;
			case VT_R8:
				txt.Format("%.6g",val->dblVal);
				break;
			case VT_ARRAY|VT_I2:
			case VT_ARRAY|VT_I4:
			case VT_ARRAY|VT_R4:
			case VT_ARRAY|VT_R8:
				txt="[]";
				break;				
			}
		}
		else
		{
//			txt.Format("Unknown Variable %s",key);
//			MessageBox(txt);
			txt="?"+key;
		}

		i=in.Find("?");
		out+=txt;
	}

	out+=in;
	return out;
}


//turns the data in the incoming variant to another type (e.g. char * to int)
//Implement arrays here!
void CStateMachine::ChangeType(variant_t *in,VARTYPE vt)
{
	CString txt;
	int arraycount;
	if(in->vt==vt)
		return;
	
	switch(in->vt)
	{
	case VT_I2:
		txt.Format("%d",(short)*in);
		break;
	case VT_I4:
		txt.Format("%d",(long)*in);
		break;
	case VT_R4:
		txt.Format("%.4g",(float)*in);
		break;
	case VT_R8:
		txt.Format("%.6g",(double)*in);
		break;
	case VT_BSTR: //string
		txt=in->bstrVal;
		break;
	}

	ReadOneVar(in,txt,vt,arraycount);
}

BSTR CStateMachine::CreateCommand(CString incomm, DISPPARAMS* params)
{
	BSTR fnname;
	CString txt,txt2,txt3;
	int i,j;
	unsigned int idx;
	variant_t *val;
	CString *sepvars;
	int count,arraycount;

	txt=incomm.SpanExcluding("(");
	fnname=txt.AllocSysString();

	txt=incomm.Mid(incomm.ReverseFind(')')+1);
	if(!txt.IsEmpty())
	{
		txt.TrimRight();
		txt.TrimLeft();
		if(txt.Find("=>")==0)
		{
			txt2=txt.Mid(2);
			txt2.TrimLeft();
			if(txt2[0]=='?')
			{
				txt2=txt2.Mid(1);
				if(!m_vars->Lookup(txt2,(void *&)val))
				{
					val=new variant_t;
					val->vt=VT_EMPTY;
					m_vars->SetAt(txt2,(void *)val);
				}
			}
			else
			{
				AfxMessageBox("Improper Syntax in command string (return variable)",MB_OK);
			}
		}
		
	}

	params->cArgs=0;
	i=incomm.Find("(");
	txt=incomm.Mid(i+1);
	txt.TrimRight();
	txt=txt.Left(txt.ReverseFind(')'));
	txt.TrimRight();
	txt.TrimLeft();

	sepvars=SeparateVars(txt,count);
	params->cArgs=count;

	if(count>0)
		params->rgvarg=new VARIANTARG[params->cArgs];
	else
		params->rgvarg=NULL;

	for(i=count-1;i>=0;i--)
	{
		idx=count-i-1;

		txt2=sepvars[i];
		if(txt2[0]=='?')
		{
			txt2=txt2.Mid(1);
			if(txt2.Find("in")==0 || txt2.Find("retval")==0)
			{
				params->rgvarg[idx].vt=VT_BYREF|VT_R8;
		 		params->rgvarg[idx].pdblVal=new double;
				if(!m_vars->Lookup(txt2,(void *&)val))
				{
					val=new variant_t;
					val->vt=VT_BYREF|VT_R8;
					m_vars->SetAt(txt2,(void *)val);
				}
			}
			else
			{
				if(m_vars->Lookup(txt2,(void *&)val))
				{
					params->rgvarg[idx].vt=val->vt;
					switch(val->vt)
					{
					case VT_I2:
						params->rgvarg[idx].iVal=(short)*val;
						break;
					case VT_I4:
						params->rgvarg[idx].lVal=(long)*val;
						break;
					case VT_R4:
						params->rgvarg[idx].fltVal=(float)*val;
						break;
					case VT_R8:
						params->rgvarg[idx].dblVal=(double)*val;
						break;
					case VT_BSTR:
						params->rgvarg[idx].bstrVal=(bstr_t)*val;
						break;
					case VT_BYREF|VT_I2:
						params->rgvarg[idx].piVal=val->piVal;
						break;
					case VT_BYREF|VT_I4:
						params->rgvarg[idx].plVal=val->plVal;
						break;
					case VT_BYREF|VT_R4:
						params->rgvarg[idx].pfltVal=val->pfltVal;
						break;
					case VT_BYREF|VT_R8:
						params->rgvarg[idx].pdblVal=val->pdblVal;
						break;
					}
				}
				else
				{
					txt.Format("Variable %s does not exist: %s",txt2,incomm);
					AfxMessageBox(txt);
					return NULL;
				}
			}
		}
		else
		{
			if(txt2[0]=='\"' || txt2.Find("(string)")==0 || txt2.Find("(BSTR)")==0)
			{
				params->rgvarg[idx].vt=VT_BSTR;
				j=txt2.Find("\"");
				txt2=txt2.Mid(j+1);
				txt2=txt2.SpanExcluding("\"");
				params->rgvarg[idx].bstrVal=txt2.AllocSysString();
			}
			else if(txt2[0]=='[' || txt2.Find("(double *)")==0 || txt2.Find("(double*)")==0 || 
									txt2.Find("(int *)")==0 || txt2.Find("(int*)")==0)
			{
				if(txt2.Find(".")!=-1 || txt2.Find("(double *)")==0 || txt2.Find("(double*)")==0)
				{
					params->rgvarg[idx].vt=VT_BYREF|VT_R8;
					j=txt2.Find("[");
					txt3=txt2.Mid(j);
					ReadOneVar(params->rgvarg[idx],txt3,VT_BYREF|VT_R8,arraycount);
				}
				else
				{
					params->rgvarg[idx].vt=VT_BYREF|VT_I4;
					j=txt2.Find("[");
					txt3=txt2.Mid(j);
					ReadOneVar(params->rgvarg[idx],txt3,VT_BYREF|VT_I4,arraycount);
				}
			}
			else if(txt2.Find(".")!=-1 || txt2.Find("(double)")==0)
			{
				params->rgvarg[idx].vt=VT_R8;
				j=txt2.FindOneOf("-.1234567890");
				txt3=txt2.Mid(j);
				params->rgvarg[idx].dblVal=atof(txt3);
			}
			else
			{
				params->rgvarg[idx].vt=VT_I4;
				j=txt2.FindOneOf("-1234567890");
				txt3=txt2.Mid(j);
				params->rgvarg[idx].lVal=atoi(txt3);
				
			}
		}			
	}


/*	if(idx!=params->cArgs)
	{
		txt.Format("Problem with number of parameters: %s",incomm);
		AfxMessageBox(txt);
		return fnname;
	}
*/

	params->rgdispidNamedArgs=NULL;
	params->cNamedArgs=0;
	return fnname;
}

UINT CStateMachine::RunSM(LPVOID param)
{
	CStateMachine *obj=(CStateMachine *)param;
	obj->LocalRunSM();
	return 0;
}

void CStateMachine::LocalRunSM()
{
	CString txt;
	IComponent* agentcomp;
	IDispatch* agentdisp;
	ILocator* locallocator;
	BSTR component;
	BSTR function;
	DISPID fnid;
	DISPPARAMS params={NULL,NULL,0,0};
	variant_t returnval;
	UINT ArgError;
	HRESULT hRes=0;
	BOOL quit=FALSE;
	int next;
	
	int tidx,i;

	hRes=CoGetInterfaceAndReleaseStream(m_LocStream,IID_ILocator,(void **)&locallocator);

	tidx=FindState(m_currstate);
	state *currstate=m_fsm[tidx];
	command *comm;

	while(currstate->name!="Stop")
	{
		for(i=0;i<currstate->commands.GetSize();i++)
		{
			comm=currstate->commands[i];
			component=comm->componentname.AllocSysString();
			hRes=locallocator->Locate(component,&agentcomp);
//			agentcomp=comm->component;
			if(agentcomp==NULL)
			{
//				if(Reconnect())
//				{
					txt.Format("Quitting\r\nCannot locate component: %s\r\nIn state: %s",comm->componentname,currstate->name);
					AfxMessageBox(txt);
					m_signal="Stop";
					break;
//				}
			}
			hRes=agentcomp->QueryInterface(IID_IDispatch,(void **)&agentdisp);
			if(agentdisp==NULL)
			{
				txt.Format("Quittint\r\nUnable to get IDispatch interface: %s\r\nIn state: %s\r\nError code: %x",comm->componentname,currstate->name,hRes);
				AfxMessageBox(txt);
				m_signal="Stop";
				break; 
			}

			//Turn command string into params structure and function name.
			function=CreateCommand(comm->function, &params);
			if(function==NULL)
			{
				txt.Format("Quitting\r\nInvalid command format: %s\r\nIn state: %s",comm->function,currstate->name);
				AfxMessageBox(txt);
				m_signal="Stop";
				break;
			}

			hRes=agentdisp->GetIDsOfNames(IID_NULL,&function,1,0,&fnid);
			if(fnid==-1)
			{
				txt.Format("Quitting\r\nFunction not found: %s\r\nIn state: %s",comm->function,currstate->name);
				AfxMessageBox(txt);
				SysFreeString(component);
				SysFreeString(function);
				if(params.rgvarg!=NULL)
				{
					delete params.rgvarg;
					params.cArgs=0;
					params.rgvarg=NULL;
				}
				m_signal="Stop";
				break;
			}
			else
			{
				try
				{
					hRes=agentdisp->Invoke(fnid,IID_NULL,LOCALE_SYSTEM_DEFAULT,DISPATCH_METHOD,&params,&returnval,NULL,&ArgError);
				}
				catch(...)
				{
					txt.Format("Immediate Stop. Unhandled Exception while calling function.\r\nFunction: %s\r\nComponent: %s\r\nIn State: %s",comm->function,comm->componentname,currstate->name);
					AfxMessageBox(txt);
					quit=TRUE;
					break;
				}
			}
			
			if(params.cArgs!=0 || returnval.vt!=VT_EMPTY)
			{
				UpdateReturnVars(comm->function,params,returnval);
			}

			SysFreeString(component);
			SysFreeString(function);
			if(params.rgvarg!=NULL)
			{
				delete params.rgvarg;
				params.cArgs=0;
				params.rgvarg=NULL;
			}
		}

		if(quit==TRUE)
		{
			break;
		}
	
		next=FindNextState();
		if(next==-1)
		{
			m_wait=TRUE;
			return;
		}
		else
		{
			m_currstate=next;
		}

		tidx=FindState(m_currstate);
		currstate=m_fsm[tidx];
	}

	m_currstate=-1;
	m_reset=FALSE;

	return;
}

//Returns the m_fsm index whose associated state that has the input shapeid
int CStateMachine::FindState(int shapeid)
{
	int i;
	for(i=0;i<m_numstates;i++)
	{
		if(shapeid==m_fsm[i]->shapeid)
			return i;
	}
	return -1;
}

STDMETHODIMP CStateMachine::get_FileName(BSTR *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	
	_bstr_t temp;
	temp=(LPCTSTR)m_filename;

	*pVal=temp.copy();

	return S_OK;
}

STDMETHODIMP CStateMachine::put_FileName(BSTR newVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	m_filename=newVal;
	return S_OK;
}

STDMETHODIMP CStateMachine::get_NumStates(long *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	*pVal=m_fsm.GetSize();
	return S_OK;
}

STDMETHODIMP CStateMachine::LoadSM()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	if(!m_filename.IsEmpty())
		LoadFile();

	return S_OK;
}

STDMETHODIMP CStateMachine::Start()
{
	m_currstate=m_firstconn->endnum;
	UpdateVars(m_firstconn);

//if(Reconnect()==S_OK)
	HRESULT hRes=CoMarshalInterThreadInterfaceInStream(IID_ILocator,m_Locator,&m_LocStream);
	if(hRes==0)
		AfxBeginThread(RunSM,this);
	else
	{
		AfxMessageBox("Threading Problem. Cannot transfer Agent Locator.\r\nError Code: 0x%x",hRes);
	}
	
	return S_OK;
}



STDMETHODIMP CStateMachine::Reset()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	Signal(L"Reset");

	return S_OK;
}

STDMETHODIMP CStateMachine::Stop()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	Signal(L"Stop");

	return S_OK;
}

STDMETHODIMP CStateMachine::get_CurrentState(BSTR *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	_bstr_t temp;
	int tidx;

	if(m_currstate!=-1)
	{
		tidx=FindState(m_currstate);
		if(m_wait==TRUE)
			temp=(LPCTSTR)(m_fsm[tidx]->name+", Waiting");
		else
			temp=(LPCTSTR)m_fsm[tidx]->name;		
	}
	else
	{
		if(m_fsm.GetSize()==0)
			temp="Unloaded";
		else if(m_wait==TRUE)
			temp="Waiting";
		else
			temp="Stopped";
	}

	*pVal=temp.copy();

	return S_OK;
}




STDMETHODIMP CStateMachine::Signal(BSTR signal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	if(m_wait==TRUE)
	{
		m_signal=signal;
		m_currstate=FindNextState();
		if(m_currstate!=-1)
		{
			m_wait=FALSE;
			HRESULT hRes=CoMarshalInterThreadInterfaceInStream(IID_ILocator,m_Locator,&m_LocStream);
			if(hRes==0)
				AfxBeginThread(RunSM,this);
			else
			{
				AfxMessageBox("Threading Problem. Cannot transfer Agent Locator.\r\nError Code: 0x%x",hRes);
			}
		}
	}
	else
	{
		m_signal=signal;
	}

	return S_OK;
}



STDMETHODIMP CStateMachine::Reconnect()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	
	int i,j;
	state *stt;
	command *comm;
	HRESULT retval=S_OK;
	CString txt;
	
	if(m_currstate==-1)
		return S_OK;

	for(i=0;i<m_fsm.GetSize();i++)
	{
		stt=m_fsm[i];
		for(j=0;j<stt->commands.GetSize();j++)
		{
			comm=stt->commands[j];
			m_Locator->Locate(comm->componentname.AllocSysString(),&(comm->component));
			if(comm->component==NULL)
			{
				txt.Format("Unable to find component: %s\r\nIn state: %s",comm->componentname,stt->name);
				AfxMessageBox(txt);
				retval=E_FAIL;
			}
		}
	}

	return retval;
}
