// ComputeGoalPos.cpp : Implementation of CComputeGoalPos
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A note about this template:
// This template is autogenerated. The template code can be found in \ProgramFiles\MicrosoftVisualStudio\Common\MSDev\Templates\ATL
// Specifically customized for an IMA 2.5 component.
// Created by Juan Rojas. Jan 08.
//
// You can also look at an example compenent created by Christina Campbell at O:\Components\ExampleComp
// If you are just learning look at that component to see more details than those included in this template.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "math.h"
#include "IMA2_HP3JCAssemblyPositionLib.h"
#include "ComputeGoalPos.h"

// Define Robots
#define		HP3JC 0
#define		ISAC  1

#define		SUCCESS 1
#define		FAILURE 0
/////////////////////////////////////////////////////////////////////////////
// CComputeGoalPos
// 
// Include Class comments.
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
// CComputeGoalPos::OnConstruct() 
// OnConstruct() is called when the component is created. If you are going to connect 
// another component anywhere in your code, you need to set up bindings. 
//
// The following code will create one binding. Change "DescriptiveName" to some
// appropriate string. This string will be visible as the name of the binding from
// DAD. It is *not* the name of the component you will bind to. The name of the
// specific component on the other end of the binding is determined at runtime (in DAD).
//
// If you wish to allow only one component to connect to this binding, make the BindType
// BT_Default. If you wish to allow several components, make the BindType BT_Collection.
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComputeGoalPos::OnConstruct()
{
	// Local variables
	int numiids			= 1;
	long x[1];
	x[0] = 0;

	IMA2_BindingInfo	BindInf;				// Structure BindInf of type IMA2_BindingInfo

	// SafeArray properties
	SAFEARRAYBOUND		SafeArrayBoundIn[1];	// We're making a one-dimensional SafeArray
	SafeArrayBoundIn[0].lLbound		= 0;		// Our SafeArray starts at index 0
	SafeArrayBoundIn[0].cElements	= 1;		// There is just one element

	// ** Error **/
	BindInf.Name		= SysAllocString(L"ImageError");					
	BindInf.BindType	= BT_Default;											// Condition to accept a single binding
	BindInf.Path		= SysAllocString(L"");									// This is the path of the component you are connecting to
	BindInf.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, 1);					// Create an empty string array
	BindInf.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);			// Create an empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));	
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	

	// Free Binding Info
	SysFreeString(BindInf.Name);
	SysFreeString(BindInf.Path);
	SafeArrayDestroy(BindInf.PIDs);
	SafeArrayDestroy(BindInf.IIDs);

	// ** LeftCentroid **/
	BindInf.Name		= SysAllocString(L"LeftCentroid");					
	BindInf.BindType	= BT_Default;											// Condition to accept a single binding
	BindInf.Path		= SysAllocString(L"");									// This is the path of the component you are connecting to
	BindInf.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, 1);					// Create an empty string array
	BindInf.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);			// Create an empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));	
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	

	// Free Binding Info
	SysFreeString(BindInf.Name);
	SysFreeString(BindInf.Path);
	SafeArrayDestroy(BindInf.PIDs);
	SafeArrayDestroy(BindInf.IIDs);

	// ** RightCentroid **/
	BindInf.Name		= SysAllocString(L"RightCentroid");					
	BindInf.BindType	= BT_Default;											// Condition to accept a single binding
	BindInf.Path		= SysAllocString(L"");									// This is the path of the component you are connecting to
	BindInf.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, 1);					// Create an empty string array
	BindInf.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);			// Create an empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));	
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	

	// Free Binding Info
	SysFreeString(BindInf.Name);
	SysFreeString(BindInf.Path);
	SafeArrayDestroy(BindInf.PIDs);
	SafeArrayDestroy(BindInf.IIDs);

	// ** 3DOutput **/
	BindInf.Name		= SysAllocString(L"3DOutput");					
	BindInf.BindType	= BT_Default;											// Condition to accept a single binding
	BindInf.Path		= SysAllocString(L"");									// This is the path of the component you are connecting to
	BindInf.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, 1);					// Create an empty string array
	BindInf.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);			// Create an empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));	
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	

	// Free Binding Info
	SysFreeString(BindInf.Name);
	SysFreeString(BindInf.Path);
	SafeArrayDestroy(BindInf.PIDs);
	SafeArrayDestroy(BindInf.IIDs);

	// ** HeadDemoStateMachine **/
	BindInf.Name		= SysAllocString(L"HeadDemoStateMachine");					
	BindInf.BindType	= BT_Default;											// Condition to accept a single binding
	BindInf.Path		= SysAllocString(L"");									// This is the path of the component you are connecting to
	BindInf.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, 1);					// Create an empty string array
	BindInf.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);			// Create an empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"StateMachineProj.StateMachine"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IStateMachine"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	

	// Free Binding Info
	SysFreeString(BindInf.Name);
	SysFreeString(BindInf.Path);
	SafeArrayDestroy(BindInf.PIDs);
	SafeArrayDestroy(BindInf.IIDs);

	// ** LeftColorSegmenter **/
	BindInf.Name		= SysAllocString(L"LeftColorSegmenter");					
	BindInf.BindType	= BT_Default;											// Condition to accept a single binding
	BindInf.Path		= SysAllocString(L"");									// This is the path of the component you are connecting to
	BindInf.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, 1);					// Create an empty string array
	BindInf.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);			// Create an empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_ColorSegmenterLib.ColorSegmenter"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IColorSegmenter"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	

	// Free Binding Info
	SysFreeString(BindInf.Name);
	SysFreeString(BindInf.Path);
	SafeArrayDestroy(BindInf.PIDs);
	SafeArrayDestroy(BindInf.IIDs);

	// ** RightColorSegmenter **/
	BindInf.Name		= SysAllocString(L"RightColorSegmenter");					
	BindInf.BindType	= BT_Default;											// Condition to accept a single binding
	BindInf.Path		= SysAllocString(L"");									// This is the path of the component you are connecting to
	BindInf.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, 1);					// Create an empty string array
	BindInf.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);			// Create an empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_ColorSegmenterLib.ColorSegmenter"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IColorSegmenter"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	

	// Free Binding Info
	SysFreeString(BindInf.Name);
	SysFreeString(BindInf.Path);
	SafeArrayDestroy(BindInf.PIDs);
	SafeArrayDestroy(BindInf.IIDs);

  return S_OK;
}
STDMETHODIMP CComputeGoalPos::OnDestruct() {	return S_OK; }
//////////////////////////////////////////////////////////////////////////////////////////
// CComputeGoalPos::Save(VARIANT *pData)
// This method is called by DAD when a component is saved. Items that should be saved are the
// ones that are important to the setup of the code, or user options that should hold over
// from one use of an agent to another. (Example: size of data, filenames, etc.) 
//
// For each variable to be saved, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to GetPropertyBag). Change the
// term "DescriptiveName" to something descriptive of the item you are saving, and make
// sure not to reuse names. In the next line of code, change "m_MyPrivateVariable" to the variable
// you are saving and VarType to the VarType of that value. Valid types and VarTypes are:
// (Note: These are limited by VB/OLE compatibility, not by the list of things that Variants can be.)
// short:	VT_I2
// int:		VT_I4
// float:	VT_R4
// double:	VT_R8
// BSTR:	VT_BSTR
// char:	VT_BYTE
// All strings (char*) should be converted to BSTR (see BSTR documentation).
// A CString can be converted to a BSTR using the member function AllocSysString (see CString documentation)
//
// If you want to save an array, you have to assign a SAFEARRAY to the Variant. (Do NOT just
// use a pointer, it will save just one value). replace the line starting "ItemValue =" with the following 
// code (substituting your pointer for "variable", the array length for "numelem", int/float/double, etc. 
// for "Type", and using the VarType of one element of the array--BSTR arrays are not allowed.):
//
//	ItemValue = new variant_t;
//	ItemValue->vt=VT_ARRAY|VarType;
//	ItemValue->parray=SafeArrayCreateVector(VarType,0,numelem);
//  memcpy(ItemValue->parray->pvData,variable,numelem*sizeof(Type));
//
// Note: "delete ItemValue" will take care of destroying the safearray (do *not* call SafeArrayDestroy).
// Because of the nature of a SafeArray, you do not have to explicitly save the length of the array.
// However, due to the nature of property bags, you must call the array version of the Add function:
//
//  hRes = pIPB->AddArrayToPropertyBag(&ItemName, ItemValue);
//
// (See Load comments for how to extract arrays from the propertybag).
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComputeGoalPos::Save(VARIANT *pData) {
	// Variables
/*	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	variant_t				*ItemValue;
	_PropertyBagWrapper		*pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		if (pIPB == NULL)	
			return !S_OK;
		
		// **START**
		// Create string names for items to be saved
		// Number of Elements
		ItemName = SysAllocString(L"DescriptiveName");
		// Store the data and the type of data into a variant_t type
 		ItemValue = new variant_t(m_YourPrivateVariableName,VT_I4);
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**
		// Returns a pointer to the PropertyBag as a VARIANT
		hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
		
		// Copy the contents of the property bag to the pData VARIANT
		VariantCopy(pData, &m_VBPropertyBag);
		// Save the size of the data 
		m_lDataSize = pData->parray->rgsabound[0].cElements;		
		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);
		
		// Release
		pIPB->Release();
		*/
	return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////
// CComputeGoalPos::Load(VARIANT Data)
// This function will load in all the data you just saved in the Save function.
// 
// For each variable to be loaded, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to VariantClear). Change the
// term "NameUsedToSave" to the name you gave this item in Save.
// On the line beginning "variable = ", change "variable" to the variable that you saved
// the value from, and change "Type" to the type of that variable (use "long" for "int")
// A CString can be directly set to a BSTR, but in order to get a char* back, you have to 
// use strcpy (I think).
//
// If you made an array, you have to load it back in now.
// Just like in the save function, you must call the array version of the Get function:
//
//  pIPB->GetArrayFromPropertyBag(&ItemName, ItemValue);
//
// If your variable is dynamically allocated, make sure to delete and reallocate it:
//
//  if(variable!=NULL)
//		delete variable;
//  variable=new Type[ItemValue->parray->rgsabound->cElements];	
//
// Then just copy the values from the parray (replace the "variable =" line with this):
//
//  memcpy(variable,ItemValue->parray->pvData,ItemValue->parray->rgsabound->cElements*sizeof(Type));
//
// Note that this means you do not have to separately save the length of the array, although if
// you have a variable that keeps track of the array length you should also set it at this point:
//
//  numelem=ItemValue->parray->rgsabound->cElements;
//
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComputeGoalPos::Load(VARIANT Data) {
	
	// Variables
/*	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	_PropertyBagWrapper*	pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	variant_t				*ItemValue;
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		if (pIPB == NULL)	
			return !S_OK;
		// Get the pointer to the real VB property bag (the VB object (defined in msvbvm60.dll (aka VBRUN)) that our wrapper class created)
		// hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
		
		// Pass Data to PropertyBag
		hRes = pIPB->SetPropertyBag(&Data);
		// **START**
		// Variable m_lNumElements
		// Define strings
		ItemName		= SysAllocString(L"NameUsedToSave");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetFromPropertyBag(&ItemName,ItemValue);  //2nd argument is return value (look retval for help)
		m_YourPrivateVariableName	= (long)*ItemValue;
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**
		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);
		
		// Release
		pIPB->Release();
*/		
return S_OK;
}

/*****************************************************************
/* ErrorThreshold()
/* Get/Set error threshold from user.
/* This threshold is used to check the stability of the head
/* before we get the 3DPosition generated by the angles in the
/* Pan-Tilt system for a gazed object.
*****************************************************************/
/*STDMETHODIMP CComputeGoalPos::get_ErrorThreshold(double *pVal)
{
	*pVal = m_dThreshold;
	return S_OK;
}

STDMETHODIMP CComputeGoalPos::put_ErrorThreshold(double newVal)
{
	if(newVal >= 0 && newVal <= 1)
		m_dThreshold = newVal;

	return S_OK;
}
*/
/**********************************************************
/* ComputeGoalPosition()
/*
/* ** This function is used in the Assembly Demonstration **
/* This function is in charge of directing commands to the 
/* DemoStateMachine of the HeadAgent to compute the distances 
/* for both of the goal targets in the assembly task.
/*
/* Those targets are the HP3JC tool end-point position, and
/*                       ISACs tool end-point position.
/*
/* (1) Get HP3JC's Position: GetPosition(bool WhatRobot)
/*     This function will be monitoring the change in centroid position 
/*     vector which is part of the ColorSegmenter object in the Left and
/*     Right Camera Agents. The following functions are performed:
/*
/*     a) CheckHeadStability(): 
/*		  If the centroid position of both 
/*        vectors does not change over a threshold, we have a measure 
/*        of head stability and can go ahead and compute the cartesian 
/*        position recorded by the 3DOutput vector in the Head Agent.
/*     b) SaveCartesianPosition(bool WhatRobot)
/*
/* (2) Once the Cartesian position is recorded we want to:
/*     -- Not necessary after testing ------ a) Stop the state machines in the HeadTracking Agent,
/*     b) Reset parameters in the Head and Camera Agents,
/*     c) Write the new color model file name to the ColorSegmenter objects, and
/*     d) Start the DemoStateMachine in the HeadTracking Agent again.
/*
/* (3) Get ISAC's Position: GetPosition(bool WhatRobot)
/*     Same as (1)
/*
/* (4) Compute the desired goal position for HP3JC: ComputeHP3JCTransform()
/*     As part of the Control Basis of the HP3JC, the position controller
/*	   requests a desired cartesian goal position to move too.
/*
/*	   This desired position is computed as:
/*	   HP3JC's home position + (HP3JC 3DPosition - ISAC 3DPosition)
/*	   Note: some of the parameters need sign adjustments to agree 
/*
/*	NOTE: After testing it was noted that the SM calls lead the SM to crash.
/*		  We also noted that this is not really necessary. The system works
/*		  well by just switching the color model file name. 
/*		  A series of flags were added to only carry out necessary operations
/*		  upon execution.
/**********************************************************/
STDMETHODIMP CComputeGoalPos::ComputeGoalPosition()
{
	// Check to see if our goal has been found. If it has not, then proceed.
	if(m_bGoalHasBeenFound == 1)
		return S_OK;

	// This next flag checks to identify if we need to find the position for the HP3JC or ISAC
	if(m_bHP3JC == 0)
	{
		// Check head stability, to get the original goal position.
		// If the head is not stable, then all other operations should be aborted.
		// The state machine will continue to call this routine indefinitely.
		retVal = CheckHeadStability(BLUE_COLOR);

		// Only proceed if the head is stable.
		// Get the HP3JC tool end-point cartesian position
		if(retVal)
		{
			retVal = GetPosition(HP3JC);

			// Write the new color model to both ColorSegmenter components in the Camera Agents for ISAC.
			if(retVal)
			{
				retVal = WriteNewColorModel(GREEN_COLOR);

				Sleep(2500);						// Give the system some time to adjust
				m_bHP3JC = 1;						// Set the flag indicating that the position for the HP3JC has been found.

				return S_OK;
			}

			else 
				return !S_OK;
		}

		return !S_OK;					// Head was not stable
	}

	/*********************** ISAC ********************************/
	// Check head stability, to get the new goal position.
	retVal = CheckHeadStability(GREEN_COLOR);

	// Get the HP3JC tool end-point cartesian position
	if(retVal)
	{
		retVal = GetPosition(ISAC);

		// Finally, compute the HP3JC Transform
		if(retVal)
		{
			retVal = ComputeHP3JCTransform();
			m_bGoalHasBeenFound = 1;
			return S_OK;						// SUCCESSFULLY COMPLETED THE TASK
		}

		else 
			return !S_OK;						// Could not return the position
	}

	else
		return !S_OK;							// Head was not stable
}

/******************************************************************************
/* CheckHeadStability(): 
/* 1) Connect to the Centroid Vector Signals of the L & R Camera Agents.
/* 2) Get centroid error
/* 3) Set thresholds and record min value
/* 4) Check to see if error measure is lower than selected threshold
******************************************************************************/
short CComputeGoalPos::CheckHeadStability(short TypeOfColorModel)
{
	// Local variables
	SAFEARRAY* mysa;

	// 1) ***** Get Component and Interface Pointers *****
	m_Bindings->get_Pointers(SysAllocString(L"LeftCentroid"),&IUnkLeftCentroidPtr);
	m_Bindings->get_Pointers(SysAllocString(L"RightCentroid"),&IUnkRightCentroidPtr);
	//m_Bindings->get_Pointers(SysAllocString(L"ImageError"),&IUnkError);

	if(IUnkLeftCentroidPtr == NULL || IUnkRightCentroidPtr == NULL /*|| IUnkError == NULL*/)
	{
		MessageBox(NULL,"Binding Missing", "Centroid bindings in CheckHeadStability() are missing.", MB_OK);
		return !S_OK;
	}

	// Get Interface pointers
	IUnkLeftCentroidPtr->QueryInterface(IID_IVectorSignal, (void**)&pILC);
	IUnkRightCentroidPtr->QueryInterface(IID_IVectorSignal, (void**)&pIRC);
	//IUnkError->QueryInterface(IID_IVectorSignal, (void**)&pIError);

	if(pILC == NULL || pIRC == NULL /*|| pIError == NULL*/)
	{
		MessageBox(NULL,"Interface Error", "The interface selected in CheckHeadStability() is not a Vector Signal.", MB_OK);
		return !S_OK;
	}

	// Get Centroid values:
	// Left
	mysa = SafeArrayCreateVector(VT_R8,0,2);
	pILC->GetCurrentVector(mysa);
	memcpy(m_dLeftCentroid,mysa->pvData,sizeof(double)*2);

	// Right 
	pIRC->GetCurrentVector(mysa);
	memcpy(m_dRightCentroid,mysa->pvData,sizeof(double)*2);

	// Deallocate safearray and interface pointer
	SafeArrayDestroy(mysa);
	pILC->Release();
	pILC = NULL;

	pIRC->Release();
	pIRC = NULL;

	// 2) ***** Check for stability *****

	// All centroids when they have reached their goal are at (0.5,0.5) (ie the middle of the screen)
	// Might want to consider 0.5 * Error^2
	m_dCentroidError[0] = fabs(0.5 - m_dLeftCentroid[0]); //  - 0.5;
	m_dCentroidError[1] = fabs(0.5 - m_dLeftCentroid[1]); //  - 0.5;

	m_dCentroidError[2] = fabs(0.5 - m_dRightCentroid[0]); // - 0.5;
	m_dCentroidError[3] = fabs(0.5 - m_dRightCentroid[1]); // - 0.5;

	// Accumulate error in left and right variables
	m_dErrorLeft  = (m_dCentroidError[0] + m_dCentroidError[1])/2;
	m_dErrorRight = (m_dCentroidError[2] + m_dCentroidError[3])/2;


	// 3) *** Set THRESHOLD & HISTORY ***** /
	// Set respective threshold values and figure out minimim error value for blue or green color models *** 

	// BlUE
	if(TypeOfColorModel == BLUE_COLOR)
	{
		// Set the threshold value depending on the color histogram. This is so, because the cameras recognize blue easier than green. We can have a lower threshold with blue.
		m_dThreshold = m_dThresholdBlue;	
		
		// SAVE LOWEST VALUE OF ERROR FOR EVERY CONTIGUOUS VALUE OF ERROR. THIS EFFECTIVELY WILL GIVE US THE MIN VALUE IN A TRIAL AND HELP DETERMINE THE LOWEST TRESHOLD
		// Left Side
		if(fabs(m_dErrorLeft) < fabs(m_dPrevErrorLeft))
		{
			m_dMinErrorBlue[0] = m_dErrorLeft;
			m_dPrevErrorLeft   = m_dErrorLeft;			// Update the previous error to the current one
		}
		else
		{
			m_dMinErrorBlue[0] = m_dPrevErrorLeft;		// No need here given that the previous error was smaller
		}

		// Right Side
		if(fabs(m_dErrorRight) < fabs(m_dPrevErrorRight))
		{
			m_dMinErrorBlue[1] = m_dErrorRight;
			m_dPrevErrorLeft   = m_dErrorRight;			// Update the previous error to the current one

		}
		else
		{
			m_dMinErrorBlue[1] = m_dPrevErrorRight;
		}

	}

	// GREEN
	if(TypeOfColorModel == GREEN_COLOR)
	{
		// Set the threshold value depending on the color histogram. This is so, because the cameras recognize blue easier than green. We can have a lower threshold with blue.
		m_dThreshold = m_dThresholdGreen;	
		
		// SAVE LOWEST VALUE OF ERROR FOR EVERY CONTIGUOUS VALUE OF ERROR. THIS EFFECTIVELY WILL GIVE US THE MIN VALUE IN A TRIAL AND HELP DETERMINE THE LOWEST TRESHOLD
		// Left Side
		if(fabs(m_dErrorLeft) < fabs(m_dPrevErrorLeft))
			m_dMinErrorGreen[0] = m_dErrorLeft;
		else
			m_dMinErrorGreen[0] = m_dPrevErrorLeft;

		// Right Side
		if(fabs(m_dErrorRight) < fabs(m_dPrevErrorRight))
			m_dMinErrorGreen[1] = m_dErrorRight;
		else
			m_dMinErrorGreen[1] = m_dPrevErrorRight;
	}

	// 4) ***** CHECK AGAINST THRESHOLD **** /
	// Both the left and the right error are checked against a single threshold value. Could expand to have BL, BR, GL, GR.
	if((fabs(m_dErrorLeft) < m_dThreshold) && (fabs(m_dErrorRight)  < m_dThreshold))
	{
		m_bStable = true;
		return SUCCESS;
	}

	else
	{
		m_bStable = false;
		return FAILURE;

	}
}

/*************************************************************
/* GetPosition(bool WhatRobot)
/* Gets the 3D Cartesian position for either the HP3JC
/* or ISAC robot by copying the value from the 3DOutput
/* component in the HeadAgent.
*************************************************************/
short CComputeGoalPos::GetPosition(bool WhatRobot)
{
	// Local variables
	SAFEARRAY* mysa;

	// 1) ***** Get Component and Interface Pointers to 3DOutput VS*****
	m_Bindings->get_Pointers(SysAllocString(L"3DOutput"),&IUnk3dOuputPtr);

	if(IUnk3dOuputPtr == NULL)
	{
		MessageBox(NULL,"Binding Missing", "3DOutput bindings in GetPosition() is missing.", MB_OK);
		return !S_OK;
	}

	// Get Interface pointers
	IUnk3dOuputPtr->QueryInterface(IID_IVectorSignal, (void**)&pI3D);

	if(pI3D == NULL)
	{
		MessageBox(NULL,"Interface Error", "The interface selected in GetPosition() is not a Vector Signal.", MB_OK);
		return !S_OK;
	}

	// Save position value according to what robot we have

	// Create safe array variable
	mysa = SafeArrayCreateVector(VT_R8,0,3);
	pI3D->GetCurrentVector(mysa);

	if(WhatRobot == HP3JC)
		memcpy(m_dHP3JC_3D_Output,mysa->pvData,sizeof(double)*3);

	else if(WhatRobot == ISAC)
		memcpy(m_dISAC_3D_Output,mysa->pvData,sizeof(double)*3);

	else
	{	
		// Deallocate memory
		SafeArrayDestroy(mysa);
		pI3D->Release();
		pI3D = NULL;

		return FAILURE;
	}

	// Dealocate memory and release pointer to interface
	SafeArrayDestroy(mysa);
	pI3D->Release();
	pI3D = NULL;

	return SUCCESS;
}

/*************************************************************
/* StopSM(bool stable)
/* Call the Stop method on the DemoStateMachine in the HeadTracking Agent to stop ALL
/* other statemachines and events in all agents.
*************************************************************/
short CComputeGoalPos::StopSM(bool stable)
{
	// 1) ***** Get Component and Interface Pointers to 3DOutput VS*****
	m_Bindings->get_Pointers(SysAllocString(L"HeadDemoStateMachine"),&IUnkStateMachinePtr);

	if(IUnkStateMachinePtr == NULL)
	{
		MessageBox(NULL,"Binding Missing", "State Machine bindings in StopSm() is missing.", MB_OK);
		return !S_OK;
	}

	// Get Interface pointers
	IUnkStateMachinePtr->QueryInterface(IID_IStateMachine, (void**)&pISM);

	if(pISM == NULL)
	{
		MessageBox(NULL,"Interface Error", "The interface selected in StopSM() is not a StateMachine Interface.", MB_OK);
		return !S_OK;
	}	

	// Call the Stop method on the DemoStateMachine in the HeadTracking Agent to stop ALL
	// other statemachines and events in all agents.
	pISM->Stop();

	return SUCCESS;
}

short CComputeGoalPos::StartSM()
{
	// 1) ***** Get Component and Interface Pointers to 3DOutput VS*****
	m_Bindings->get_Pointers(SysAllocString(L"HeadDemoStateMachine"),&IUnkStateMachinePtr);

	if(IUnkStateMachinePtr == NULL)
	{
		MessageBox(NULL,"Binding Missing", "State Machine bindings in StartSm() is missing.", MB_OK);
		return !S_OK;
	}

	// Get Interface pointers
	IUnkStateMachinePtr->QueryInterface(IID_IStateMachine, (void**)&pISM);

	if(pISM == NULL)
	{
		MessageBox(NULL,"Interface Error", "The interface selected in StartSM() is not a StateMachine Interface.", MB_OK);
		return !S_OK;
	}	

	// Call the Start method on the DemoStateMachine in the HeadTracking Agent to start ALL
	// other statemachines and events in all agents.
	pISM->Start();

	return SUCCESS;
}

/***********************************************************
/* WriteNewColorModel()
/*
/* This function writes a color model file path to the 
/* ColorModelFileName([in] BSTR) property.
/*
/* The type of color model that is loaded, is hard coded, and if
/* a different one is desired the user needs to hard-code the new
/* model.
/*
/* This function:
/* 1) Connects to both right and left ColorSegmenter components
/* 2) Sets the string for the new path, and
/* 3) Initializes the respective components to LOAD the new 
/*    color model.
***********************************************************/
short CComputeGoalPos::WriteNewColorModel(short TypeOfColorModel)
{
	// Local Variables
	HRESULT hRes1, hRes2;
	BSTR bstr_ColorModelFileName = NULL;
	
	// For blue color model
	if(TypeOfColorModel == BLUE_COLOR)
	{
		// Create a B-string using the string path to the desired color model.
		// PurpleHologram color model file path.
		bstr_ColorModelFileName = SysAllocString(L"O:\\Tools\\Cameras\\ColorModels\\HologramRibbons\\Blue\\blueholog001.rgn");
	}

	else
		bstr_ColorModelFileName = SysAllocString(L"O:\\Tools\\Cameras\\ColorModels\\HologramRibbons\\Green\\greenholog001.rgn");


	// 1) ***** Connect to the two ColorSegmenter Components and to their interfaces *****
	m_Bindings->get_Pointers(SysAllocString(L"LeftColorSegmenter"),&IUnkLeftColorSegPtr);
	m_Bindings->get_Pointers(SysAllocString(L"RightColorSegmenter"),&IUnkRightColorSegPtr);

	if(IUnkLeftColorSegPtr == NULL || IUnkRightColorSegPtr == NULL)
	{
		MessageBox(NULL,"Binding Missing", "ColorSegmenter bindings in WriteNewColorModel() are missing.", MB_OK);
		return FAILURE;
	}

	// Get Interface pointers
	IUnkLeftColorSegPtr->QueryInterface(IID_IColorSegmenter, (void**)&pILCS);
	IUnkRightColorSegPtr->QueryInterface(IID_IColorSegmenter, (void**)&pIRCS);

	if(pILCS == NULL || pIRCS == NULL)
	{
		MessageBox(NULL,"Interface Error", "The interface selected in WriteNewColorModel() is not of type ColorSegmenter.", MB_OK);
		return FAILURE;
	}

	// ***** 2) Set the name of the color model file *****
	hRes1 = pILCS->put_ColorModelFileName(bstr_ColorModelFileName);
	hRes2 = pIRCS->put_ColorModelFileName(bstr_ColorModelFileName);

	// Check for errors
	if(hRes1 != S_OK || hRes2 != S_OK )
	{
		MessageBox(NULL,"ColorModel File Path Error", "WriteNewColorModel() did not set the file path for the new color model.", MB_OK);
		return FAILURE;
	}
	
	// ***** 3) Initialize the ColorSegmenter components *****
	hRes1 = pILCS->Initialize();
	hRes2 = pIRCS->Initialize();

	// Check for errors
	if(hRes1 != S_OK || hRes2 != S_OK )
	{
		MessageBox(NULL,"ColorModel File Path Error", "WriteNewColorModel() did not call CColorSegmenter::Initialize().", MB_OK);
		return FAILURE;
	}

	// Deallocate safearray and interface pointer
	pILCS->Release();
	pIRCS->Release();
	
	pILCS = NULL;
	pIRCS = NULL;	

	return SUCCESS;

}

/******************************************************************************
/* ComputeHP3JCTransform()
/* Compute the desired goal position for HP3JC: ComputeHP3JCTransform()
/* As part of the Control Basis of the HP3JC, the position controller
/* requests a desired cartesian goal position to move too.
/*
/* This desired position is computed as:
/* (HP3JC 3DPosition - ISAC 3DPosition)
/* Note: The HP3JC robot will add this difference to its current position.
/*
/* As of Dec 2008, connecting components accross computers is not possible.
/* Hence, the resulting position will be written to a file that will be read
/* by a relevant component. 
/* The file will be saved at: O:\Demos\AssemblyDemo\GoalPosition.txt
/******************************************************************************/
short CComputeGoalPos::ComputeHP3JCTransform()
{
	// Compute the goal position
	m_dGoalPosition[0] =  m_dHP3JC_3D_Output[0] - m_dISAC_3D_Output[0];
	m_dGoalPosition[1] =  m_dHP3JC_3D_Output[1] - m_dISAC_3D_Output[1];
	m_dGoalPosition[2] = -1*(m_dHP3JC_3D_Output[2] - m_dISAC_3D_Output[2]);	// negative sign necessary to compensate for ISACs -Z values under  his eyes

	// Open the file where the path will be saved
	m_fp = fopen("O:\\Demos\\AssemblyDemo\\GoalPosition.txt", "w+t");

	// Write the goal positions
	for(int i=0; i<3; i++)		
		fprintf(m_fp,"%f\t", m_dGoalPosition[i]);

	// Close 
	if(m_fp!=NULL) 
	{
		fclose(m_fp);
		m_fp = NULL;
	}

	// Tell the local state machine to stop

	// Get object and interface pointer
	m_Bindings->get_Pointers(SysAllocString(L"HeadDemoStateMachine"), &IUnkStateMachinePtr);

	// Check for errors
	if(IUnkStateMachinePtr == NULL )
	{
		MessageBox(NULL,"State Machine Binding error", "ComputeHP3JCTransform() did not bind to the HP3JC state machine", MB_OK);
		return FAILURE;
	}

	IUnkStateMachinePtr->QueryInterface(IID_IStateMachine, (void**)&pISM);

	// Check for errors
	if(pISM == NULL )
	{
		MessageBox(NULL,"Interface error", "ComputeHP3JCTransform() You have tried to connect with an interface that does not exist", MB_OK);
		return FAILURE;
	}

	// Call the signal to stop the local statemachine
	pISM->Stop();

	// Release the pointer
	pISM->Release();
	pISM = NULL;

	// Also, place the blue color model again. It helps to re-run the algorithm without having to quit and start again.
	WriteNewColorModel(BLUE_COLOR);


	return SUCCESS;
}

///////////////////////////////////////////////////////
// This property reads the error used in the 
// ::CheckHeadStability() function.
// Error is the variable that determines when
// the new color model is loaded.
///////////////////////////////////////////////////////
/*STDMETHODIMP CComputeGoalPos::get_Error(double *pVal)
{
	// TODO: Add your implementation code here
	*pVal = m_dError;
	return S_OK;
}

STDMETHODIMP CComputeGoalPos::put_Error(double newVal)
{
	m_dError = newVal;
	return S_OK;
}
*/