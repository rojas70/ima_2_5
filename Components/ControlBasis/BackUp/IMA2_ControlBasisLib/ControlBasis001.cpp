// ControlBasis.cpp : Implementation of CControlBasis
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A note about this template:
// This template is autogenerated. The template code can be found in \ProgramFiles\MicrosoftVisualStudio\Common\MSDev\Templates\ATL
// Specifically customized for an IMA 2.5 component.
// Created by Juan Rojas. Jan 08.
//
// You can also look at an example compenent created by Christina Campbell at O:\Components\ExampleComp
// If you are just learning look at that component to see more details than those included in this template.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "IMA2_ControlBasisLib.h"
#include "ControlBasis.h"

/////////////////////////////////////////////////////////////////////////////
// CControlBasis
// 
// Include Class comments.
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
// CControlBasis::OnConstruct() 
// OnConstruct() is called when the component is created. In addition to putting in
// whatever initialization code you need, If you are going to connect to another
// component anywhere in your code, you need to set up bindings. 
//
// The following code will create one binding. Change "DescriptiveName" to some
// appropriate string. This string will be visible as the name of the binding from
// DAD. It is *not* the name of the component you will bind to. The name of the
// specific component on the other end of the binding is determined at runtime (in DAD).
//
// If you wish to allow only one component to connect to this binding, make the BindType
// BT_Default. If you wish to allow several components, make the BindType BT_Collection.
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CControlBasis::OnConstruct()
{
// TODO: Bindings. Personalize the binding of your component. 
	IMA2_BindingInfo	BindInf;

	long x[1] = { 0 };
	SAFEARRAYBOUND		SafeArrayBoundIn[1];										// We're making a one-dimensional SafeArray
	SafeArrayBoundIn[0].lLbound		= 0;											// Our SafeArray starts at index 0
	SafeArrayBoundIn[0].cElements	= 1;

	// **START**
	// 1. Dominant Controller - Desired Input Vector
	BindInf.Name		= SysAllocString(L"DomCont_DesiredInput");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// 2. Dominant Controller - Actual Input Vector
	BindInf.Name		= SysAllocString(L"DomCont_ActualInput");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// 3. Dominant Controller - Output Vector
	BindInf.Name		= SysAllocString(L"DomCont_Output");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// 4. Subordinate Controller - Desired Input Vector
	BindInf.Name		= SysAllocString(L"SubCont_DesiredInput");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// 5. Subordinate Controller - Actual Input Vector
	BindInf.Name		= SysAllocString(L"SubCont_ActualInput");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// 6. Subordinate Controller - Output Vector
	BindInf.Name		= SysAllocString(L"SubCont_Output");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// 7. JointAngle
	BindInf.Name		= SysAllocString(L"ActualAngle");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// Deallocate storage
	SysFreeString(BindInf.Name);
	SysFreeString(BindInf.Path);
	SafeArrayDestroy(BindInf.PIDs);
	SafeArrayDestroy(BindInf.IIDs);
  return S_OK;
}
STDMETHODIMP CControlBasis::OnDestruct() {	return S_OK; }
//////////////////////////////////////////////////////////////////////////////////////////
// CControlBasis::Save(VARIANT *pData)
// This method is called by DAD when a component is saved. Items that should be saved are the
// ones that are important to the setup of the code, or user options that should hold over
// from one use of an agent to another. (Example: size of data, filenames, etc.) 
//
// For each variable to be saved, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to GetPropertyBag). Change the
// term "DescriptiveName" to something descriptive of the item you are saving, and make
// sure not to reuse names. In the next line of code, change "m_MyPrivateVariable" to the variable
// you are saving and VarType to the VarType of that value. Valid types and VarTypes are:
// (Note: These are limited by VB/OLE compatibility, not by the list of things that Variants can be.)
// short:	VT_I2
// int:		VT_I4
// float:	VT_R4
// double:	VT_R8
// BSTR:	VT_BSTR
// char:	VT_BYTE
// All strings (char*) should be converted to BSTR (see BSTR documentation).
// A CString can be converted to a BSTR using the member function AllocSysString (see CString documentation)
//
// If you want to save an array, you have to assign a SAFEARRAY to the Variant. (Do NOT just
// use a pointer, it will save just one value). replace the line starting "ItemValue =" with the following 
// code (substituting your pointer for "variable", the array length for "numelem", int/float/double, etc. 
// for "Type", and using the VarType of one element of the array--BSTR arrays are not allowed.):
//
//	ItemValue = new variant_t;
//	ItemValue->vt=VT_ARRAY|VarType;
//	ItemValue->parray=SafeArrayCreateVector(VarType,0,numelem);
//  memcpy(ItemValue->parray->pvData,variable,numelem*sizeof(Type));
//
// Note: "delete ItemValue" will take care of destroying the safearray (do *not* call SafeArrayDestroy).
// Because of the nature of a SafeArray, you do not have to explicitly save the length of the array.
// However, due to the nature of property bags, you must call the array version of the Add function:
//
//  hRes = pIPB->AddArrayToPropertyBag(&ItemName, ItemValue);
//
// (See Load comments for how to extract arrays from the propertybag).
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CControlBasis::Save(VARIANT *pData) {
	// Variables
	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	variant_t				*ItemValue;
	_PropertyBagWrapper		*pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		if (pIPB == NULL)	
			return !S_OK;
/*		
		// **START**
		// Create string names for items to be saved
		// Number of Elements
		ItemName = SysAllocString(L"DescriptiveName");
		// Store the data and the type of data into a variant_t type
 		ItemValue = new variant_t(m_YourPrivateVariableName,VT_I4);
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**
		// Returns a pointer to the PropertyBag as a VARIANT
		hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
		
		// Copy the contents of the property bag to the pData VARIANT
		VariantCopy(pData, &m_VBPropertyBag);
		// Save the size of the data 
		m_lDataSize = pData->parray->rgsabound[0].cElements;		
		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);
		
		// Release
		pIPB->Release();
*/
	return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////
// CControlBasis::Load(VARIANT Data)
// This function will load in all the data you just saved in the Save function.
// 
// For each variable to be loaded, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to VariantClear). Change the
// term "NameUsedToSave" to the name you gave this item in Save.
// On the line beginning "variable = ", change "variable" to the variable that you saved
// the value from, and change "Type" to the type of that variable (use "long" for "int")
// A CString can be directly set to a BSTR, but in order to get a char* back, you have to 
// use strcpy (I think).
//
// If you made an array, you have to load it back in now.
// Just like in the save function, you must call the array version of the Get function:
//
//  pIPB->GetArrayFromPropertyBag(&ItemName, ItemValue);
//
// If your variable is dynamically allocated, make sure to delete and reallocate it:
//
//  if(variable!=NULL)
//		delete variable;
//  variable=new Type[ItemValue->parray->rgsabound->cElements];	
//
// Then just copy the values from the parray (replace the "variable =" line with this):
//
//  memcpy(variable,ItemValue->parray->pvData,ItemValue->parray->rgsabound->cElements*sizeof(Type));
//
// Note that this means you do not have to separately save the length of the array, although if
// you have a variable that keeps track of the array length you should also set it at this point:
//
//  numelem=ItemValue->parray->rgsabound->cElements;
//
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CControlBasis::Load(VARIANT Data) {
	
	// Variables
	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	_PropertyBagWrapper*	pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	variant_t				*ItemValue;
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		if (pIPB == NULL)	
			return !S_OK;
		// Get the pointer to the real VB property bag (the VB object (defined in msvbvm60.dll (aka VBRUN)) that our wrapper class created)
		// hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
/*		
		// Pass Data to PropertyBag
		hRes = pIPB->SetPropertyBag(&Data);
		// **START**
		// Variable m_lNumElements
		// Define strings
		ItemName		= SysAllocString(L"NameUsedToSave");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetFromPropertyBag(&ItemName,ItemValue);  //2nd argument is return value (look retval for help)
		m_YourPrivateVariableName	= (long)*ItemValue;
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**
		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);
		
		// Release
		pIPB->Release();
*/		
	return S_OK;
}


/************************************************************************
****************************** Properties *******************************
************************************************************************/

/****************************************************
* ErrorMessage()
* Used to print the status of the program and help the
* user see what is happening in the system in RT.
*
* The variable m_bstrError should be updated in member
* functions whenever the developper wants to print a 
* message.
*
* The PUT function is empty as we don't need the input
* of the user.
****************************************************/
STDMETHODIMP CControlBasis::get_ErrorMessage(BSTR *pVal)
{
	if (pVal != NULL)
		*pVal = m_bstrError;
	return S_OK;
}

STDMETHODIMP CControlBasis::put_ErrorMessage(BSTR newVal)
{
	// Keep empty. We don't want the user to change this.
	m_bstrError = SysAllocString(L"This component controlls valves and has PID or NN Controller");

	return S_OK;
}

/****************************************************
* WhatRobot()
* Indicates what robot we are using. There are two 
* possible options: ISAC and HP3JC.
*
* 1) Function receives a string
* 2) Converts to lower case
* 3) Assigns a flag to identify selected robot.
* 4) Calls a functions that sets all the parameters
*    (gains) for the assigned robot.
*
* Error: if user types an unrecognized robot, the 
* prompt will ask the user to input either ISAC or
* HP3JC.
****************************************************/
STDMETHODIMP CControlBasis::get_WhatRobot(BSTR *pVal)
{
	if(pVal != NULL)
		SysReAllocString(&(*pVal),m_bstrWhatRobot);//*pVal = m_bstrWhatRobot;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_WhatRobot(BSTR newVal)
{
	USES_CONVERSION;	// Macro to use string conversions
	// Set tags for internal variable
	if(strcmp(strupr(OLE2T(newVal)),"ISAC")==0)
	{
		m_sWhatRobot = ISAC_ROBOT;
		m_bstrWhatRobot = SysAllocString(L"ISAC");
	}

	else if(strcmp(strupr(OLE2T(newVal)),"HP3JC")==0)
	{
		m_sWhatRobot = HP3JC_ROBOT;
		m_bstrWhatRobot = SysAllocString(L"HP3JC");
	}

	// Otherwise do not copy to local variable and print warning message
	else
		m_bstrError = SysAllocString(L"Please either enter ISAC or HP3JC");

	return S_OK;
}

/****************************************************
* cont_NumControllers()
* Indicates how many controllers are in use. We can 
* have a minimum of 1 and a maximum of 2;
*
* If only 1 controller is used, then clear the string
* tag for the subordinate controller. Do this by calling
* put_cont_SubcONTType()
****************************************************/
STDMETHODIMP CControlBasis::get_cont_NumControllers(short *pVal)
{
	if(pVal != NULL)
		*pVal = m_sNumControllers;		

	return S_OK;
}

STDMETHODIMP CControlBasis::put_cont_NumControllers(short newVal)
{
	// Verify that we are only selecting 1 or 2 controllers.
	if(newVal < 1 || newVal > 2)
		m_bstrError = SysAllocString(L"Select 1 or 2 controllers.");
	else
		m_sNumControllers = newVal;

	// Clear the string tag of the subordinate controller and flag internal variable
	if (newVal == 1)
	{
		put_cont_SubContType( SysAllocString(L"NONE") );
		m_sWhichIsSubController = NOT_ACTIVE;
	}

	else
		m_bstrError = SysAllocString(L"You have selected 2 controllers.");


	return S_OK;
}

/****************************************************
* cont_DomContType()
* This function will read a string input provided by
* the user. The string can either read POSITION, FORCE
* or MOMENT.
*
* This string will indicate that that type of controller
* will be the dominant one for this program.
*
* After passing a valid string, a flag will be assigned
* that identifies the user selection.
*
* If the string contains a wrong name, an warning message
* will print through DAD's interface message property.
****************************************************/
STDMETHODIMP CControlBasis::get_cont_DomContType(BSTR *pVal)
{
	// Select the position controller 
	if (m_sWhichIsDomController == DOMINANT_POSITION_CONTROLLER)
			*pVal = SysAllocString(L"POSITION");
	
	// Select the force controller
	if (m_sWhichIsDomController == DOMINANT_FORCE_CONTROLLER)
			*pVal = SysAllocString(L"FORCE");
	
	// Select the moment controller
	if (m_sWhichIsDomController == DOMINANT_MOMENT_CONTROLLER)
			*pVal = SysAllocString(L"MOMENT");

	return S_OK;
}

STDMETHODIMP CControlBasis::put_cont_DomContType(BSTR newVal)
{
	USES_CONVERSION;

	// Select position controller as dominant
	if(strcmp(strupr(OLE2T(newVal)),"POSITION")==0)
	{
		m_sWhichIsDomController = DOMINANT_POSITION_CONTROLLER;
		m_bstrError = SysAllocString(L"The POSITION controller was selected to be dominant.");
	}

	// Select force controller as dominant
	else if (strcmp(strupr(OLE2T(newVal)), "FORCE") == 0 )
	{
		m_sWhichIsDomController = DOMINANT_FORCE_CONTROLLER;
		m_bstrError = SysAllocString(L"The FORCE controller was selected to be dominant.");
	}

	// Select moment controller as dominant
	else if (strcmp( strupr(OLE2T(newVal)), "MOMENT") == 0 )
	{
		m_sWhichIsDomController = DOMINANT_MOMENT_CONTROLLER;
		m_bstrError = SysAllocString(L"The MOMENT controller was selected to be dominant.");
	}

	else
		m_bstrError = SysAllocString(L"Please type either POSITION, FORCE, or MOMENT.");		

	return S_OK;
}

/****************************************************
* get_cont_SubContType()
* This function will read a string input provided by
* the user. The string can either read POSITION, FORCE,
* MOMENT, or NONE.
*
* This string will indicate that that type of controller
* will be the subordinate one for this program if it exists.
*
* After passing a valid string, a flag will be assigned
* that identifies the user selection.
*
* If the string contains a wrong name, an warning message
* will print through DAD's interface message property.
****************************************************/
STDMETHODIMP CControlBasis::get_cont_SubContType(BSTR *pVal)
{
	// Select the position controller 
	if (m_sWhichIsSubController == SUBORDINATE_POSITION_CONTROLLER)
			*pVal = SysAllocString(L"POSITION");
	
	// Select the force controller
	if (m_sWhichIsSubController == SUBORDINATE_FORCE_CONTROLLER)
			*pVal = SysAllocString(L"FORCE");
	
	// Select the moment controller
	if (m_sWhichIsSubController == SUBORDINATE_MOMENT_CONTROLLER)
			*pVal = SysAllocString(L"MOMENT");

	// Select None
	if (m_sWhichIsSubController == NOT_ACTIVE)
		*pVal = SysAllocString(L"NONE");

	return S_OK;
}

STDMETHODIMP CControlBasis::put_cont_SubContType(BSTR newVal)
{
	USES_CONVERSION;

	// Select position controller as subordinate
	if ( strcmp( strupr(OLE2T(newVal)), "POSITION") == 0 )
	{
		m_sWhichIsSubController = SUBORDINATE_POSITION_CONTROLLER;
		m_bstrError = SysAllocString(L"The POSITION controller was selected to be subordinate.");
		m_sNumControllers = 2; // Indicate that there are two controllers
	}

	// Select force controller as subordinate
	else if ( strcmp( strupr(OLE2T(newVal)), "FORCE") == 0 )
	{
		m_sWhichIsSubController = SUBORDINATE_FORCE_CONTROLLER;
		m_bstrError = SysAllocString(L"The FORCE controller was selected to be subordinate.");
		m_sNumControllers = 2; // Indicate that there are two controllers
	}

	// Select moment controller as subordinate
	else if ( strcmp( strupr(OLE2T(newVal)), "MOMENT") == 0 )
	{
		m_sWhichIsSubController = SUBORDINATE_MOMENT_CONTROLLER;
		m_bstrError = SysAllocString(L"The MOMENT controller was selected to be subordinate.");
		m_sNumControllers = 2; // Indicate that there are two controllers
	}

	// Select none
	else if ( strcmp( strupr(OLE2T(newVal)), "NONE") == 0 )
	{
		m_sWhichIsSubController = NOT_ACTIVE;
		m_sNumControllers = 1;
		m_bstrError = SysAllocString(L"The subordinate controller has been de-activated.");
	}

	else
		m_bstrError = SysAllocString(L"Please type either POSITION, FORCE, MOMENT, or NONE.");		


	return S_OK;
}

/****************************************************
* Gain_Indeces()
* Contain the indeces for the different gains. 
* Value has to be between 0 and 5.
****************************************************/
STDMETHODIMP CControlBasis::get_gain_PositionGainIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sPositionGainIndex;
	
	return S_OK;
}

STDMETHODIMP CControlBasis::put_gain_PositionGainIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sPositionGainIndex = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_gain_ForceGainIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sForceGainIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_gain_ForceGainIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sForceGainIndex = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_gain_MomentGainIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sMomentGainIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_gain_MomentGainIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sMomentGainIndex = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_gain_InverseTorqueGainIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sInverseTorqueGainIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_gain_InverseTorqueGainIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sInverseTorqueGainIndex = newVal;

	return S_OK;
}

/****************************************************
* gain_PositionGain()
* Retrieves the value for the position gain depending 
* on the robot selected. 
****************************************************/
STDMETHODIMP CControlBasis::get_gain_PositionGain(double *pVal)
{
	if (pVal != NULL)
		*pVal = m_dPositionGain[m_sPositionGainIndex];
	return S_OK;
}

STDMETHODIMP CControlBasis::put_gain_PositionGain(double newVal)
{
	m_dPositionGain[m_sPositionGainIndex] = newVal;
	return S_OK;
}

STDMETHODIMP CControlBasis::get_gain_ForceGain(double *pVal)
{
	if (pVal != NULL)
		*pVal = m_dForceGain[m_sForceGainIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_gain_ForceGain(double newVal)
{
	m_dForceGain[m_sForceGainIndex] = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_gain_MomentGain(double *pVal)
{
	if (pVal != NULL)
		*pVal = m_dMomentGain[m_sMomentGainIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_gain_MomentGain(double newVal)
{
	m_dMomentGain[m_sMomentGainIndex] = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_gain_InverseTorqueGain(double *pVal)
{
	if (pVal != NULL)
		*pVal = m_dInverseTorqueGain[m_sInverseTorqueGainIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_gain_InverseTorqueGain(double newVal)
{
	m_dInverseTorqueGain[m_sInverseTorqueGainIndex] = newVal;

	return S_OK;
}

/****************************************************
* Dominant: Vector_Indeces()
* Contain the indeces for the different gains. 
* Value has to be between 0 and 5.
****************************************************/
STDMETHODIMP CControlBasis::get_dom_DesiredVectorIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sDomCont_DesInputIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_dom_DesiredVectorIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sDomCont_DesInputIndex = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_dom_ActualVectorIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sDomCont_ActualInputIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_dom_ActualVectorIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sDomCont_ActualInputIndex = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_dom_OutputVectorIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sDomCont_OutputIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_dom_OutputVectorIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sDomCont_OutputIndex = newVal;

	return S_OK;
}
/****************************************************
* Dominant: Desired, Actual, Output Vectors()
* Reads and prints values for vectors.
*
* Values of vectors must be doubles.
****************************************************/
STDMETHODIMP CControlBasis::get_dom_DesiredVector(double *pVal)
{
	if(pVal != NULL)
		*pVal = m_dDomCont_DesInput[m_sDomCont_DesInputIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_dom_DesiredVector(double newVal)
{
	m_dDomCont_DesInput[m_sDomCont_DesInputIndex] = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_dom_ActualVector(double *pVal)
{
	if(pVal != NULL)
		*pVal = m_dDomCont_ActualInput[m_sDomCont_ActualInputIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_dom_ActualVector(double newVal)
{
	m_dDomCont_ActualInput[m_sDomCont_ActualInputIndex] = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_dom_OutputVector(double *pVal)
{
	if(pVal != NULL)
		*pVal = m_dDomCont_Output[m_sDomCont_OutputIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_dom_OutputVector(double newVal)
{
	m_dDomCont_Output[m_sDomCont_OutputIndex] = newVal;

	return S_OK;
}

/****************************************************
* Subordinate: Vector_Indeces()
* Contain the indeces for the different gains. 
* Value has to be between 0 and 5.
****************************************************/

STDMETHODIMP CControlBasis::get_sub_ActualVectorIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sSubCont_ActualInputIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_sub_ActualVectorIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sSubCont_ActualInputIndex = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_sub_DesiredVectorIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sSubCont_DesInputIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_sub_DesiredVectorIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sSubCont_DesInputIndex = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_sub_OutputVectorIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sSubCont_OutputIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_sub_OutputVectorIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sSubCont_OutputIndex = newVal;

	return S_OK;
}

/****************************************************
* Subordinate: Desired, Actual, Output Vectors()
* Reads and prints values for vectors.
*
* Values of vectors must be doubles.
****************************************************/
STDMETHODIMP CControlBasis::get_sub_DesiredVector(double *pVal)
{
	if(pVal != NULL)
		*pVal = m_dSubCont_DesInput[m_sSubCont_DesInputIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_sub_DesiredVector(double newVal)
{
	m_dSubCont_DesInput[m_sSubCont_DesInputIndex] = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_sub_ActualVector(double *pVal)
{
	if(pVal != NULL)
		*pVal = m_dSubCont_ActualInput[m_sSubCont_ActualInputIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_sub_ActualVector(double newVal)
{
	m_dSubCont_ActualInput[m_sSubCont_ActualInputIndex] = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_sub_OutputVector(double *pVal)
{
	if(pVal != NULL)
		*pVal = m_dDomCont_Output[m_sSubCont_OutputIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_sub_OutputVector(double newVal)
{
	m_dDomCont_Output[m_sSubCont_OutputIndex] = newVal;

	return S_OK;
}

/************************************************************************
**************************  Interface Methods  **************************
************************************************************************/


/****************************************************
* ComputeControlBasis
* This function computes the controller loop:
* 
*		output = Jacobian Transform * gain * error. 
*
* This function will: 
* 1) Will consider if there are 1 or 2 controllers.
* 2) If there are 2, it will project the output of
*    the second controller unto the null space of the
*    dominant controller.
* 3) The values of the Jacobian and gain will change
*    depending on the type of controller being run.
* 4) Passes the output to the Output Vector Signal.
* 5) This function will run the controller loop for
*    a certain "NUMBER_OF_CYCLES; 
****************************************************/
STDMETHODIMP CControlBasis::ComputeControlBasis()
{
	// Local variables
	short			Counter = 0;
	SAFEARRAY*		mysa;
	IVectorSignal *pIVSDomOutput;

	// Set the gains for appropriate robot
	SetGains();

	// 1) Get dominant vector data. Get (a) object pointers, (b) interface pointers, (c) VS data.
	GetDominantVectorData();

	// Check to see if there is 1 or 2 controllers.
	if(m_sNumControllers == 1)
	{
		if(Counter <= NUMBER_OF_CYCLES)
		{
			// 2) Compute controller output. Values are placed in m_dDomCont_Output
			ComputeControllerOutput(DOMINANT);

			// 4) Pass the OUTPUT to the vector signal. (Connect to object/interface first).
			m_Bindings->get_Pointers(SysAllocString(L"DomCont_Output"), &m_pIUnkDomCont_Output);
			if(m_pIUnkDomCont_Output == NULL)	return !S_OK;

			m_pIUnkDomCont_Output->QueryInterface(IID_IVectorSignal, (void **)&pIVSDomOutput);
			if(pIVSDomOutput == NULL)	return !S_OK;

			mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
			memcpy(mysa->pvData,m_dDomCont_Output,sizeof(double)*NUM_AXES);
			pIVSDomOutput->SetCurrentVector(mysa);
			SafeArrayDestroy(mysa);
			pIVSDomOutput->Release();

		}
	}
	/***************************************************
	* For the subordinate controller we need to:
	* 1) Get subordiante vector data
	* 2) Compute the subordinate controller output
	* 3) Compute the dominant controller output
	* 4) Compute the null space projection of the subordinate
	*    controller and store in m_dNullSpaceProjection
	* 5) Compute the combined output and add it to the current joint
	*    angle position
	* 6) Pass the data to the output VS
	*****************************************************/
	else
	{
		if(Counter <= NUMBER_OF_CYCLES)
		{
			int i=0;

			// 1) Get subordinate vector data. Get (a) object pointers, (b) interface pointers, (c) VS data.
			GetSubordinateVectorData();

			// 2) Compute controller output. Values are placed in m_dSubCont_Output[]
			ComputeControllerOutput(SUBORDINATE);

			// 3) Compute controller output. Values are placed in m_dDomCont_Output[]
			ComputeControllerOutput(DOMINANT);

			// 4) Project the result into the null space of the dominant controller. Values are placed in m_dNullSpaceProjection[]
			ProjectToNullSpace();

			// 6) Computed the combined output and add it to the current joint position of the robot.
			//    Then pass it to the output vector signal. 
			for(i=0; i<NUM_AXES; i++)
			{
				m_dCompositeControllerOutput[i] = m_dDomCont_Output[i] + m_dNullSpaceProjection[i];
				m_dCompositeControllerOutput[i] = m_dCompositeControllerOutput[i] + Angle[i];
			}

			// Output to the Dominant's controller vector: 
			m_Bindings->get_Pointers(SysAllocString(L"DomCont_Output"), &m_pIUnkDomCont_Output);
			if(m_pIUnkDomCont_Output == NULL)	return !S_OK;

			m_pIUnkDomCont_Output->QueryInterface(IID_IVectorSignal, (void **)&pIVSDomOutput);
			if(pIVSDomOutput == NULL)	return !S_OK;

			mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
			memcpy(mysa->pvData,m_dDomCont_Output,sizeof(double)*NUM_AXES);
			pIVSDomOutput->SetCurrentVector(mysa);
			SafeArrayDestroy(mysa);
			pIVSDomOutput->Release();

		}
		
	}

	return S_OK;
}

/************************************************************************
**************************  Member Functions  ***************************
************************************************************************/

/****************************************************
* Set_Gains()
* Sets the gains for the pertinent robot
****************************************************/
void CControlBasis::SetGains()
{
	if(m_sWhatRobot == ISAC_ROBOT)
	{
		m_dPositionGain[0] = 0.2;		m_dForceGain[0] = 0.2;	m_dMomentGain[0] = 0.2;	m_dInverseTorqueGain[0] = 0.2;
		m_dPositionGain[1] = 0.2;		m_dForceGain[1] = 0.2;	m_dMomentGain[1] = 0.2;	m_dInverseTorqueGain[1] = 0.2;
		m_dPositionGain[2] = 0.2;		m_dForceGain[2] = 0.2;	m_dMomentGain[2] = 0.2;	m_dInverseTorqueGain[2] = 0.2;
		m_dPositionGain[3] = 0.2;		m_dForceGain[3] = 0.2;	m_dMomentGain[3] = 0.2;	m_dInverseTorqueGain[3] = 0.2;
		m_dPositionGain[4] = 0.2;		m_dForceGain[4] = 0.2;	m_dMomentGain[4] = 0.2;	m_dInverseTorqueGain[4] = 0.2;
		m_dPositionGain[5] = 0.2;		m_dForceGain[5] = 0.2;	m_dMomentGain[5] = 0.2;	m_dInverseTorqueGain[5] = 0.2;
	}

	if(m_sWhatRobot == HP3JC_ROBOT)
	{
		m_dPositionGain[0] = 0.2;		m_dForceGain[0] = 0.2;	m_dMomentGain[0] = 0.2;	m_dInverseTorqueGain[0] = 0.2;
		m_dPositionGain[1] = 0.2;		m_dForceGain[1] = 0.2;	m_dMomentGain[1] = 0.2;	m_dInverseTorqueGain[1] = 0.2;
		m_dPositionGain[2] = 0.2;		m_dForceGain[2] = 0.2;	m_dMomentGain[2] = 0.2;	m_dInverseTorqueGain[2] = 0.2;
		m_dPositionGain[3] = 0.2;		m_dForceGain[3] = 0.2;	m_dMomentGain[3] = 0.2;	m_dInverseTorqueGain[3] = 0.2;
		m_dPositionGain[4] = 0.2;		m_dForceGain[4] = 0.2;	m_dMomentGain[4] = 0.2;	m_dInverseTorqueGain[4] = 0.2;
		m_dPositionGain[5] = 0.2;		m_dForceGain[5] = 0.2;	m_dMomentGain[5] = 0.2;	m_dInverseTorqueGain[5] = 0.2;
	}

}

/****************************************************
* Set_Jacobians()
* Sets the Jacobian for the pertinent robot and for 
* the pertinent controller. This function requires us to
* obtain the current joint Angle of the robot. 
*
* The derivation and programming of the Jacobian was done
* by modifying the Jacobian file from DiProdi's Matlab 
* Robotic Toolkit. The derivation was done for both ISAC
* and the HP3JC robot. Some manipulation was done to then
* run this Jacobian through Mathematica and simplify it further.
* The form in Mathematica was copied over to C++.
* 
* The Matlab and Mathematica file can be found at: 
* O:\Components\ArmComponents\MatlabFiles
*
* Note!! 
* The Jacobian used here is the TRANSFORM of the original 
* matrix. The transform of the Jacobian is used in all
* controllers.
*
* This function also defines the Jacobian differently
* according to what controller is selected. The reasoning
* is related to the fact that we are separating the force
* and moment components. We have two vectors and two 
* controllers to deal with these elements separately.
*
* When using the force controller we have to zero-out
* the elements multiplied with moment components. In
* essence we will keep the left (3 cols) of the Jacobian
* and we will zero out the right cols. The opposite is true
* if we are using the moment controller.
*
* For the POSITION controller the full Jacobian is used.
****************************************************/
HRESULT CControlBasis::ComputeJacobian()
{
	// Local Variables
	SAFEARRAY		*mysa;
	IVectorSignal	*pIVSAngle;

	// 1) Get pointers to object and interface of Angle and fill Angle vector.
	m_Bindings->get_Pointers(SysAllocString(L"ActualAngle"), &m_pIUnkAngle);
	if(m_pIUnkAngle == NULL) return !S_OK;
	m_pIUnkAngle->QueryInterface(IID_IVectorSignal, (void**)&pIVSAngle);
	if(pIVSAngle == NULL)	return !S_OK;

	// Copy data to Angle member variable. Used when executing the Jacobian.
	mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
	pIVSAngle->GetCurrentVector(mysa);
	memcpy(Angle,mysa->pvData,sizeof(double)*NUM_AXES);
	SafeArrayDestroy(mysa);
	m_pIUnkAngle->Release();


	// 2) Determine which robot is active
	if(m_sWhatRobot == ISAC_ROBOT)
	{

	// 3) Determine the type of controller used:
	//  ** POSITION CONTROLLER  ** 
	// If using the position controller arrange for the full jacobian
	if(m_sWhichIsDomController == DOMINANT_POSITION_CONTROLLER || m_sWhichIsSubController == SUBORDINATE_POSITION_CONTROLLER)
		{
			// 1st row
			J11 = 10 * (cos(Angle[2]) * cos(Angle[5]) * sin(Angle[3]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2])) - 20 * ( cos(Angle[1] + Angle[2]) * sin(Angle[3]) * sin(Angle[5]) + cos(Angle[5]) * sin(Angle[4]) * sin( Angle[1] + Angle[2])) + cos(Angle[3]) * (20 * cos(Angle[4]) * cos(Angle[5]) * cos(Angle[1] + Angle[2]) + sin(Angle[5]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2]))));
			J12 = -10 * (20 * cos(Angle[5]) * cos(Angle[1] + Angle[2]) * sin(Angle[3]) + cos(Angle[3]) * (20 * cos(Angle[4]) * cos(Angle[1] + Angle[2]) * sin(Angle[5]) + cos(Angle[5]) * (33 * cos(Angle[1]) - 29 * sin(Angle[1] + Angle[2]))) + sin(Angle[5]) * (-20 * sin(Angle[4]) * sin(Angle[1] + Angle[2]) + cos(Angle[4]) * sin(Angle[3]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2]))));
			J13 = 10 * (20 * cos(Angle[3]) * cos(Angle[1] - Angle[2]) * sin(Angle[4]) - cos(Angle[2]) * (20 * cos(Angle[4]) + 29 * sin(Angle[3]) * sin(Angle[4])) * sin(Angle[1]) + cos(Angle[1]) * (sin(Angle[3]) * sin(Angle[4]) * (33 - 29 * sin(Angle[2])) - 20 * cos(Angle[4]) * sin(Angle[2])));
			J14 = sin(Angle[3]) * sin(Angle[5]) * sin(Angle[1] + Angle[2]) - cos(Angle[5]) * (cos(Angle[1] + Angle[2]) * sin(Angle[4]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[1] + Angle[2]));
			J15 = cos(Angle[1] + Angle[2]) * sin(Angle[4]) * sin(Angle[5]) + ( cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[5]) ) * sin( Angle[1] + Angle[2] );
			J16 = -cos(Angle[4]) * cos( Angle[1] + Angle[2] ) + cos(Angle[3]) * sin(Angle[4]) * sin( Angle[1] + Angle[2] );
			
			// 2nd row
			J21 = 10 * ( cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2])) - 20 * (cos(Angle[1] + Angle[2]) * sin(Angle[3]) * sin(Angle[5]) + cos(Angle[5]) * sin(Angle[4]) * sin(Angle[1] + Angle[2])) + cos(Angle[3]) * (20 * cos(Angle[4]) * cos(Angle[5]) * cos(Angle[1] + Angle[2]) + sin(Angle[5]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2]))));
			J22 = -10 * (20 * cos(Angle[5]) * cos(Angle[1] + Angle[2]) * sin(Angle[3]) + cos(Angle[3]) * (20 * cos(Angle[4]) * cos(Angle[1] + Angle[2]) * sin(Angle[5]) + cos(Angle[5]) * (33 * cos(Angle[1]) - 29 * sin(Angle[1] + Angle[2]))) + sin(Angle[5]) * (-20 * sin(Angle[4]) * sin(Angle[1] + Angle[2]) + cos(Angle[4]) * sin(Angle[3]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2]))));
			J23 = 5 * (-49 * cos(Angle[3] - Angle[1] - Angle[2]) + 9 * cos(Angle[3] + Angle[1] + Angle[2]) + 66 * cos(Angle[1]) * sin(Angle[3])) * sin(Angle[4]) - 200 * cos(Angle[4]) * sin(Angle[1] + Angle[2]);
			J24 = sin(Angle[3]) * sin(Angle[5]) * sin(Angle[1] + Angle[2]) - cos(Angle[5]) * (cos(Angle[1] + Angle[2]) * sin(Angle[4]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[1] + Angle[2]));
			J25 = cos(Angle[1] + Angle[2]) * sin(Angle[4]) * sin(Angle[5]) + (cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[5])) * sin(Angle[1] + Angle[2]);
			J26 = -cos(Angle[4]) * cos(Angle[1] + Angle[2]) + cos(Angle[3]) * sin(Angle[4]) * sin(Angle[1] + Angle[2]);
			
			// 3rd row
			J31 = 10 * (33 * cos(Angle[5]) * cos(Angle[2]) * sin(Angle[4]) + sin(Angle[3]) * sin(Angle[5]) * (29 - 33 * sin(Angle[2])) + cos(Angle[3]) * cos(Angle[4]) * cos(Angle[5]) * (-29 + 33 * sin(Angle[2])));
			J32 = -10 * (cos(Angle[5]) * sin(Angle[3]) * (-29 + 33 * sin(Angle[2])) + sin(Angle[5]) * (33 * cos(Angle[2]) * sin(Angle[4]) + cos(Angle[3]) * cos(Angle[4]) * (-29 + 33 * sin(Angle[2]))));
			J33 = 10 * (33 * cos(Angle[4]) * cos(Angle[2]) + cos(Angle[3]) * sin(Angle[4]) * (29 - 33 * sin(Angle[2])));
			J34 = -cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) - cos(Angle[3]) * sin(Angle[5]);
			J35 = -cos(Angle[3]) * cos(Angle[5]) + cos(Angle[4]) * sin(Angle[3]) * sin(Angle[5]);
			J36 = sin(Angle[3]) * sin(Angle[4]);
			
			// 4th row
			J41 = 290 * (-cos(Angle[3]) * cos(Angle[4]) * cos(Angle[5]) + sin(Angle[3]) * sin(Angle[5]));
			J42 = 290 * (cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[5]));
			J43 = 290 * cos(Angle[3]) * sin(Angle[4]);
			J44 = -cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) - cos(Angle[3]) * sin(Angle[5]);
			J45 = -cos(Angle[3]) * cos(Angle[5]) + cos(Angle[4]) * sin(Angle[3]) * sin(Angle[5]);
			J46 = sin(Angle[3]) * sin(Angle[4]);
			
			// 5th row
			J51 = 0.0;
			J52 = 0.0;
			J53 = 0.0;
			J54 = cos(Angle[5]) * sin(Angle[4]);
			J55 = -sin(Angle[4]) * sin(Angle[5]);
			J56 = cos(Angle[4]);
			
			// 6th row
			J61 = 0.0;
			J62 = 0.0;
			J63 = 0.0;
			J64 = -sin(Angle[5]);
			J65 = -cos(Angle[5]);
			J66 = 0.0;

			return S_OK;

		}

		// ** FORCE CONTROLLER** 
		// Fill left half
		if(m_sWhichIsDomController == DOMINANT_FORCE_CONTROLLER || m_sWhichIsSubController == SUBORDINATE_FORCE_CONTROLLER) 
		{
			// 1st row
			J11 = 10 * (cos(Angle[2]) * cos(Angle[5]) * sin(Angle[3]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2])) - 20 * ( cos(Angle[1] + Angle[2]) * sin(Angle[3]) * sin(Angle[5]) + cos(Angle[5]) * sin(Angle[4]) * sin( Angle[1] + Angle[2])) + cos(Angle[3]) * (20 * cos(Angle[4]) * cos(Angle[5]) * cos(Angle[1] + Angle[2]) + sin(Angle[5]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2]))));
			J12 = -10 * (20 * cos(Angle[5]) * cos(Angle[1] + Angle[2]) * sin(Angle[3]) + cos(Angle[3]) * (20 * cos(Angle[4]) * cos(Angle[1] + Angle[2]) * sin(Angle[5]) + cos(Angle[5]) * (33 * cos(Angle[1]) - 29 * sin(Angle[1] + Angle[2]))) + sin(Angle[5]) * (-20 * sin(Angle[4]) * sin(Angle[1] + Angle[2]) + cos(Angle[4]) * sin(Angle[3]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2]))));
			J13 = 10 * (20 * cos(Angle[3]) * cos(Angle[1] - Angle[2]) * sin(Angle[4]) - cos(Angle[2]) * (20 * cos(Angle[4]) + 29 * sin(Angle[3]) * sin(Angle[4])) * sin(Angle[1]) + cos(Angle[1]) * (sin(Angle[3]) * sin(Angle[4]) * (33 - 29 * sin(Angle[2])) - 20 * cos(Angle[4]) * sin(Angle[2])));

			// 2nd row
			J21 = 10 * ( cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2])) - 20 * (cos(Angle[1] + Angle[2]) * sin(Angle[3]) * sin(Angle[5]) + cos(Angle[5]) * sin(Angle[4]) * sin(Angle[1] + Angle[2])) + cos(Angle[3]) * (20 * cos(Angle[4]) * cos(Angle[5]) * cos(Angle[1] + Angle[2]) + sin(Angle[5]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2]))));
			J22 = -10 * (20 * cos(Angle[5]) * cos(Angle[1] + Angle[2]) * sin(Angle[3]) + cos(Angle[3]) * (20 * cos(Angle[4]) * cos(Angle[1] + Angle[2]) * sin(Angle[5]) + cos(Angle[5]) * (33 * cos(Angle[1]) - 29 * sin(Angle[1] + Angle[2]))) + sin(Angle[5]) * (-20 * sin(Angle[4]) * sin(Angle[1] + Angle[2]) + cos(Angle[4]) * sin(Angle[3]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2]))));
			J23 = 5 * (-49 * cos(Angle[3] - Angle[1] - Angle[2]) + 9 * cos(Angle[3] + Angle[1] + Angle[2]) + 66 * cos(Angle[1]) * sin(Angle[3])) * sin(Angle[4]) - 200 * cos(Angle[4]) * sin(Angle[1] + Angle[2]);

			// 3rd row
			J31 = 10 * (33 * cos(Angle[5]) * cos(Angle[2]) * sin(Angle[4]) + sin(Angle[3]) * sin(Angle[5]) * (29 - 33 * sin(Angle[2])) + cos(Angle[3]) * cos(Angle[4]) * cos(Angle[5]) * (-29 + 33 * sin(Angle[2])));
			J32 = -10 * (cos(Angle[5]) * sin(Angle[3]) * (-29 + 33 * sin(Angle[2])) + sin(Angle[5]) * (33 * cos(Angle[2]) * sin(Angle[4]) + cos(Angle[3]) * cos(Angle[4]) * (-29 + 33 * sin(Angle[2]))));
			J33 = 10 * (33 * cos(Angle[4]) * cos(Angle[2]) + cos(Angle[3]) * sin(Angle[4]) * (29 - 33 * sin(Angle[2])));

			// 4th row
			J41 = 290 * (-cos(Angle[3]) * cos(Angle[4]) * cos(Angle[5]) + sin(Angle[3]) * sin(Angle[5]));
			J42 = 290 * (cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[5]));
			J43 = 290 * cos(Angle[3]) * sin(Angle[4]);

			// 5th row
			J51 = 0.0;
			J52 = 0.0;
			J53 = 0.0;

			// 6th row
			J61 = 0.0;
			J62 = 0.0;
			J63 = 0.0;

			// Set the right side of the Jacobian transform to zero. 
			J14 = J15 = J16 = 0.0;
			J24 = J25 = J26 = 0.0;
			J34 = J35 = J36 = 0.0;
			J44 = J45 = J46 = 0.0;
			J54 = J55 = J56 = 0.0;
			J64 = J65 = J66 = 0.0;

			return S_OK;
		}
		
		//  ** MOMENT CONTROLLER  ** 
		// Fill right half. 
		if(m_sWhichIsDomController == DOMINANT_MOMENT_CONTROLLER || m_sWhichIsSubController == SUBORDINATE_MOMENT_CONTROLLER) 
		{
			// Set the left side of the Jacobian transform to zero. 
			J11 = J12 = J13 = 0.0;
			J21 = J22 = J23 = 0.0;
			J31 = J32 = J33 = 0.0;
			J41 = J42 = J43 = 0.0;
			J51 = J52 = J53 = 0.0;
			J61 = J62 = J63 = 0.0;

			// 1st row
			J14 = sin(Angle[3]) * sin(Angle[5]) * sin(Angle[1] + Angle[2]) - cos(Angle[5]) * (cos(Angle[1] + Angle[2]) * sin(Angle[4]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[1] + Angle[2]));
			J15 = cos(Angle[1] + Angle[2]) * sin(Angle[4]) * sin(Angle[5]) + ( cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[5]) ) * sin( Angle[1] + Angle[2] );
			J16 = -cos(Angle[4]) * cos( Angle[1] + Angle[2] ) + cos(Angle[3]) * sin(Angle[4]) * sin( Angle[1] + Angle[2] );

			// 2nd row
			J24 = sin(Angle[3]) * sin(Angle[5]) * sin(Angle[1] + Angle[2]) - cos(Angle[5]) * (cos(Angle[1] + Angle[2]) * sin(Angle[4]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[1] + Angle[2]));
			J25 = cos(Angle[1] + Angle[2]) * sin(Angle[4]) * sin(Angle[5]) + (cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[5])) * sin(Angle[1] + Angle[2]);
			J26 = -cos(Angle[4]) * cos(Angle[1] + Angle[2]) + cos(Angle[3]) * sin(Angle[4]) * sin(Angle[1] + Angle[2]);

			// 3rd row
			J34 = -cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) - cos(Angle[3]) * sin(Angle[5]);
			J35 = -cos(Angle[3]) * cos(Angle[5]) + cos(Angle[4]) * sin(Angle[3]) * sin(Angle[5]);
			J36 = sin(Angle[3]) * sin(Angle[4]);

			// 4th row
			J44 = -cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) - cos(Angle[3]) * sin(Angle[5]);
			J45 = -cos(Angle[3]) * cos(Angle[5]) + cos(Angle[4]) * sin(Angle[3]) * sin(Angle[5]);
			J46 = sin(Angle[3]) * sin(Angle[4]);

			// 5th row
			J54 = cos(Angle[5]) * sin(Angle[4]);
			J55 = -sin(Angle[4]) * sin(Angle[5]);
			J56 = cos(Angle[4]);

			// 6th row
			J64 = -sin(Angle[5]);
			J65 = -cos(Angle[5]);
			J66 = 0.0;

			return S_OK;
		}

			return S_OK;
	}

	// HP3JC ROBOT
	if(m_sWhatRobot == HP3JC_ROBOT)
	{
		// If using the position controller arrange for the full jacobian
		if(m_sWhichIsDomController == DOMINANT_POSITION_CONTROLLER || m_sWhichIsSubController == SUBORDINATE_POSITION_CONTROLLER)
		{
			// 1st row
			J11 = -10 * (10 * ( -sin(Angle[3]) + sin(Angle[4]) ) * sin( Angle[5] - Angle[1] - Angle[2] ) + cos(Angle[3]) * ( cos(Angle[4]) * ( 10 * cos( Angle[5] - Angle[1] - Angle[2] )  + 19 * cos( Angle[5] - Angle[1] - Angle[2] ) ) + sin(Angle[5]) * ( 26 * cos(Angle[1]) - 27 * sin( Angle[1] + Angle[2] ) )) + cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) * (26 * cos(Angle[1]) - 27 * sin( Angle[1] + Angle[2] ) ) - 19 * (sin(Angle[3]) + sin(Angle[4])) * sin( Angle[5] - Angle[1] - Angle[2] ) );
			J12 = 10 * (cos(Angle[5]) * cos( Angle[1] + Angle[2] )  * (29 * sin(Angle[3]) + 9 * sin(Angle[4])) + sin(Angle[5]) * (26 * cos(Angle[4]) * cos(Angle[1]) * sin(Angle[3]) - (9 * (1 + 3 * cos(Angle[4])) * sin(Angle[3]) + 29 * sin(Angle[4])) * sin( Angle[1] + Angle[2] ) ) + cos(Angle[3]) * (29 * cos(Angle[4]) * cos( Angle[1] + Angle[2] )  * sin(Angle[5]) + cos(Angle[5]) * (-26 * cos(Angle[1]) + 9 * (3 + cos(Angle[4])) * sin( Angle[1] + Angle[2] ) )));
			J13 = 10 * (cos( Angle[3] - Angle[1] - Angle[2] )  + 28 * cos( Angle[3] + Angle[1] + Angle[2] ) + 26 * cos(Angle[1]) * sin(Angle[3])) * sin(Angle[4]) + 290 * cos(Angle[4]) * sin( Angle[1] + Angle[2] ) ;
			J14 = sin(Angle[3]) * sin(Angle[5]) * sin( Angle[1] + Angle[2] )  - cos(Angle[5]) * (cos( Angle[1] + Angle[2] )  * sin(Angle[4]) + cos(Angle[3]) * cos(Angle[4]) * sin( Angle[1] + Angle[2] ) );
			J15 = cos( Angle[1] + Angle[2] )  * sin(Angle[4]) * sin(Angle[5]) + (cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[5])) * sin( Angle[1] + Angle[2] ) ;
			J16 = -cos(Angle[4]) * cos( Angle[1] + Angle[2] )  + cos(Angle[3]) * sin(Angle[4]) * sin( Angle[1] + Angle[2] ) ;

			// 2nd row
			J21 = -10 * (10 * (-sin(Angle[3]) + sin(Angle[4])) * sin( Angle[5] - Angle[1] - Angle[2] )  + cos(Angle[3]) * (cos(Angle[4]) * (10 * cos( Angle[5] - Angle[1] - Angle[2] )  + 19 * cos( Angle[5] - Angle[1] - Angle[2] ) ) + sin(Angle[5]) * (26 * cos(Angle[1]) - 27 * sin( Angle[1] + Angle[2] ) )) + cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) * (26 * cos(Angle[1]) - 27 * sin( Angle[1] + Angle[2] ) ) - 19 * (sin(Angle[3]) + sin(Angle[4])) * sin( Angle[5] - Angle[1] - Angle[2] ) );
			J22 = 10 * (cos(Angle[5]) * cos( Angle[1] + Angle[2] )  * (29 * sin(Angle[3]) + 9 * sin(Angle[4])) + sin(Angle[5]) * (26 * cos(Angle[4]) * cos(Angle[1]) * sin(Angle[3]) - (9 * (1 + 3 * cos(Angle[4])) * sin(Angle[3]) + 29 * sin(Angle[4])) * sin( Angle[1] + Angle[2] ) ) + cos(Angle[3]) * (29 * cos(Angle[4]) * cos( Angle[1] + Angle[2] )  * sin(Angle[5]) + cos(Angle[5]) * (-26 * cos(Angle[1]) + 9 * (3 + cos(Angle[4])) * sin( Angle[1] + Angle[2] ) )));
			J23 = 10 * (cos( Angle[3] - Angle[1] - Angle[2] )  + 28 * cos( Angle[3] + Angle[1] + Angle[2] ) + 26 * cos(Angle[1]) * sin(Angle[3])) * sin(Angle[4]) + 290 * cos(Angle[4]) * sin( Angle[1] + Angle[2] ) ;
			J24 = sin(Angle[3]) * sin(Angle[5]) * sin( Angle[1] + Angle[2] )  - cos(Angle[5]) * (cos( Angle[1] + Angle[2] )  * sin(Angle[4]) + cos(Angle[3]) * cos(Angle[4]) * sin( Angle[1] + Angle[2] ) );
			J25 = cos( Angle[1] + Angle[2] )  * sin(Angle[4]) * sin(Angle[5]) + (cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[5])) * sin( Angle[1] + Angle[2] ) ;
			J26 = -cos(Angle[4]) * cos( Angle[1] + Angle[2] )  + cos(Angle[3]) * sin(Angle[4]) * sin( Angle[1] + Angle[2] ) ;

			// 3rd row
			J31 = 10 * (26 * cos(Angle[5]) * cos(Angle[2]) * sin(Angle[4]) + sin(Angle[3]) * sin(Angle[5]) * (27 + 9 * cos(Angle[4]) - 26 * sin(Angle[2])) + cos(Angle[3]) * cos(Angle[5]) * (-9 + cos(Angle[4]) * (-27 + 26 * sin(Angle[2]))));
			J32 = 10 * (sin(Angle[5]) * (-26 * cos(Angle[2]) * sin(Angle[4]) + cos(Angle[3]) * (9 + cos(Angle[4]) * (27 - 26 * sin(Angle[2])))) + cos(Angle[5]) * sin(Angle[3]) * (27 + 9 * cos(Angle[4]) - 26 * sin(Angle[2])));
			J33 = 10 * (26 * cos(Angle[4]) * cos(Angle[2]) + cos(Angle[3]) * sin(Angle[4]) * (27 - 26 * sin(Angle[2])));
			J34 = -cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) - cos(Angle[3]) * sin(Angle[5]);
			J35 = -cos(Angle[3]) * cos(Angle[5]) + cos(Angle[4]) * sin(Angle[3]) * sin(Angle[5]);
			J36 = sin(Angle[3]) * sin(Angle[4]);

			// 4th row
			J41 = -90 * cos(Angle[3]) * (1 + 3 * cos(Angle[4])) * cos(Angle[5]) + 90 * (3 + cos(Angle[4])) * sin(Angle[3]) * sin(Angle[5]);
			J42 = 90 * ((3 + cos(Angle[4])) * cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * (1 + 3 * cos(Angle[4])) * sin(Angle[5]));
			J43 = 270 * cos(Angle[3]) * sin(Angle[4]);
			J44 = -cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) - cos(Angle[3]) * sin(Angle[5]);
			J45 = -cos(Angle[3]) * cos(Angle[5]) + cos(Angle[4]) * sin(Angle[3]) * sin(Angle[5]);
			J46 = sin(Angle[3]) * sin(Angle[4]);

			// 5th row
			J51 = -90 * sin(Angle[4]) * sin(Angle[5]);
			J52 = -90 * cos(Angle[5]) * sin(Angle[4]);
			J53 = 0.0;
			J54 = cos(Angle[5]) * sin(Angle[4]);
			J55 = -sin(Angle[4]) * sin(Angle[5]);
			J56 = cos(Angle[4]);

			// 6th row
			J61 = -90 * cos(Angle[5]);
			J62 = 90 * sin(Angle[5]);
			J63 = 0.0;
			J64 = -sin(Angle[5]);
			J65 = -cos(Angle[5]);
			J66 = 0.0;

			return S_OK;

		}

		// Force Controller
		if(m_sWhichIsDomController == DOMINANT_FORCE_CONTROLLER || m_sWhichIsSubController == SUBORDINATE_FORCE_CONTROLLER) 
		{
			// 1st row
			J11 = -10 * (10 * ( -sin(Angle[3]) + sin(Angle[4]) ) * sin( Angle[5] - Angle[1] - Angle[2] ) + cos(Angle[3]) * ( cos(Angle[4]) * ( 10 * cos( Angle[5] - Angle[1] - Angle[2] )  + 19 * cos( Angle[5] - Angle[1] - Angle[2] ) ) + sin(Angle[5]) * ( 26 * cos(Angle[1]) - 27 * sin( Angle[1] + Angle[2] ) )) + cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) * (26 * cos(Angle[1]) - 27 * sin( Angle[1] + Angle[2] ) ) - 19 * (sin(Angle[3]) + sin(Angle[4])) * sin( Angle[5] - Angle[1] - Angle[2] ) );
			J12 = 10 * (cos(Angle[5]) * cos( Angle[1] + Angle[2] )  * (29 * sin(Angle[3]) + 9 * sin(Angle[4])) + sin(Angle[5]) * (26 * cos(Angle[4]) * cos(Angle[1]) * sin(Angle[3]) - (9 * (1 + 3 * cos(Angle[4])) * sin(Angle[3]) + 29 * sin(Angle[4])) * sin( Angle[1] + Angle[2] ) ) + cos(Angle[3]) * (29 * cos(Angle[4]) * cos( Angle[1] + Angle[2] )  * sin(Angle[5]) + cos(Angle[5]) * (-26 * cos(Angle[1]) + 9 * (3 + cos(Angle[4])) * sin( Angle[1] + Angle[2] ) )));
			J13 = 10 * (cos( Angle[3] - Angle[1] - Angle[2] )  + 28 * cos( Angle[3] + Angle[1] + Angle[2] ) + 26 * cos(Angle[1]) * sin(Angle[3])) * sin(Angle[4]) + 290 * cos(Angle[4]) * sin( Angle[1] + Angle[2] ) ;

			// 2nd row
			J21 = -10 * (10 * (-sin(Angle[3]) + sin(Angle[4])) * sin( Angle[5] - Angle[1] - Angle[2] )  + cos(Angle[3]) * (cos(Angle[4]) * (10 * cos( Angle[5] - Angle[1] - Angle[2] )  + 19 * cos( Angle[5] - Angle[1] - Angle[2] ) ) + sin(Angle[5]) * (26 * cos(Angle[1]) - 27 * sin( Angle[1] + Angle[2] ) )) + cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) * (26 * cos(Angle[1]) - 27 * sin( Angle[1] + Angle[2] ) ) - 19 * (sin(Angle[3]) + sin(Angle[4])) * sin( Angle[5] - Angle[1] - Angle[2] ) );
			J22 = 10 * (cos(Angle[5]) * cos( Angle[1] + Angle[2] )  * (29 * sin(Angle[3]) + 9 * sin(Angle[4])) + sin(Angle[5]) * (26 * cos(Angle[4]) * cos(Angle[1]) * sin(Angle[3]) - (9 * (1 + 3 * cos(Angle[4])) * sin(Angle[3]) + 29 * sin(Angle[4])) * sin( Angle[1] + Angle[2] ) ) + cos(Angle[3]) * (29 * cos(Angle[4]) * cos( Angle[1] + Angle[2] )  * sin(Angle[5]) + cos(Angle[5]) * (-26 * cos(Angle[1]) + 9 * (3 + cos(Angle[4])) * sin( Angle[1] + Angle[2] ) )));
			J23 = 10 * (cos( Angle[3] - Angle[1] - Angle[2] )  + 28 * cos( Angle[3] + Angle[1] + Angle[2] ) + 26 * cos(Angle[1]) * sin(Angle[3])) * sin(Angle[4]) + 290 * cos(Angle[4]) * sin( Angle[1] + Angle[2] ) ;

			// 3rd row
			J31 = 10 * (26 * cos(Angle[5]) * cos(Angle[2]) * sin(Angle[4]) + sin(Angle[3]) * sin(Angle[5]) * (27 + 9 * cos(Angle[4]) - 26 * sin(Angle[2])) + cos(Angle[3]) * cos(Angle[5]) * (-9 + cos(Angle[4]) * (-27 + 26 * sin(Angle[2]))));
			J32 = 10 * (sin(Angle[5]) * (-26 * cos(Angle[2]) * sin(Angle[4]) + cos(Angle[3]) * (9 + cos(Angle[4]) * (27 - 26 * sin(Angle[2])))) + cos(Angle[5]) * sin(Angle[3]) * (27 + 9 * cos(Angle[4]) - 26 * sin(Angle[2])));
			J33 = 10 * (26 * cos(Angle[4]) * cos(Angle[2]) + cos(Angle[3]) * sin(Angle[4]) * (27 - 26 * sin(Angle[2])));

			// 4th row
			J41 = -90 * cos(Angle[3]) * (1 + 3 * cos(Angle[4])) * cos(Angle[5]) + 90 * (3 + cos(Angle[4])) * sin(Angle[3]) * sin(Angle[5]);
			J42 = 90 * ( (3 + cos(Angle[4])) * cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * (1 + 3 * cos(Angle[4])) * sin(Angle[5]));
			J43 = 270 * cos(Angle[3]) * sin(Angle[4]);

			// Set the right side of the Jacobian transform to zero. 
			J14 = J15 = J16 = 0.0;
			J24 = J25 = J26 = 0.0;
			J34 = J35 = J36 = 0.0;
			J44 = J45 = J46 = 0.0;
			J54 = J55 = J56 = 0.0;
			J64 = J65 = J66 = 0.0;

			return S_OK;
		}
		
		// Moment Controller
		if(m_sWhichIsDomController == DOMINANT_MOMENT_CONTROLLER || m_sWhichIsSubController == SUBORDINATE_MOMENT_CONTROLLER) 
		{
			// Set the left side of the Jacobian transform to zero. 
			J11 = J12 = J13 = 0.0;
			J21 = J22 = J23 = 0.0;
			J31 = J32 = J33 = 0.0;
			J41 = J42 = J43 = 0.0;
			J51 = J52 = J53 = 0.0;
			J61 = J62 = J63 = 0.0;

			// 1st row
			J14 = sin(Angle[3]) * sin(Angle[5]) * sin( Angle[1] + Angle[2] )  - cos(Angle[5]) * (cos( Angle[1] + Angle[2] )  * sin(Angle[4]) + cos(Angle[3]) * cos(Angle[4]) * sin( Angle[1] + Angle[2] ) );
			J15 = cos( Angle[1] + Angle[2] )  * sin(Angle[4]) * sin(Angle[5]) + (cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[5])) * sin( Angle[1] + Angle[2] ) ;
			J16 = -cos(Angle[4]) * cos( Angle[1] + Angle[2] )  + cos(Angle[3]) * sin(Angle[4]) * sin( Angle[1] + Angle[2] ) ;

			// 2nd row
			J24 = sin(Angle[3]) * sin(Angle[5]) * sin( Angle[1] + Angle[2] )  - cos(Angle[5]) * (cos( Angle[1] + Angle[2] )  * sin(Angle[4]) + cos(Angle[3]) * cos(Angle[4]) * sin( Angle[1] + Angle[2] ) );
			J25 = cos( Angle[1] + Angle[2] )  * sin(Angle[4]) * sin(Angle[5]) + (cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[5])) * sin( Angle[1] + Angle[2] ) ;
			J26 = -cos(Angle[4]) * cos( Angle[1] + Angle[2] )  + cos(Angle[3]) * sin(Angle[4]) * sin( Angle[1] + Angle[2] ) ;

			// 3rd row
			J34 = -cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) - cos(Angle[3]) * sin(Angle[5]);
			J35 = -cos(Angle[3]) * cos(Angle[5]) + cos(Angle[4]) * sin(Angle[3]) * sin(Angle[5]);
			J36 = sin(Angle[3]) * sin(Angle[4]);

			// 4th row
			J44 = -cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) - cos(Angle[3]) * sin(Angle[5]);
			J45 = -cos(Angle[3]) * cos(Angle[5]) + cos(Angle[4]) * sin(Angle[3]) * sin(Angle[5]);
			J46 = sin(Angle[3]) * sin(Angle[4]);

			// 5th row
			J54 = cos(Angle[5]) * sin(Angle[4]);
			J55 = -sin(Angle[4]) * sin(Angle[5]);
			J56 = cos(Angle[4]);

			// 6th row
			J64 = -sin(Angle[5]);
			J65 = -cos(Angle[5]);
			J66 = 0.0;

			return S_OK;
		}

		return S_OK;
	}

	return S_OK;
}



/****************************************************
* ComputeControllerOutput()
* 1) Determine if we have a dominant or subordinate controller
* 2) Determine if we have a position, force or moment controller.
*    Force elements are the first 3 from desired vector, moment 
*    elements are the last 3 from the desired vector. In both
*    cases we copy over to our private member variable.
* 3) Calculate the product between the error and the gain
* 4) Call JacobianProduct to compute the product from the 
*    prior result and the Jacobian. The result is stored in the
*    output vector.
****************************************************/
void CControlBasis::ComputeControllerOutput(bool SubordinateController)
{
	// Local variables
	int i;
	double TempBuffer[NUM_AXES];	// Holds product: Gain * Error;

	// 1) Determine if this is a dominant or subordinate controller.
	if(SubordinateController == DOMINANT) // We have a dominant controller
	{
		// 2) Check to see if we have a position controller
		if(m_sWhichIsDomController == DOMINANT_POSITION_CONTROLLER)
		{
			// 3) Calculate error and its product with position gain.
			for(i = 0; i<NUM_AXES; i++)
			{
				m_dDomCont_Error[i] = m_dDomCont_DesInput[i] - m_dDomCont_ActualInput[i];
				TempBuffer[i] = m_dDomCont_Error[i] * m_dPositionGain[i];
			}

			// Calculate product between Jacobian transform and TempBuffer. Store result in OUTPUT vector.
			JacobianProduct(DOMINANT,TempBuffer);
		}

		// 2) Check to see if we have a force controller
		else if(m_sWhichIsDomController == DOMINANT_FORCE_CONTROLLER)
		{
			// For force controller we need to clear the last three entries of the vector.
			for(i=3;i<NUM_AXES;i++) 
			{
				m_dDomCont_DesInput[i]		= 0.0;
				m_dDomCont_ActualInput[i]	= 0.0;
			}

			// 3) Calculate error and its product with position gain.
			//    For the force controller we have to also multiply by the inv. torque gain
			for(i = 0; i<NUM_AXES; i++)
			{
				m_dDomCont_Error[i] = m_dDomCont_DesInput[i] - m_dDomCont_ActualInput[i];
				TempBuffer[i] = m_dInverseTorqueGain[i] * m_dDomCont_Error[i] * m_dPositionGain[i];
			}

			// Calculate product between Jacobian transform and TempBuffer. Store result in OUTPUT vector.
			JacobianProduct(DOMINANT,TempBuffer);
		}

		// 2) Check to see if we have a moment controller
		else if(m_sWhichIsDomController == DOMINANT_MOMENT_CONTROLLER)
		{
			// For moment controller we need to copy the last three entries of the vector into the first three positions
			for(i=0;i<3;i++)
			{
				// Copy data from element [3] into [0].
				m_dDomCont_DesInput[i] = m_dDomCont_DesInput[i+3];
				m_dDomCont_ActualInput[i] = m_dDomCont_ActualInput[i+3];

				// Clear data in [3]
				m_dDomCont_DesInput[i+3] = 0;
				m_dDomCont_ActualInput[i+3];
			}
			
			// 3) Calculate error and its product with position gain.
			//    Also need to include the inv. torque gain.
			for(i = 0; i<NUM_AXES; i++)
			{
				m_dDomCont_Error[i] = m_dDomCont_DesInput[i] - m_dDomCont_ActualInput[i];
				TempBuffer[i] = m_dInverseTorqueGain[i] * m_dDomCont_Error[i] * m_dPositionGain[i];
			}

			// Calculate product between Jacobian transform and TempBuffer. Store result in OUTPUT vector.
			JacobianProduct(DOMINANT,TempBuffer);
		}
	}

	// 1) Determine if we have a subordinate controller
	if(SubordinateController == SUBORDINATE) 
	{
		// 2) Check to see if we have a position controller
		if(m_sWhichIsSubController == SUBORDINATE_POSITION_CONTROLLER)
		{
			// 3) Calculate error and its product with position gain.
			for(i = 0; i<NUM_AXES; i++)
			{
				m_dSubCont_Error[i] = m_dSubCont_DesInput[i] - m_dSubCont_ActualInput[i];
				TempBuffer[i] = m_dSubCont_Error[i] * m_dPositionGain[i];
			}

			// Calculate product between Jacobian transform and TempBuffer. Store result in OUTPUT vector.
			JacobianProduct(SUBORDINATE,TempBuffer);
		}

		// 2) Check to see if we have a force controller
		//	  Also need to include the inv. torque gain
		else if(m_sWhichIsSubController == SUBORDINATE_FORCE_CONTROLLER)
		{
			// For force controller we need to clear the last three entries of the vector.
			for(i=3;i<NUM_AXES;i++) 
			{
				m_dSubCont_DesInput[i]		= 0.0;
				m_dSubCont_ActualInput[i]	= 0.0;
			}
			// 3) Calculate error and its product with position gain.
			for(i = 0; i<NUM_AXES; i++)
			{
				m_dSubCont_Error[i] = m_dSubCont_DesInput[i] - m_dSubCont_ActualInput[i];
				TempBuffer[i] = m_dInverseTorqueGain[i] * m_dSubCont_Error[i] * m_dPositionGain[i];
			}

			// Calculate product between Jacobian transform and TempBuffer. Store result in OUTPUT vector.
			JacobianProduct(SUBORDINATE,TempBuffer);
		}

		// 2) Check to see if we have a moment controller
		//	  Also need to include the inv torque gain
		else if(m_sWhichIsSubController == SUBORDINATE_MOMENT_CONTROLLER)
		{
			// For moment controller we need to copy the last three entries of the vector into the first three positions
			for(i=0;i<3;i++)
			{
				// Copy data from element [3] into [0].
				m_dSubCont_DesInput[i] = m_dSubCont_DesInput[i+3];
				m_dSubCont_ActualInput[i] = m_dSubCont_ActualInput[i+3];

				// Clear data in [3]
				m_dSubCont_DesInput[i+3] = 0;
				m_dSubCont_ActualInput[i+3];
			}
			// 3) Calculate error and its product with position gain.
			for(i = 0; i<NUM_AXES; i++)
			{
				m_dSubCont_Error[i] = m_dSubCont_DesInput[i] - m_dSubCont_ActualInput[i];
				TempBuffer[i] = m_dInverseTorqueGain[i] * m_dSubCont_Error[i] * m_dPositionGain[i];
			}

			// Calculate product between Jacobian transform and TempBuffer. Store result in OUTPUT vector.
			JacobianProduct(SUBORDINATE,TempBuffer);
		}
	}

}

/****************************************************
* JacobianProduct()
* Returns the control basis output.
* 
* This function performs the following:
* 1) Calls: ComputeJacobian() which creates the 
*    the individual elements of the Jacobian transform.
* 2) Multiply by the Intermediate product of the error 
*    and the gain to obtain the control basis controller
*    output.
* 3) Add the update in joint Angle to the current 
*    angle position.
*	 q_new = q_old + delta_q.
****************************************************/
void CControlBasis::JacobianProduct(bool SubordinateController, double * TempBuffer)
{
	// Local variables
	int i; 

	// 1) Call the ComputeJacobian() method
	ComputeJacobian();

	// Determine if we are working with the dominant or subordinate controller
	if(SubordinateController == DOMINANT)
	{
		// 2) Compute the elements of the output vector
		/** 1st **/
		m_dDomCont_Output[0] = (J11 * TempBuffer[0]) + (J12 * TempBuffer[1]) + (J13 * TempBuffer[2]) + 
								  (J14 * TempBuffer[3]) + (J15 * TempBuffer[4]) + (J16 * TempBuffer[5]);
		/** 2nd **/
		m_dDomCont_Output[1] = (J21 * TempBuffer[0]) + (J22 * TempBuffer[1]) + (J23 * TempBuffer[2]) + 
								  (J24 * TempBuffer[3]) + (J25 * TempBuffer[4]) + (J26 * TempBuffer[5]);
		/** 3rd **/
		m_dDomCont_Output[2] = (J31 * TempBuffer[0]) + (J32 * TempBuffer[1]) + (J33 * TempBuffer[2]) + 
								  (J34 * TempBuffer[3]) + (J35 * TempBuffer[4]) + (J36 * TempBuffer[5]);
		/** 4th **/
		m_dDomCont_Output[3] = (J41 * TempBuffer[0]) + (J42 * TempBuffer[1]) + (J43 * TempBuffer[2]) + 
								  (J44 * TempBuffer[3]) + (J45 * TempBuffer[4]) + (J46 * TempBuffer[5]);	
		/** 5th **/
		m_dDomCont_Output[4] = (J51 * TempBuffer[0]) + (J52 * TempBuffer[1]) + (J53 * TempBuffer[2]) + 
								  (J54 * TempBuffer[3]) + (J55 * TempBuffer[4]) + (J56 * TempBuffer[5]);
		/** 6th **/
		m_dDomCont_Output[5] = (J61 * TempBuffer[0]) + (J62 * TempBuffer[1]) + (J63 * TempBuffer[2]) + 
								  (J64 * TempBuffer[3]) + (J65 * TempBuffer[4]) + (J66 * TempBuffer[5]);

		// 3) Add the update in joint Angle to the actual joint angle position.
		for(i = 0; i<NUM_AXES; i++)
			m_dDomCont_Output[i] = m_dDomCont_Output[i] + Angle[i];

	}

	if(SubordinateController == SUBORDINATE)
	{
		// 2) Compute the elements of the output vector
		/** 1st **/
		m_dSubCont_Output[0] = (J11 * TempBuffer[0]) + (J12 * TempBuffer[1]) + (J13 * TempBuffer[2]) + 
								  (J14 * TempBuffer[3]) + (J15 * TempBuffer[4]) + (J16 * TempBuffer[5]);
		/** 2nd **/
		m_dSubCont_Output[1] = (J21 * TempBuffer[0]) + (J22 * TempBuffer[1]) + (J23 * TempBuffer[2]) + 
								  (J24 * TempBuffer[3]) + (J25 * TempBuffer[4]) + (J26 * TempBuffer[5]);
		/** 3rd **/
		m_dSubCont_Output[2] = (J31 * TempBuffer[0]) + (J32 * TempBuffer[1]) + (J33 * TempBuffer[2]) + 
								  (J34 * TempBuffer[3]) + (J35 * TempBuffer[4]) + (J36 * TempBuffer[5]);
		/** 4th **/
		m_dSubCont_Output[3] = (J41 * TempBuffer[0]) + (J42 * TempBuffer[1]) + (J43 * TempBuffer[2]) + 
								  (J44 * TempBuffer[3]) + (J45 * TempBuffer[4]) + (J46 * TempBuffer[5]);	
		/** 5th **/
		m_dSubCont_Output[4] = (J51 * TempBuffer[0]) + (J52 * TempBuffer[1]) + (J53 * TempBuffer[2]) + 
								  (J54 * TempBuffer[3]) + (J55 * TempBuffer[4]) + (J56 * TempBuffer[5]);
		/** 6th **/
		m_dSubCont_Output[5] = (J61 * TempBuffer[0]) + (J62 * TempBuffer[1]) + (J63 * TempBuffer[2]) + 
								  (J64 * TempBuffer[3]) + (J65 * TempBuffer[4]) + (J66 * TempBuffer[5]);

		// 3) Add the update in joint Angle to the actual joint angle position.
		for(i = 0; i<NUM_AXES; i++)
			m_dSubCont_Output[i] = m_dSubCont_Output[i] + Angle[i];
	}
}

/****************************************************
* ProjectToNullSpace()
* This function projects the output of the subordinate
* controller to the null space of the dominant controller.
* 
* We multiply m_dSubCont_Output * null_space_matrix and 
* place the result in m_dNullSpaceProjection
*
* This controller consider a 6D space, given that the input
* and output vectors will always be the change in joint 
* coordinates, m_sDomCont_OutputIndex(q1,q2,q3,q4,q5,q6).
*
* In the following explanation, m_sDomCont_OutputIndex will be
* represented by x_out:
* 
* From Platt's work, the null space operator, N, is defined as:
* 
* N = I - [x_out * inv(x_out' * x_out) * x_out']
*
* N = I - [ 1/(q1^2 + q2^2 + q3^2 + q4^2 + q5^2 + q6) * |q1^2 q1q2 q13 ... q1q6 |
*														|q2q1 q2^2 ...     q2q6 |												|q6q   ... ...      q6^2|
*
* Notice that the identity matrix is subtracted from 
* the outer product normalized by the dot product of x_out.
*
* Variables:
* Denominator - we compute the value of the denominator ahead of time.
* Matrix mulitplication - the product of the null_space_matrix
* with the subordinate controller output will be implemented by the use
* of 2 'for-loops'.
* The results will be stored in: m_dNullSpaceProjection
* 
****************************************************/
void CControlBasis::ProjectToNullSpace()
{
	// Local variables
	double denominator;
	double x[NUM_AXES];

	// Make a local copy of the dominant controller output for convencience:
	x[0] = m_dDomCont_Output[0];

	// 1) Implement the denominator term. The sum of squares of the diagonal:
	denominator = pow(x[0],2) + pow(x[1],2) + pow(x[2],2) + pow(x[3],2) + pow(x[4],2) + pow(x[5],2);

	// 2) Perform the matrix product with the subordinate controller
	for(int i=0;i<NUM_AXES;i++)
	{
		for(int j=0;j<NUM_AXES;j++)
		{
			m_dNullSpaceProjection[i] = m_dSubCont_Output[i] + (x[i]*x[j])/denominator;
		}
	}
}

/****************************************************
* GetDominantVectorData()
* Retrievs object and interface pointers of:
* the Desired, Actual, and output vectors.
*
* Also passes VS data to private member variables.
*
* At the end, we free membory and release interface
* handles.
****************************************************/
HRESULT CControlBasis::GetDominantVectorData()
{
	// Local Variables
	int				i		= 0;
	short			Counter = 0;
	SAFEARRAY*		mysa;
	IVectorSignal *pIVSDomDesInput, *pIVSDomActualInput;

	// (1) Get dominant vector data. Get (a) object pointers, (b) interface pointers, (c) VS data.
	m_Bindings->get_Pointers(SysAllocString(L"DomCont_DesiredInput"), &m_pIUnkDomCont_DesInput);
	m_Bindings->get_Pointers(SysAllocString(L"DomCont_ActualInput"), &m_pIUnkDomCont_ActualInput);
	
	if(m_pIUnkDomCont_DesInput == NULL || m_pIUnkDomCont_ActualInput == NULL)	return !S_OK;

	// (b) Get Interface pointers
	m_pIUnkDomCont_DesInput->QueryInterface(IID_IVectorSignal, (void **)&pIVSDomDesInput);
	m_pIUnkDomCont_ActualInput->QueryInterface(IID_IVectorSignal, (void **)&pIVSDomActualInput);
	if(pIVSDomDesInput == NULL || pIVSDomActualInput == NULL)	return !S_OK;

	// (c) Get data from VS for Desired and Actual.
	mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
	pIVSDomDesInput->GetCurrentVector(mysa);
	memcpy(m_dDomCont_DesInput,mysa->pvData,sizeof(double)*NUM_AXES);
	SafeArrayDestroy(mysa);
	pIVSDomDesInput->Release();

	mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
	pIVSDomActualInput->GetCurrentVector(mysa);
	memcpy(m_dDomCont_ActualInput,mysa->pvData,sizeof(double)*NUM_AXES);
	SafeArrayDestroy(mysa);
	pIVSDomActualInput->Release();

	return S_OK;
}

/****************************************************
* GetSubordinateVectorData()
* Retrievs object and interface pointers of:
* the Desired, Actual, and Output vectors.
*
* Also passes VS data to private member variables.
*
* At the end, we free membory and release interface
* handles.
****************************************************/
HRESULT CControlBasis::GetSubordinateVectorData()
{
	// Local Variables
	int				i		= 0;
	short			Counter = 0;
	SAFEARRAY*		mysa;
	IVectorSignal *pIVSSubDesInput, *pIVSSubActualInput;

	// Get object pointers for all three vectors.
	m_Bindings->get_Pointers(SysAllocString(L"SubCont_DesiredInput"), &m_pIUnkSubCont_DesInput);
	m_Bindings->get_Pointers(SysAllocString(L"SubCont_ActualInput"), &m_pIUnkSubCont_ActualInput);
	
	if(m_pIUnkSubCont_DesInput == NULL || m_pIUnkSubCont_ActualInput == NULL)	return !S_OK;

	// (b) Get Interface pointers
	m_pIUnkSubCont_DesInput->QueryInterface(IID_IVectorSignal, (void **)&pIVSSubDesInput);
	m_pIUnkSubCont_ActualInput->QueryInterface(IID_IVectorSignal, (void **)&pIVSSubActualInput);

	if(pIVSSubDesInput == NULL || pIVSSubActualInput == NULL)	return !S_OK;

	// (c) Get data from VS for Desired and Actual.
	mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
	pIVSSubDesInput->GetCurrentVector(mysa);
	memcpy(m_dSubCont_DesInput,mysa->pvData,sizeof(double)*NUM_AXES);
	SafeArrayDestroy(mysa);
	m_pIUnkSubCont_DesInput->Release();

	mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
	pIVSSubActualInput->GetCurrentVector(mysa);
	memcpy(m_dSubCont_ActualInput,mysa->pvData,sizeof(double)*NUM_AXES);
	SafeArrayDestroy(mysa);
	m_pIUnkSubCont_ActualInput->Release();

	return S_OK;
}
