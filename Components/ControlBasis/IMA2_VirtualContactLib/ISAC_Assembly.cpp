// ISAC_Assembly.cpp : Implementation of CISAC_Assembly
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A note about this template:
// This template is autogenerated. The template code can be found in \ProgramFiles\MicrosoftVisualStudio\Common\MSDev\Templates\ATL
// Specifically customized for an IMA 2.5 component.
// Created by Juan Rojas. Jan 08.
//
// You can also look at an example compenent created by Christina Campbell at O:\Components\ExampleComp
// If you are just learning look at that component to see more details than those included in this template.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "IMA2_VirtualContactLib.h"
#include "ISAC_Assembly.h"

/////////////////////////////////////////////////////////////////////////////
// CISAC_Assembly
// 
// Include Class comments.
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
// CISAC_Assembly::OnConstruct() 
// OnConstruct() is called when the component is created. If you are going to connect 
// another component anywhere in your code, you need to set up bindings. 
//
// The following code will create one binding. Change "DescriptiveName" to some
// appropriate string. This string will be visible as the name of the binding from
// DAD. It is *not* the name of the component you will bind to. The name of the
// specific component on the other end of the binding is determined at runtime (in DAD).
//
// If you wish to allow only one component to connect to this binding, make the BindType
// BT_Default. If you wish to allow several components, make the BindType BT_Collection.
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CISAC_Assembly::OnConstruct()
{
// TODO: Bindings. Personalize the binding of your component. 
	IMA2_BindingInfo	BindInf;
	long x[1] = { 0 };
	SAFEARRAYBOUND		SafeArrayBoundIn[1];										// We're making a one-dimensional SafeArray
	SafeArrayBoundIn[0].lLbound		= 0;											// Our SafeArray starts at index 0
	SafeArrayBoundIn[0].cElements	= 1;

	// **START**
	// 1a) RIGHT ATI Force Sensor
	BindInf.Name		= SysAllocString(L"force_RightATIForceSensor");						// Assign name to object
	BindInf.BindType	= BT_Collection;											// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");										// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);			// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);			// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal")); // Enter the appropriate PID and IID for your binding. 
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));						 // This will ensure when you add a binding only components of this type will show in DAD
	m_ConfigureBindings->Add(&BindInf);	
	
	// 1b) LEFT ATI Force Sensor
	BindInf.Name		= SysAllocString(L"force_LeftATIForceSensor");						// Assign name to object
	BindInf.BindType	= BT_Collection;											// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");										// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);			// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);			// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal")); // Enter the appropriate PID and IID for your binding. 
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));						 // This will ensure when you add a binding only components of this type will show in DAD
	m_ConfigureBindings->Add(&BindInf);	

	// 1c) Average Force Sensor Data
	BindInf.Name		= SysAllocString(L"force_AvgForceSensorData");						// Assign name to object
	BindInf.BindType	= BT_Collection;											// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");										// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);			// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);			// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal")); // Enter the appropriate PID and IID for your binding. 
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));						 // This will ensure when you add a binding only components of this type will show in DAD
	m_ConfigureBindings->Add(&BindInf);	

	// 2a) RIGHT Actual Joint Angle Position for ISAC
	BindInf.Name		= SysAllocString(L"angle_RightActualJointAngle");						// Assign name to object
	BindInf.BindType	= BT_Collection;											// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");										// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);			// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);			// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal")); // Enter the appropriate PID and IID for your binding. 
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));						 // This will ensure when you add a binding only components of this type will show in DAD
	m_ConfigureBindings->Add(&BindInf);	
	
	// 2b) LEFT Actual Joint Angle Position for ISAC
	BindInf.Name		= SysAllocString(L"angle_LeftActualJointAngle");						// Assign name to object
	BindInf.BindType	= BT_Collection;											// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");										// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);			// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);			// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal")); // Enter the appropriate PID and IID for your binding. 
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));						 // This will ensure when you add a binding only components of this type will show in DAD
	m_ConfigureBindings->Add(&BindInf);	

	// 2c) Average Joint Angle Position
	BindInf.Name		= SysAllocString(L"angle_AvgActualJointAngle");						// Assign name to object
	BindInf.BindType	= BT_Collection;											// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");										// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);			// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);			// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal")); // Enter the appropriate PID and IID for your binding. 
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));						 // This will ensure when you add a binding only components of this type will show in DAD
	m_ConfigureBindings->Add(&BindInf);	

	// Deallocate storage
	SysFreeString(BindInf.Name);
	SysFreeString(BindInf.Path);
	SafeArrayDestroy(BindInf.PIDs);
	SafeArrayDestroy(BindInf.IIDs);
  return S_OK;
}
STDMETHODIMP CISAC_Assembly::OnDestruct() {	return S_OK; }
//////////////////////////////////////////////////////////////////////////////////////////
// CISAC_Assembly::Save(VARIANT *pData)
// This method is called by DAD when a component is saved. Items that should be saved are the
// ones that are important to the setup of the code, or user options that should hold over
// from one use of an agent to another. (Example: size of data, filenames, etc.) 
//
// For each variable to be saved, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to GetPropertyBag). Change the
// term "DescriptiveName" to something descriptive of the item you are saving, and make
// sure not to reuse names. In the next line of code, change "m_MyPrivateVariable" to the variable
// you are saving and VarType to the VarType of that value. Valid types and VarTypes are:
// (Note: These are limited by VB/OLE compatibility, not by the list of things that Variants can be.)
// short:	VT_I2
// int:		VT_I4
// float:	VT_R4
// double:	VT_R8
// BSTR:	VT_BSTR
// char:	VT_BYTE
// All strings (char*) should be converted to BSTR (see BSTR documentation).
// A CString can be converted to a BSTR using the member function AllocSysString (see CString documentation)
//
// If you want to save an array, you have to assign a SAFEARRAY to the Variant. (Do NOT just
// use a pointer, it will save just one value). replace the line starting "ItemValue =" with the following 
// code (substituting your pointer for "variable", the array length for "numelem", int/float/double, etc. 
// for "Type", and using the VarType of one element of the array--BSTR arrays are not allowed.):
//
//	ItemValue = new variant_t;
//	ItemValue->vt=VT_ARRAY|VarType;
//	ItemValue->parray=SafeArrayCreateVector(VarType,0,numelem);
//  memcpy(ItemValue->parray->pvData,variable,numelem*sizeof(Type));
//
// Note: "delete ItemValue" will take care of destroying the safearray (do *not* call SafeArrayDestroy).
// Because of the nature of a SafeArray, you do not have to explicitly save the length of the array.
// However, due to the nature of property bags, you must call the array version of the Add function:
//
//  hRes = pIPB->AddArrayToPropertyBag(&ItemName, ItemValue);
//
// (See Load comments for how to extract arrays from the propertybag).
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CISAC_Assembly::Save(VARIANT *pData) 
{
	// Variables
/*	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	variant_t				*ItemValue;
	_PropertyBagWrapper		*pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		if (pIPB == NULL)	
			return !S_OK;
		
		// **START**
		// Create string names for items to be saved
		// Number of Elements
		ItemName = SysAllocString(L"DescriptiveName");
		// Store the data and the type of data into a variant_t type
 		ItemValue = new variant_t(m_YourPrivateVariableName,VT_I4);
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**
		// Returns a pointer to the PropertyBag as a VARIANT
		hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
		
		// Copy the contents of the property bag to the pData VARIANT
		VariantCopy(pData, &m_VBPropertyBag);
		// Save the size of the data 
		m_lDataSize = pData->parray->rgsabound[0].cElements;		
		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);
		
		// Release
		pIPB->Release();
*/
	return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////
// CISAC_Assembly::Load(VARIANT Data)
// This function will load in all the data you just saved in the Save function.
// 
// For each variable to be loaded, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to VariantClear). Change the
// term "NameUsedToSave" to the name you gave this item in Save.
// On the line beginning "variable = ", change "variable" to the variable that you saved
// the value from, and change "Type" to the type of that variable (use "long" for "int")
// A CString can be directly set to a BSTR, but in order to get a char* back, you have to 
// use strcpy (I think).
//
// If you made an array, you have to load it back in now.
// Just like in the save function, you must call the array version of the Get function:
//
//  pIPB->GetArrayFromPropertyBag(&ItemName, ItemValue);
//
// If your variable is dynamically allocated, make sure to delete and reallocate it:
//
//  if(variable!=NULL)
//		delete variable;
//  variable=new Type[ItemValue->parray->rgsabound->cElements];	
//
// Then just copy the values from the parray (replace the "variable =" line with this):
//
//  memcpy(variable,ItemValue->parray->pvData,ItemValue->parray->rgsabound->cElements*sizeof(Type));
//
// Note that this means you do not have to separately save the length of the array, although if
// you have a variable that keeps track of the array length you should also set it at this point:
//
//  numelem=ItemValue->parray->rgsabound->cElements;
//
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CISAC_Assembly::Load(VARIANT Data) 
{
	
	// Variables
/*	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	_PropertyBagWrapper*	pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	variant_t				*ItemValue;
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		if (pIPB == NULL)	
			return !S_OK;
		// Get the pointer to the real VB property bag (the VB object (defined in msvbvm60.dll (aka VBRUN)) that our wrapper class created)
		// hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
		
		// Pass Data to PropertyBag
		hRes = pIPB->SetPropertyBag(&Data);
		// **START**
		// Variable m_lNumElements
		// Define strings
		ItemName		= SysAllocString(L"NameUsedToSave");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetFromPropertyBag(&ItemName,ItemValue);  //2nd argument is return value (look retval for help)
		m_YourPrivateVariableName	= (long)*ItemValue;
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**
		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);
		
		// Release
		pIPB->Release();
*/		
	return S_OK;
}

/********************************************************************/
/* AverageValues()
/*
/* This function performs that task of a virtual contact (Platt, 2006).
/* In essence it inputs the data values of force or joint angle configurations
/* and it computes the average value for all inputs involved.
/*
/* This function is used on ISAC for the control basis. 
/*
/* Incoming values:	a) Right ATI Force data
/*					b) Left  ATI Force data
/*					c) Right Actual Joint Angle
/*					d) Left Actual Joint Angle
/*
/* Ouput averaged values:	a) Averaged Force reading
/*							b) Averaged Joint Angle reading
/*
/* This function works in the following way:
/* 1) Get data from incoming sensory sources
/* 2) Average data values appropriately
/* 3) Output results
/********************************************************************/
STDMETHODIMP CISAC_Assembly::AverageValues()
{
	// Local variables
	int			i;
	SAFEARRAY		*mysa;

	if(m_bInitial == false)
	{
		double Angle[6];

		// In the first call make output angle_AvgActualJointAngle to be the home position of ISAC.
		Angle[0] =   0.0;
		Angle[1] =  90.0;
		Angle[2] =-180.0;
		Angle[3] =   0.0;
		Angle[4] =  90.0;
		Angle[5] =   0.0;

		// 1) Get pointers to object and interface of Angle and fill Angle vector.
		m_Bindings->get_Pointers(SysAllocString(L"angle_AvgActualJointAngle"), &IUnkAvgJointAngle);
		if(IUnkAvgJointAngle == NULL) return !S_OK;
		IUnkAvgJointAngle->QueryInterface(IID_IVectorSignal, (void**)&pIVSLAvgJointAngle);
		if(pIVSLAvgJointAngle == NULL)	return !S_OK;

		// Copy data to Angle member variable. Used when executing the Jacobian.
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		memcpy(mysa->pvData,Angle,sizeof(double)*NUM_AXES);		
		pIVSLAvgJointAngle->SetCurrentVector(mysa);		
		SafeArrayDestroy(mysa);
		pIVSLAvgJointAngle->Release();

		// Change flag
		m_bInitial = true;
	}

	else
	{

		// 1) ***** Get Sensory inputs ***** // 
		// a) Get pointers to objects 
		m_Bindings->get_Pointers(SysAllocString(L"force_RightATIForceSensor"),	&IUnkRightForceSensor);	
		m_Bindings->get_Pointers(SysAllocString(L"force_LeftATIForceSensor"),	&IUnkLeftForceSensor);	
		m_Bindings->get_Pointers(SysAllocString(L"force_AvgForceSensorData"),	&IUnkAvgForce);	

		m_Bindings->get_Pointers(SysAllocString(L"angle_RightActualJointAngle"),&IUnkRightActualJointAngle);	
		m_Bindings->get_Pointers(SysAllocString(L"angle_LeftActualJointAngle"),	&IUnkLeftActualJointAngle);	
		m_Bindings->get_Pointers(SysAllocString(L"angle_AvgActualJointAngle"),	&IUnkAvgJointAngle);	

		// Check for null pointers
		if(IUnkRightForceSensor == NULL || IUnkLeftForceSensor == NULL || IUnkAvgForce == NULL || IUnkRightActualJointAngle == NULL || IUnkLeftActualJointAngle == NULL || IUnkAvgJointAngle == NULL)	
			return !S_OK;

		// b) Get pointers to Interface 
		IUnkRightForceSensor->QueryInterface(IID_IVectorSignal,(void **)&pIVSLeftForce);
		IUnkLeftForceSensor->QueryInterface(IID_IVectorSignal,(void **)&pIVSRightForce);
		IUnkAvgForce->QueryInterface(IID_IVectorSignal,(void **)&pIVSAvgForce);
		
		IUnkRightActualJointAngle->QueryInterface(IID_IVectorSignal,(void **)&pIVSLeftJointAngle);
		IUnkLeftActualJointAngle->QueryInterface(IID_IVectorSignal,(void **)&pIVSRightJointAngle);
		IUnkAvgJointAngle->QueryInterface(IID_IVectorSignal,(void **)&pIVSLAvgJointAngle);
			
		// Check for null pointers
		if(pIVSLeftForce == NULL || pIVSRightForce == NULL || pIVSAvgForce == NULL || pIVSLeftJointAngle == NULL || pIVSRightJointAngle == NULL || pIVSLAvgJointAngle == NULL)	
			return !S_OK;

		// c) Copy input data to local variables

		// Force
		/** Left **/
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		pIVSLeftForce->GetCurrentVector(mysa);
		memcpy(m_dLeftForceValues, mysa->pvData,sizeof(double)*(NUM_AXES));	// Set the Actual Physical Angles
		// Destroy SafeArray
		SafeArrayDestroy(mysa);
		pIVSLeftForce->Release();

		/** Right **/
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		pIVSRightForce->GetCurrentVector(mysa);
		memcpy(m_dRightForceValues, mysa->pvData,sizeof(double)*(NUM_AXES));	// Set the Actual Physical Angles
		// Destroy SafeArray
		SafeArrayDestroy(mysa);
		pIVSRightForce->Release();

		// Angles
		/** Left **/
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		pIVSLeftJointAngle->GetCurrentVector(mysa);
		memcpy(m_dLeftJointAngles, mysa->pvData,sizeof(double)*(NUM_AXES));	// Set the Actual Physical Angles
		// Destroy SafeArray
		SafeArrayDestroy(mysa);
		pIVSLeftJointAngle->Release();

		/** Right **/
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		pIVSRightJointAngle->GetCurrentVector(mysa);
		memcpy(m_dRightJointAngles, mysa->pvData,sizeof(double)*(NUM_AXES));	// Set the Actual Physical Angles
		// Destroy SafeArray
		SafeArrayDestroy(mysa);
		pIVSRightJointAngle->Release();

		// 2) ***** Average Values ***** // 
		// Force and Joint Angles
		for(i=0;i<NUM_AXES;i++)
		{
			m_dAvgActualForce[i]		= (m_dLeftForceValues[i] + m_dRightForceValues[i])/2;
			m_dAvgActualJointAngles[i]	= (m_dLeftJointAngles[i] + m_dRightJointAngles[i])/2;
		}

		// 3) Average results over time
		// Average Data by using a low-pass frequency filter equation.
		// We use alpha as a parameter to establish the weight of old or new data
		// It creates an averaging filter over time.
		for (i=0; i<NUM_AXES; i++)
		{
			m_dAveragedForceData[i] = (1 - alpha) * m_dPreviousForceData[i] + alpha * m_dAvgActualForce[i];
			m_dAveragedJointData[i] = (1 - alpha) * m_dPreviousJointData[i] + alpha * m_dAvgActualJointAngles[i];

			// Copy current data into Previous member data array
			m_dPreviousForceData[i] = m_dAveragedForceData[i];
			m_dPreviousJointData[i] = m_dAveragedJointData[i];
		}
			

		// 4) ***** Output Results ***** // 
		// Force Avg
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		memcpy(mysa->pvData, m_dAvgActualForce, sizeof(double)*(NUM_AXES));	// Set the Actual Physical Angles
		pIVSAvgForce->SetCurrentVector(mysa);
		// Destroy SafeArray
		SafeArrayDestroy(mysa);
		pIVSAvgForce->Release();

		// Actual Angles
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		memcpy(mysa->pvData, m_dAvgActualJointAngles, sizeof(double)*(NUM_AXES));	// Set the Actual Physical Angles
		pIVSLAvgJointAngle->SetCurrentVector(mysa);
		// Destroy SafeArray
		SafeArrayDestroy(mysa);
		pIVSLAvgJointAngle->Release();
	}

	return S_OK;
}

STDMETHODIMP CISAC_Assembly::Close()
{
	// Reset all parameters. Basically calling constructor again.
	// Useful to start from scratch without having to close the component.
	for(int i=0;i<NUM_AXES;i++)
		{
			// Force variables
			m_dLeftForceValues[i]		= 0.0;				// Used to store incoming values from left force sensor
			m_dRightForceValues[i]		= 0.0;
			m_dAvgActualForce[i]		= 0.0;

			// Joint variables
			m_dLeftJointAngles[i]		= 0.0;				// Used to store actual joint angle positions for ISACs left arm
			m_dRightJointAngles[i]		= 0.0;
			m_dAvgActualJointAngles[i]	= 0.0;

			// Averaging variables
			m_dAveragedForceData[i]		= 0.0;
			m_dPreviousForceData[i]		= 0.0;

			m_dAveragedJointData[i]		= 0.0;
			m_dPreviousJointData[i]		= 0.0;
		}	
		
		// Weighted averaging parameter
		alpha						= 0.85;

		// IComponent Pointers
		IUnkRightForceSensor		= NULL;
		IUnkLeftForceSensor			= NULL;
		IUnkAvgForce				= NULL;

		IUnkRightActualJointAngle	= NULL;
		IUnkLeftActualJointAngle	= NULL;				
		IUnkAvgJointAngle			= NULL;	

		// IVectorSignal Pointers
		pIVSLeftForce	= NULL;
		pIVSRightForce	= NULL;
		pIVSAvgForce	= NULL;
		
		pIVSLeftJointAngle	= NULL;
		pIVSRightJointAngle	= NULL;
		pIVSLAvgJointAngle	= NULL;

		// Change initial flag
		m_bInitial = false;

	return S_OK;
}
