// ControlBasis.cpp : Implementation of CControlBasis
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A note about this template:
// This template is autogenerated. The template code can be found in \ProgramFiles\MicrosoftVisualStudio\Common\MSDev\Templates\ATL
// Specifically customized for an IMA 2.5 component.
// Created by Juan Rojas. Jan 08.
//
// You can also look at an example compenent created by Christina Campbell at O:\Components\ExampleComp
// If you are just learning look at that component to see more details than those included in this template.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "IMA2_ControlBasisLib.h"
#include "ControlBasis.h"

/////////////////////////////////////////////////////////////////////////////
// CControlBasis
// 
// Include Class comments.
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
// CControlBasis::OnConstruct() 
// OnConstruct() is called when the component is created. In addition to putting in
// whatever initialization code you need, If you are going to connect to another
// component anywhere in your code, you need to set up bindings. 
//
// The following code will create one binding. Change "DescriptiveName" to some
// appropriate string. This string will be visible as the name of the binding from
// DAD. It is *not* the name of the component you will bind to. The name of the
// specific component on the other end of the binding is determined at runtime (in DAD).
//
// If you wish to allow only one component to connect to this binding, make the BindType
// BT_Default. If you wish to allow several components, make the BindType BT_Collection.
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CControlBasis::OnConstruct()
{
// TODO: Bindings. Personalize the binding of your component. 
	IMA2_BindingInfo	BindInf;

	long x[1] = { 0 };
	SAFEARRAYBOUND		SafeArrayBoundIn[1];										// We're making a one-dimensional SafeArray
	SafeArrayBoundIn[0].lLbound		= 0;											// Our SafeArray starts at index 0
	SafeArrayBoundIn[0].cElements	= 1;

	// **START**
	// 1. Dominant Controller - Desired Input Vector
	BindInf.Name		= SysAllocString(L"DomCont_DesiredInput");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// 2. Dominant Controller - Actual Input Vector
	BindInf.Name		= SysAllocString(L"DomCont_ActualInput");							// Assign name to object
	BindInf.BindType	= BT_Collection;													// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");												// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);					// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);					// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// 3. Dominant Controller - Output Vector
	BindInf.Name		= SysAllocString(L"DomCont_Output");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// 4. Subordinate Controller - Desired Input Vector
	BindInf.Name		= SysAllocString(L"SubCont_DesiredInput");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// 5. Subordinate Controller - Actual Input Vector
	BindInf.Name		= SysAllocString(L"SubCont_ActualInput");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	// Commented out in Feb. 2009. This binding will be used by the cartesian controller (when its selected) as the output binding.
	//SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	//SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// 6. Subordinate Controller - Output Vector
	BindInf.Name		= SysAllocString(L"SubCont_Output");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// 7. JointAngle
	BindInf.Name		= SysAllocString(L"ActualAngle");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// 8. Actual Cartesian Position
	BindInf.Name		= SysAllocString(L"ActualCartesian");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// 9. HP3JC
	BindInf.Name		= SysAllocString(L"HP3JC");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_MotomanLib.HP3JC"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IHP3JC"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// 10. CumulativeError
	BindInf.Name		= SysAllocString(L"CumulativeError");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// 10. CumulativeError
	BindInf.Name		= SysAllocString(L"_StateMachine");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"StateMachineProj.StateMachine"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IStateMachine"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// Deallocate storage
	SysFreeString(BindInf.Name);
	SysFreeString(BindInf.Path);
	SafeArrayDestroy(BindInf.PIDs);
	SafeArrayDestroy(BindInf.IIDs);

	return S_OK;
}
STDMETHODIMP CControlBasis::OnDestruct() {	return S_OK; }
//////////////////////////////////////////////////////////////////////////////////////////
// CControlBasis::Save(VARIANT *pData)
// This method is called by DAD when a component is saved. Items that should be saved are the
// ones that are important to the setup of the code, or user options that should hold over
// from one use of an agent to another. (Example: size of data, filenames, etc.) 
//
// For each variable to be saved, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to GetPropertyBag). Change the
// term "DescriptiveName" to something descriptive of the item you are saving, and make
// sure not to reuse names. In the next line of code, change "m_MyPrivateVariable" to the variable
// you are saving and VarType to the VarType of that value. Valid types and VarTypes are:
// (Note: These are limited by VB/OLE compatibility, not by the list of things that Variants can be.)
// short:	VT_I2
// int:		VT_I4
// float:	VT_R4
// double:	VT_R8
// BSTR:	VT_BSTR
// char:	VT_BYTE
// All strings (char*) should be converted to BSTR (see BSTR documentation).
// A CString can be converted to a BSTR using the member function AllocSysString (see CString documentation)
//
// If you want to save an array, you have to assign a SAFEARRAY to the Variant. (Do NOT just
// use a pointer, it will save just one value). replace the line starting "ItemValue =" with the following 
// code (substituting your pointer for "variable", the array length for "numelem", int/float/double, etc. 
// for "Type", and using the VarType of one element of the array--BSTR arrays are not allowed.):
//
//	ItemValue = new variant_t;
//	ItemValue->vt=VT_ARRAY|VarType;
//	ItemValue->parray=SafeArrayCreateVector(VarType,0,numelem);
//  memcpy(ItemValue->parray->pvData,variable,numelem*sizeof(Type));
//
// Note: "delete ItemValue" will take care of destroying the safearray (do *not* call SafeArrayDestroy).
// Because of the nature of a SafeArray, you do not have to explicitly save the length of the array.
// However, due to the nature of property bags, you must call the array version of the Add function:
//
//  hRes = pIPB->AddArrayToPropertyBag(&ItemName, ItemValue);
//
// (See Load comments for how to extract arrays from the propertybag).
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CControlBasis::Save(VARIANT *pData) {
	
	// Variables
	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	variant_t				*ItemValue;
	_PropertyBagWrapper		*pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		if (pIPB == NULL)	
			return !S_OK;
		
		// **START**
		// Create string names for items to be saved
		// m_sWhichIsDomController
		ItemName = SysAllocString(L"WhichIsDomController");
		// Store the data and the type of data into a variant_t type
 		ItemValue = new variant_t(m_sWhichIsDomController,VT_I2);
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**

		// **START**
		// Create string names for items to be saved
		// m_sWhichIsSubController
		ItemName = SysAllocString(L"WhichIsSubController");
		// Store the data and the type of data into a variant_t type
 		ItemValue = new variant_t(m_sWhichIsSubController,VT_I2);
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**

		// **START**
		// Create string names for items to be saved
		// m_sWhatRobot
		ItemName = SysAllocString(L"WhatRobot");
		// Store the data and the type of data into a variant_t type
 		ItemValue = new variant_t(m_sWhatRobot,VT_I2);
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**

		// **START**
		// Create string names for items to be saved
		// m_sNumControllers
		ItemName = SysAllocString(L"NumControllers");
		// Store the data and the type of data into a variant_t type
 		ItemValue = new variant_t(m_sNumControllers,VT_I2);
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**
/*
		// **START**
		// Create string names for items to be saved
		// m_bstrWhatRobot
		ItemName = SysAllocString(L"bstrWhatRobot");
		// Store the data and the type of data into a variant_t type
 		ItemValue = new variant_t(m_bstrWhatRobot,VT_BSTR);
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**

*/

		// Returns a pointer to the PropertyBag as a VARIANT
		hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
		
		// Copy the contents of the property bag to the pData VARIANT
		VariantCopy(pData, &m_VBPropertyBag);
		// Save the size of the data 
		m_lDataSize = pData->parray->rgsabound[0].cElements;		
		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);
		
		// Release
		pIPB->Release();

	return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////
// CControlBasis::Load(VARIANT Data)
// This function will load in all the data you just saved in the Save function.
// 
// For each variable to be loaded, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to VariantClear). Change the
// term "NameUsedToSave" to the name you gave this item in Save.
// On the line beginning "variable = ", change "variable" to the variable that you saved
// the value from, and change "Type" to the type of that variable (use "long" for "int")
// A CString can be directly set to a BSTR, but in order to get a char* back, you have to 
// use strcpy (I think).
//
// If you made an array, you have to load it back in now.
// Just like in the save function, you must call the array version of the Get function:
//
//  pIPB->GetArrayFromPropertyBag(&ItemName, ItemValue);
//
// If your variable is dynamically allocated, make sure to delete and reallocate it:
//
//  if(variable!=NULL)
//		delete variable;
//  variable=new Type[ItemValue->parray->rgsabound->cElements];	
//
// Then just copy the values from the parray (replace the "variable =" line with this):
//
//  memcpy(variable,ItemValue->parray->pvData,ItemValue->parray->rgsabound->cElements*sizeof(Type));
//
// Note that this means you do not have to separately save the length of the array, although if
// you have a variable that keeps track of the array length you should also set it at this point:
//
//  numelem=ItemValue->parray->rgsabound->cElements;
//
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CControlBasis::Load(VARIANT Data) {
	
	// Variables
	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	_PropertyBagWrapper*	pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	variant_t				*ItemValue;
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		if (pIPB == NULL)	
			return !S_OK;
		// Get the pointer to the real VB property bag (the VB object (defined in msvbvm60.dll (aka VBRUN)) that our wrapper class created)
		// hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
		
		// Pass Data to PropertyBag
		hRes = pIPB->SetPropertyBag(&Data);

		// **START**
		// Variable m_sWhichIsDomController
		// Define strings
		ItemName		= SysAllocString(L"WhichIsDomController");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetFromPropertyBag(&ItemName,ItemValue);  //2nd argument is return value (look retval for help)
		m_sWhichIsDomController	= (short)*ItemValue;
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**

		// **START**
		// Variable m_sWhichIsSubController
		// Define strings
		ItemName		= SysAllocString(L"WhichIsSubController");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetFromPropertyBag(&ItemName,ItemValue);  //2nd argument is return value (look retval for help)
		m_sWhichIsSubController	= (short)*ItemValue;
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**

		// **START**
		// Variable m_sWhatRobot
		// Define strings
		ItemName		= SysAllocString(L"WhatRobot");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetFromPropertyBag(&ItemName,ItemValue);  //2nd argument is return value (look retval for help)
		m_sWhatRobot	= (short)*ItemValue;
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**

		// **START**
		// Variable m_sNumControllers
		// Define strings
		ItemName		= SysAllocString(L"NumControllers");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetFromPropertyBag(&ItemName,ItemValue);  //2nd argument is return value (look retval for help)
		m_sNumControllers	= (short)*ItemValue;
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**

/*		// **START**
		// Variable m_bstrWhatRobot
		// Define strings
		ItemName		= SysAllocString(L"bstrWhatRobot");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetFromPropertyBag(&ItemName,ItemValue);  //2nd argument is return value (look retval for help)
		m_bstrWhatRobot	= SysAllocString((BSTR)*ItemValue);
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**
*/
		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);
		
		// Release
		pIPB->Release();
	
	return S_OK;
}


/************************************************************************
****************************** Properties *******************************
************************************************************************/

/****************************************************
* ErrorMessage()
* Used to print the status of the program and help the
* user see what is happening in the system in RT.
*
* The variable m_bstrError should be updated in member
* functions whenever the developper wants to print a 
* message.
*
* The PUT function is empty as we don't need the input
* of the user.
****************************************************/
STDMETHODIMP CControlBasis::get_ErrorMessage(BSTR *pVal)
{
	if (pVal != NULL)
		*pVal = m_bstrError;
	return S_OK;
}

STDMETHODIMP CControlBasis::put_ErrorMessage(BSTR newVal)
{
	// Keep empty. We don't want the user to change this.
	m_bstrError = SysAllocString(L"This component controlls valves and has PID or NN Controller");

	return S_OK;
}

/****************************************************
* WhatRobot()
* Indicates what robot we are using. There are two 
* possible options: ISAC and HP3JC.
*
* 1) Function receives a string
* 2) Converts to lower case
* 3) Assigns a flag to identify selected robot.
* 4) Calls a functions that sets all the parameters
*    (gains) for the assigned robot.
*
* Error: if user types an unrecognized robot, the 
* prompt will ask the user to input either ISAC or
* HP3JC.
****************************************************/
STDMETHODIMP CControlBasis::get_WhatRobot(BSTR *pVal)
{
	if(pVal != NULL)
	{
		if (m_sWhatRobot == ISAC_ROBOT)
				*pVal = SysAllocString(L"ISAC");
	
		if (m_sWhatRobot == HP3JC_ROBOT)
			*pVal = SysAllocString(L"HP3JC");
	}
	return S_OK;
}

STDMETHODIMP CControlBasis::put_WhatRobot(BSTR newVal)
{
	USES_CONVERSION;	// Macro to use string conversions
	// Set tags for internal variable
	if(strcmp(strupr(OLE2T(newVal)),"ISAC")==0)
	{
		m_sWhatRobot = ISAC_ROBOT;
		m_bstrWhatRobot = SysAllocString(L"ISAC");
	}

	else if(strcmp(strupr(OLE2T(newVal)),"HP3JC")==0)
	{
		m_sWhatRobot = HP3JC_ROBOT;
		m_bstrWhatRobot = SysAllocString(L"HP3JC");
	}

	// Otherwise do not copy to local variable and print warning message
	else
		m_bstrError = SysAllocString(L"Please either enter ISAC or HP3JC");

	return S_OK;
}

/****************************************************
* cont_NumControllers()
* Indicates how many controllers are in use. We can 
* have a minimum of 1 and a maximum of 2;
*
* If only 1 controller is used, then clear the string
* tag for the subordinate controller. Do this by calling
* put_cont_SubcONTType()
****************************************************/
STDMETHODIMP CControlBasis::get_cont_NumControllers(short *pVal)
{
	if(pVal != NULL)
		*pVal = m_sNumControllers;		

	return S_OK;
}

STDMETHODIMP CControlBasis::put_cont_NumControllers(short newVal)
{
	// Verify that we are only selecting 1 or 2 controllers.
	if(newVal < 1 || newVal > 2)
		m_bstrError = SysAllocString(L"Select 1 or 2 controllers.");
	else
		m_sNumControllers = newVal;

	// Clear the string tag of the subordinate controller and flag internal variable
	if (newVal == 1)
	{
		put_cont_SubContType( SysAllocString(L"NONE") );
		m_sWhichIsSubController = NOT_ACTIVE;
	}

	else
		m_bstrError = SysAllocString(L"You have selected 2 controllers.");


	return S_OK;
}

/****************************************************
* cont_DomContType()
* This function will read a string input provided by
* the user. The string can either read POSITION, FORCE
* or MOMENT.
*
* This string will indicate that that type of controller
* will be the dominant one for this program.
*
* After passing a valid string, a flag will be assigned
* that identifies the user selection.
*
* If the string contains a wrong name, an warning message
* will print through DAD's interface message property.
****************************************************/
STDMETHODIMP CControlBasis::get_cont_DomContType(BSTR *pVal)
{
	// Select the jacobian position controller 
	if (m_sWhichIsDomController == DOMINANT_POSITION_CONTROLLER)
			*pVal = SysAllocString(L"POSITION");

	// Select the inverse kinematic position controller - added Sept 2008
	if (m_sWhichIsDomController == DOMINANT_IKIN_CONTROLLER)
			*pVal = SysAllocString(L"IKIN");	

	// Select the inverse kinematic position controller
	if (m_sWhichIsDomController == DOMINANT_CARTESIAN_CONTROLLER)
			*pVal = SysAllocString(L"CARTESIAN");

	// Select the force controller
	if (m_sWhichIsDomController == DOMINANT_FORCE_CONTROLLER)
			*pVal = SysAllocString(L"FORCE");
	
	// Select the moment controller
	if (m_sWhichIsDomController == DOMINANT_MOMENT_CONTROLLER)
			*pVal = SysAllocString(L"MOMENT");

	return S_OK;
}

STDMETHODIMP CControlBasis::put_cont_DomContType(BSTR newVal)
{
	USES_CONVERSION;

	// Select position controller as dominant
	if(strcmp(strupr(OLE2T(newVal)),"POSITION")==0)
	{
		m_sWhichIsDomController = DOMINANT_POSITION_CONTROLLER;
		m_bstrError = SysAllocString(L"The Jacobian POSITION controller was selected to be dominant.");
	}

	// Select inverse kinematic controller as dominant, added Sept 2008
	else if(strcmp(strupr(OLE2T(newVal)),"IKIN")==0)
	{
		m_sWhichIsDomController = DOMINANT_IKIN_CONTROLLER;
		m_bstrError = SysAllocString(L"The IKIN POSITION controller was selected to be dominant.");
	}

	else if (strcmp( strupr(OLE2T(newVal)), "CARTESIAN") == 0 )
	{
		m_sWhichIsDomController = DOMINANT_CARTESIAN_CONTROLLER;
		m_bstrError = SysAllocString(L"The CARTESIAN controller was selected to be dominant.");
	}

	// Select force controller as dominant
	else if (strcmp(strupr(OLE2T(newVal)), "FORCE") == 0 )
	{
		m_sWhichIsDomController = DOMINANT_FORCE_CONTROLLER;
		m_bstrError = SysAllocString(L"The FORCE controller was selected to be dominant.");
	}

	// Select moment controller as dominant
	else if (strcmp( strupr(OLE2T(newVal)), "MOMENT") == 0 )
	{
		m_sWhichIsDomController = DOMINANT_MOMENT_CONTROLLER;
		m_bstrError = SysAllocString(L"The MOMENT controller was selected to be dominant.");
	}

	else
		m_bstrError = SysAllocString(L"Please type either POSITION, FORCE, or MOMENT.");		

	return S_OK;
}

/****************************************************
* get_cont_SubContType()
* This function will read a string input provided by
* the user. The string can either read POSITION, FORCE,
* MOMENT, or NONE.
*
* This string will indicate that that type of controller
* will be the subordinate one for this program if it exists.
*
* After passing a valid string, a flag will be assigned
* that identifies the user selection.
*
* If the string contains a wrong name, an warning message
* will print through DAD's interface message property.
****************************************************/
STDMETHODIMP CControlBasis::get_cont_SubContType(BSTR *pVal)
{
	// Select the jacobian position controller 
	if (m_sWhichIsSubController == SUBORDINATE_POSITION_CONTROLLER)
			*pVal = SysAllocString(L"POSITION");
	
	// Select the IKIN position controller 
	if (m_sWhichIsSubController == SUBORDINATE_IKIN_CONTROLLER)
			*pVal = SysAllocString(L"IKIN");

	// Select the CARTESIAN position controller 
	if (m_sWhichIsSubController == SUBORDINATE_CARTESIAN_CONTROLLER)
			*pVal = SysAllocString(L"CARTESIAN");
	
	// Select the force controller
	if (m_sWhichIsSubController == SUBORDINATE_FORCE_CONTROLLER)
			*pVal = SysAllocString(L"FORCE");
	
	// Select the moment controller
	if (m_sWhichIsSubController == SUBORDINATE_MOMENT_CONTROLLER)
			*pVal = SysAllocString(L"MOMENT");

	// Select None
	if (m_sWhichIsSubController == NOT_ACTIVE)
		*pVal = SysAllocString(L"NONE");

	return S_OK;
}

STDMETHODIMP CControlBasis::put_cont_SubContType(BSTR newVal)
{
	USES_CONVERSION;

	// Select position controller as subordinate
	if ( strcmp( strupr(OLE2T(newVal)), "POSITION") == 0 )
	{
		m_sWhichIsSubController = SUBORDINATE_POSITION_CONTROLLER;
		m_bstrError = SysAllocString(L"The POSITION controller was selected to be subordinate.");
		m_sNumControllers = 2; // Indicate that there are two controllers
	}

	// Select Inverse Kinematic controller as subordinate
	if ( strcmp( strupr(OLE2T(newVal)), "IKIN") == 0 )
	{
		m_sWhichIsSubController = SUBORDINATE_IKIN_CONTROLLER;
		m_bstrError = SysAllocString(L"The IKIN controller was selected to be subordinate.");
		m_sNumControllers = 2; // Indicate that there are two controllers
	}

	// Select CARTESIAN controller as subordinate
	if ( strcmp( strupr(OLE2T(newVal)), "CARTESIAN") == 0 )
	{
		m_sWhichIsSubController = SUBORDINATE_CARTESIAN_CONTROLLER;
		m_bstrError = SysAllocString(L"The CARTESIAN controller was selected to be subordinate.");
		m_sNumControllers = 2; // Indicate that there are two controllers
	}


	// Select force controller as subordinate
	else if ( strcmp( strupr(OLE2T(newVal)), "FORCE") == 0 )
	{
		m_sWhichIsSubController = SUBORDINATE_FORCE_CONTROLLER;
		m_bstrError = SysAllocString(L"The FORCE controller was selected to be subordinate.");
		m_sNumControllers = 2; // Indicate that there are two controllers
	}

	// Select moment controller as subordinate
	else if ( strcmp( strupr(OLE2T(newVal)), "MOMENT") == 0 )
	{
		m_sWhichIsSubController = SUBORDINATE_MOMENT_CONTROLLER;
		m_bstrError = SysAllocString(L"The MOMENT controller was selected to be subordinate.");
		m_sNumControllers = 2; // Indicate that there are two controllers
	}

	// Select none
	else if ( strcmp( strupr(OLE2T(newVal)), "NONE") == 0 )
	{
		m_sWhichIsSubController = NOT_ACTIVE;
		m_sNumControllers = 1;
		m_bstrError = SysAllocString(L"The subordinate controller has been de-activated.");
	}

	else
		m_bstrError = SysAllocString(L"Please type either POSITION, FORCE, MOMENT, or NONE.");		


	return S_OK;
}

/****************************************************
* Gain_Indeces()
* Contain the indeces for the different gains. 
* Value has to be between 0 and 5.
****************************************************/
STDMETHODIMP CControlBasis::get_gain_PositionGainIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sPositionGainIndex;
	
	return S_OK;
}

STDMETHODIMP CControlBasis::put_gain_PositionGainIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sPositionGainIndex = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_gain_IKinGainIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sIKinGainIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_gain_IKinGainIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sIKinGainIndex = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_gain_ForceGainIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sForceGainIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_gain_ForceGainIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sForceGainIndex = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_gain_MomentGainIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sMomentGainIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_gain_MomentGainIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sMomentGainIndex = newVal;

	return S_OK;
}

/****************************************************
* gain_PositionGain()
* Retrieves the value for the position gain depending 
* on the robot selected. 
****************************************************/
STDMETHODIMP CControlBasis::get_gain_PositionGain(double *pVal)
{
	if (pVal != NULL)
		*pVal = m_dPositionGain[m_sPositionGainIndex];
	return S_OK;
}

STDMETHODIMP CControlBasis::put_gain_PositionGain(double newVal)
{
	m_dPositionGain[m_sPositionGainIndex] = newVal;
	return S_OK;
}

STDMETHODIMP CControlBasis::get_gain_IKinGain(double *pVal)
{
	if (pVal != NULL)
		*pVal = m_dIKinGain[m_sIKinGainIndex];
	return S_OK;
}

STDMETHODIMP CControlBasis::put_gain_IKinGain(double newVal)
{
	m_dIKinGain[m_sIKinGainIndex] = newVal;
	return S_OK;
}

STDMETHODIMP CControlBasis::get_gain_ForceGain(double *pVal)
{
	if (pVal != NULL)
		*pVal = m_dForceGain[m_sForceGainIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_gain_ForceGain(double newVal)
{
	m_dForceGain[m_sForceGainIndex] = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_gain_MomentGain(double *pVal)
{
	if (pVal != NULL)
		*pVal = m_dMomentGain[m_sMomentGainIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_gain_MomentGain(double newVal)
{
	m_dMomentGain[m_sMomentGainIndex] = newVal;

	return S_OK;
}

/***************************************************************************************/
/* DesFT_ReferenceValue()
/*
/* Set the reference values for either the DesiredForce Vector signal or 
/* the DesiredMoment Vector Signal. We will connect to the VS binding and 
/* write the value for the reference there.
/* If Index is 0, 1, 2, then we check to see if we have a force controller (dom/sub)
/* else we check for a moment controller (dom/sub).
/**************************************************************************************/
STDMETHODIMP CControlBasis::get_ref_DesFT_ReferenceValue(double *pVal)
{
	*pVal = m_dFTReferenceValue[m_sFTReferenceValueIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_ref_DesFT_ReferenceValue(double newVal)
{
	// Localvariables
	SAFEARRAY *mysa;
	IVectorSignal *pIVSRefInput   = NULL;
	IComponent    *IUnkFTRefValue = NULL;

	// Set the new value
	m_dFTReferenceValue[m_sFTReferenceValueIndex] = newVal;

	// Post it to the appropriate desired Vector Signal. Either Desired Dominant/Subordinate Input

	// Force Controller
	if(m_sFTReferenceValueIndex < 3)
	{
		// Check type of controller we have
		if(m_sWhichIsDomController == DOMINANT_FORCE_CONTROLLER)
		{
			// (1) Get dominant vector data. Get (a) object pointers, (b) interface pointers, (c) VS data.
			m_Bindings->get_Pointers(SysAllocString(L"DomCont_DesiredInput"), &IUnkFTRefValue);
			if(IUnkFTRefValue == NULL)
				{
					MessageBox(NULL, "Cannot connect to dominant desired vector", "Error::get_Pointers()",MB_OK);
					return !S_OK;
				}

			// (b) Get Interface pointers
			IUnkFTRefValue->QueryInterface(IID_IVectorSignal, (void **)&pIVSRefInput);

			// (c) Desired VS Data
			if(pIVSRefInput != NULL)	
			{
				mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
				memcpy(mysa->pvData,m_dFTReferenceValue,sizeof(double)*NUM_AXES);
				pIVSRefInput->SetCurrentVector(mysa);
				SafeArrayDestroy(mysa);
				pIVSRefInput->Release();
			}
		}

		// Else, we have a subordinate controller
		else
		{
			if(m_sWhichIsSubController == SUBORDINATE_FORCE_CONTROLLER)
			{
				// (1) Get dominant vector data. Get (a) object pointers, (b) interface pointers, (c) VS data.
				m_Bindings->get_Pointers(SysAllocString(L"SubCont_DesiredInput"), &IUnkFTRefValue);
				if(IUnkFTRefValue == NULL)
				{
					MessageBox(NULL, "Cannot connect to subordinate desired vector", "Error::get_Pointers()",MB_OK);
					return !S_OK;
				}

				// (b) Get Interface pointers
				IUnkFTRefValue->QueryInterface(IID_IVectorSignal, (void **)&pIVSRefInput);

				// (c) Desired VS Data
				if(pIVSRefInput != NULL)	
				{
					mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
					memcpy(mysa->pvData,m_dFTReferenceValue,sizeof(double)*NUM_AXES);
					pIVSRefInput->SetCurrentVector(mysa);
					SafeArrayDestroy(mysa);
					pIVSRefInput->Release();
				}
			}
		}

	}

	// Moment Controller. Our index tells us we have a moment controller. What type dominant or subordinate, check next:
	else
	{
		// Check type of controller we have
		if(m_sWhichIsDomController == DOMINANT_MOMENT_CONTROLLER)
		{
			// (1) Get dominant vector data. Get (a) object pointers, (b) interface pointers, (c) VS data.
			m_Bindings->get_Pointers(SysAllocString(L"DomCont_DesiredInput"), &IUnkFTRefValue);
			if(IUnkFTRefValue == NULL)
				{
					MessageBox(NULL, "Cannot connect to dominant desired vector", "Error::get_Pointers()",MB_OK);
					return !S_OK;
				}

			// (b) Get Interface pointers
			IUnkFTRefValue->QueryInterface(IID_IVectorSignal, (void **)&pIVSRefInput);

			// (c) Desired VS Data
			if(pIVSRefInput != NULL)	
			{
				mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
				memcpy(mysa->pvData,m_dFTReferenceValue,sizeof(double)*NUM_AXES);
				pIVSRefInput->SetCurrentVector(mysa);
				SafeArrayDestroy(mysa);
				pIVSRefInput->Release();
			}
		}

		// Else, we have a subordinate controller
		else
		{
			if(m_sWhichIsSubController == SUBORDINATE_MOMENT_CONTROLLER)
			{
				// (1) Get dominant vector data. Get (a) object pointers, (b) interface pointers, (c) VS data.
				m_Bindings->get_Pointers(SysAllocString(L"SubCont_DesiredInput"), &IUnkFTRefValue);
				if(IUnkFTRefValue == NULL)
				{
					MessageBox(NULL, "Cannot connect to subordinate desired vector", "Error::get_Pointers()",MB_OK);
					return !S_OK;
				}

				// (b) Get Interface pointers
				IUnkFTRefValue->QueryInterface(IID_IVectorSignal, (void **)&pIVSRefInput);

				// (c) Desired VS Data
				if(pIVSRefInput != NULL)	
				{
					mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
					memcpy(mysa->pvData,m_dFTReferenceValue,sizeof(double)*NUM_AXES);
					pIVSRefInput->SetCurrentVector(mysa);
					SafeArrayDestroy(mysa);
					pIVSRefInput->Release();
				}
			}
		}

	}

	return S_OK;
}

/****************************************************/
// Ref Value indeces
/****************************************************/
STDMETHODIMP CControlBasis::get_ref_DesFT_ReferenceValueIndex(short *pVal)
{
	*pVal = m_sFTReferenceValueIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_ref_DesFT_ReferenceValueIndex(short newVal)
{
	if(newVal>=0 && newVal<6)
		m_sFTReferenceValueIndex = newVal;
	return S_OK;
}


/****************************************************/
/* Dominant: Vector_Indeces()
/* Contain the indeces for the different gains. 
/* Value has to be between 0 and 5.
****************************************************/
STDMETHODIMP CControlBasis::get_dom_DesiredVectorIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sDomCont_DesInputIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_dom_DesiredVectorIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sDomCont_DesInputIndex = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_dom_ActualVectorIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sDomCont_ActualInputIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_dom_ActualVectorIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sDomCont_ActualInputIndex = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_dom_OutputVectorIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sDomCont_OutputIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_dom_OutputVectorIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sDomCont_OutputIndex = newVal;

	return S_OK;
}
/****************************************************
* Dominant: Desired, Actual, Output Vectors()
* Reads and prints values for vectors.
*
* Values of vectors must be doubles.
****************************************************/
STDMETHODIMP CControlBasis::get_dom_DesiredVector(double *pVal)
{
	if(pVal != NULL)
		*pVal = m_dDomCont_DesInput[m_sDomCont_DesInputIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_dom_DesiredVector(double newVal)
{
	m_dDomCont_DesInput[m_sDomCont_DesInputIndex] = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_dom_ActualVector(double *pVal)
{
	if(pVal != NULL)
		*pVal = m_dDomCont_ActualInput[m_sDomCont_ActualInputIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_dom_ActualVector(double newVal)
{
	m_dDomCont_ActualInput[m_sDomCont_ActualInputIndex] = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_dom_OutputVector(double *pVal)
{
	if(pVal != NULL)
		*pVal = m_dDomCont_Output[m_sDomCont_OutputIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_dom_OutputVector(double newVal)
{
	m_dDomCont_Output[m_sDomCont_OutputIndex] = newVal;

	return S_OK;
}

/****************************************************
* Subordinate: Vector_Indeces()
* Contain the indeces for the different gains. 
* Value has to be between 0 and 5.
****************************************************/

STDMETHODIMP CControlBasis::get_sub_ActualVectorIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sSubCont_ActualInputIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_sub_ActualVectorIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sSubCont_ActualInputIndex = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_sub_DesiredVectorIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sSubCont_DesInputIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_sub_DesiredVectorIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sSubCont_DesInputIndex = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_sub_OutputVectorIndex(short *pVal)
{
	if (pVal != NULL)
		*pVal = m_sSubCont_OutputIndex;

	return S_OK;
}

STDMETHODIMP CControlBasis::put_sub_OutputVectorIndex(short newVal)
{
	if(newVal >= 0 && newVal <= 5)
		m_sSubCont_OutputIndex = newVal;

	return S_OK;
}

/****************************************************
* Subordinate: Desired, Actual, Output Vectors()
* Reads and prints values for vectors.
*
* Values of vectors must be doubles.
****************************************************/
STDMETHODIMP CControlBasis::get_sub_DesiredVector(double *pVal)
{
	if(pVal != NULL)
		*pVal = m_dSubCont_DesInput[m_sSubCont_DesInputIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_sub_DesiredVector(double newVal)
{
	m_dSubCont_DesInput[m_sSubCont_DesInputIndex] = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_sub_ActualVector(double *pVal)
{
	if(pVal != NULL)
		*pVal = m_dSubCont_ActualInput[m_sSubCont_ActualInputIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_sub_ActualVector(double newVal)
{
	m_dSubCont_ActualInput[m_sSubCont_ActualInputIndex] = newVal;

	return S_OK;
}

STDMETHODIMP CControlBasis::get_sub_OutputVector(double *pVal)
{
	if(pVal != NULL)
		*pVal = m_dSubCont_Output[m_sSubCont_OutputIndex];

	return S_OK;
}

STDMETHODIMP CControlBasis::put_sub_OutputVector(double newVal)
{
	m_dSubCont_Output[m_sSubCont_OutputIndex] = newVal;

	return S_OK;
}

/************************************************************************
**************************  Interface Methods  **************************
************************************************************************/

/****************************************************
* Initialize()
*
* This function will set the gains for the controllers
* according to which robot we are using.
****************************************************/
STDMETHODIMP CControlBasis::Initialize()
{
	// 1) Set the gains for appropriate robot
	SetGains();

	// 2) Set the values of the variables for home positions according to controllers
	WriteJointAngleHomePosition();

	// 3) Set flag to write controller data to file throughout the entire project
	m_bWrite2File = true;

	/******************** CONTROLLER REFERENCES ***************************/
	// 4) Set any reference values for the controllers
	if(m_sWhichIsSubController == SUBORDINATE_FORCE_CONTROLLER)
	{
		// Local Variables		
		SAFEARRAY *mysa;
		IVectorSignal *pIVSSubDesInput = NULL;

		// Set our reference value buffer to our desired results
		m_dFTReferenceValue[0] = Des_Fx_Approach;
		m_dFTReferenceValue[1] = Des_Fy_Approach;
		m_dFTReferenceValue[2] = Des_Fz_Approach;

		// (1) Get dominant vector data. Get (a) object pointers, (b) interface pointers, (c) VS data.
		m_Bindings->get_Pointers(SysAllocString(L"SubCont_DesiredInput"), &m_pIUnkSubCont_DesInput);
		if(m_pIUnkSubCont_ActualInput != NULL)
		{
			// (b) Get Interface pointers
			m_pIUnkSubCont_DesInput->QueryInterface(IID_IVectorSignal, (void **)&pIVSSubDesInput);

			// (c) Desired VS Data
			if(pIVSSubDesInput != NULL)	
			{
				mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
				memcpy(mysa->pvData,m_dFTReferenceValue,sizeof(double)*NUM_AXES);
				pIVSSubDesInput->SetCurrentVector(mysa);
				SafeArrayDestroy(mysa);
				pIVSSubDesInput->Release();
			}
		}

		else
			MessageBox(NULL, "GetSubinantVectorData()::Error. Object pointer could not be found", "Error::get_Pointers()",MB_OK);

	}
	/****************************************************************************/

	// 5) If using Inverse Kinematics, we use matlab for this purpose.
	// Need to initialize Matlab Variables
	if(m_sWhichIsDomController == DOMINANT_IKIN_CONTROLLER || m_sWhichIsSubController == SUBORDINATE_IKIN_CONTROLLER)
	{

		// Allocate memory for matlab variables. We will create two (1 x 6) arrays with real numbers.
		// Note that for these arrays, they must match the dimensions of the matlab result. 
		// mxCreateDoubleMatrix(mwSize rows, mwSize cols,mxComplexity mxREAL or mxComplex);
		m_MatXYZRPY			= mxCreateDoubleMatrix(1, 6, mxREAL);
		m_MatJointAngles	= mxCreateDoubleMatrix(1, 6, mxREAL);

		// Create an array to hold data for tool type
		m_MatToolType		= mxCreateDoubleMatrix(1, 1, mxREAL);

		// Open matlab engine
		// engOpen(const char* startcmd) - for windows the string can be null
		if (!(ep = engOpen(NULL))) {
			m_bstrError = SysAllocString(L"Can't start MATLAB engine");
			return !S_OK;
		}
		else
		{
			// Set engine visibility to zero (ie don't show matlab's command window).
			engSetVisible(ep, 1);

			// Turn the flag on
			m_sMatEngine = 1;

			// Print result
			m_bstrError = SysAllocString(L"Initialize Succeeded");

			// Change alpha to 1. Averaging joint angle results does not seem to help here
			//alpha = 1;
		}
	}	

	return S_OK;
}
/****************************************************
* ComputeControlBasis
* This function computes the controller loop:
* 
*		output = Jacobian Transform * gain * error. 
*
* This function will: 
* 1) Will consider if there are 1 or 2 controllers.
* 2) If there are 2, it will project the output of
*    the second controller unto the null space of the
*    dominant controller.
* 3) The values of the Jacobian and gain will change
*    depending on the type of controller being run.
* 4) Averages the values of the output over time.
* 5) Passes the output to the Output Vector Signal.
* 6) This function will run the controller loop for
*    a certain "NUMBER_OF_CYCLES; 
****************************************************/
STDMETHODIMP CControlBasis::ComputeControlBasis()
{
	// Local variables
	int				i=0;
	short			Counter = 0;
	SAFEARRAY      *mysa;
	IVectorSignal  *pIVSDomOutput;
	/******************************************/
	// Added Jan. 2009, as part of the inclusion of a cartesian controller. Used to call IMOV in HP3JC.		   
	//double dAverageOutputCart[NUM_AXES];
	//double d_PreviousCartOutput[NUM_AXES];

	IVectorSignal  *pIVSSubOutput;	
	/******************************************/


	// 1) Get dominant vector data. Get (a) object pointers, (b) interface pointers, (c) VS data.
	GetDominantVectorData();

	// Check to see if there is 1 or 2 controllers.
	if(m_sNumControllers == 1)
	{
		// 2) Compute controller output. Values are placed in m_dDomCont_Output
	 	ComputeControllerOutput(DOMINANT);

		// 4) Average Data
		// Average Data by using a low-pass frequency filter equation.
		// We use alpha as a parameter to establish the weight of old or new data
		// It creates an averaging filter over time.
		for (i=0; i<NUM_AXES; i++)
			m_dAveragedOutput[i] = (1 - alpha) * m_dPreviousControllerOutput[i] + alpha * m_dDomCont_Output[i];

		// Copy our outgoing data into our PreviousFTData structre
		memcpy(m_dPreviousControllerOutput,m_dAveragedOutput,sizeof(double)*NUM_AXES);

		// 5) Pass the OUTPUT to the vector signal. (Connect to object/interface first).
		/***** OUTPUT UPDATE JOINT CONFIGURATION *****/
		// For all controller except the cartesian controllers, pass output to the DomCont_Output binding. This is used by the HP3JC and called next in the state machine.

		// Connect to object and interface pointer
		m_Bindings->get_Pointers(SysAllocString(L"DomCont_Output"), &m_pIUnkDomCont_Output);
		if(m_pIUnkDomCont_Output == NULL)	return !S_OK;

		m_pIUnkDomCont_Output->QueryInterface(IID_IVectorSignal, (void **)&pIVSDomOutput);
		if(pIVSDomOutput == NULL)	return !S_OK;

		// Copy data
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		memcpy(mysa->pvData,m_dAveragedOutput,sizeof(double)*NUM_AXES);
		pIVSDomOutput->SetCurrentVector(mysa);
		SafeArrayDestroy(mysa);
		pIVSDomOutput->Release();

	}
	/***************************************************
	* For the subordinate controller we need to:
	* 1) Get subordinate vector data
	* 2) Compute the subordinate controller output
	* 3) Compute the dominant controller output
	* 4) Compute the null space projection of the subordinate
	*    controller and store in m_dNullSpaceProjection
	* 5) Compute the combined output and add it to the current joint
	*    angle position
	* 6) Pass averaged data to the output VS
	*****************************************************/
	else
	{
		// 1) Get subordinate vector data. Get (a) object pointers, (b) interface pointers, (c) VS data.
		GetSubordinateVectorData();

		// 2) Compute controller output. Values are placed in m_dSubCont_Output[] in degrees
		ComputeControllerOutput(SUBORDINATE);

		// 3) Compute controller output. Values are placed in m_dDomCont_Output[] in degrees 
		ComputeControllerOutput(DOMINANT);

		// 4) Project the result of the subordinate controller onto the null space of the dominant controller. Values are placed in m_dNullSpaceProjection[]
		// Jan. 2009, if we have a subordinate cartesian controller, we would not perform the null space projection. the cartesian output would be independent from the dominant joing angle output.
		if(m_sWhichIsSubController != SUBORDINATE_CARTESIAN_CONTROLLER)
		{
			ProjectToNullSpace();

			// 6) Compute the combined output and add it to the current joint position of the robot.
			//    Then pass it to the output vector signal. 
			for(i=0; i<NUM_AXES; i++)
			{
				m_dCompositeControllerOutput[i] = m_dDomCont_Output[i] + m_dNullSpaceProjectionOutput[i];
				m_dNullSpaceProjectionOutput[i] = 0;														// Reset the value for this matrix for the next run
				m_dCompositeControllerOutput[i] = m_dCompositeControllerOutput[i] + Angle[i];
			}
		

			// Average Data by using a low-pass frequency filter equation.
			// We use alpha as a parameter to establish the weight of old or new data
			// It creates an averaging filter over time.
			for (i=0; i<NUM_AXES; i++)
				m_dAveragedOutput[i] = (1 - alpha) * m_dPreviousControllerOutput[i] + alpha * m_dCompositeControllerOutput[i];

			// Copy our outgoing data into our PreviousFTData structre
			memcpy(m_dPreviousControllerOutput,m_dAveragedOutput,sizeof(double)*NUM_AXES);
		}

		/********************************************************************************************************************/
		// If we are using the subordinate cartesian controller:
		// we want to output the cartesian space response to the SubCont_Actual binding. The HP3JC is connected to this binding, and we directly call IMOV.
		// There is no call to project the null space of the subordinate controller to the dominant controller.
		else
		{
			// Adding Current Joint Angle positions to Controller Output
			// This normally is done in JacobianProduct(), but it has to be done here for the dominant controller when there is a subordinate cartesian controller				
			for(i = 0; i<NUM_AXES; i++)				
				m_dDomCont_Output[i] = m_dDomCont_Output[i] + Angle[i];

			// In this case we want to average the dominant joint data and the subordinate cartesian data, both separately.
			// Average controlllers
			for (i=0; i<NUM_AXES; i++)
			{
				// Average dominant controller (We are tyring to filter the independent dominant output response)
				m_dAveragedOutput[i] = /*(1 - alpha) * m_dPreviousControllerOutput[i] + alpha * */m_dDomCont_Output[i];
				//m_dPreviousControllerOutput[i] = m_dAveragedOutput[i];

				// Average subordinate controller (here we filter the independent subordinate cartesian response)
				d_AverageOutputCart[i] = (1 - alpha) * d_PreviousCartOutput[i] + alpha * m_dSubCont_Output[i];
				d_PreviousCartOutput[i] = d_AverageOutputCart[i];
			}
				// Send out signal to move the cartesian controller from here.
				// Hoping that as the joint update occurs through the state machine, they will be able to offset each other. 
				// Will post value by using the m_dSubCont_ActualInput

				// Output the updated cartesian space configuration to the subordinate output binding: "SubCont_Output"
				m_Bindings->get_Pointers(SysAllocString(L"SubCont_Output"), &m_pIUnkSubCont_Output);
				if(m_pIUnkSubCont_Output == NULL)	return !S_OK;

				// Connect to the HP3JC Interface
				m_pIUnkSubCont_Output->QueryInterface(IID_IVectorSignal, (void **)&pIVSSubOutput);
				if(pIVSSubOutput == NULL)	return !S_OK;

				// Directly call the IMOV method on the HP3JC interface, passing the subordinate output cartesian configuration as an argument.
				mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
				memcpy(mysa->pvData,d_AverageOutputCart,sizeof(double)*NUM_AXES);
				pIVSSubOutput->SetCurrentVector(mysa);
				SafeArrayDestroy(mysa);
				pIVSSubOutput->Release();		
		}
		/********************************************************************************************************************/

		// Output to averaged data to the Dominant's controller output vector: 
		m_Bindings->get_Pointers(SysAllocString(L"DomCont_Output"), &m_pIUnkDomCont_Output);
		if(m_pIUnkDomCont_Output == NULL)	return !S_OK;

		m_pIUnkDomCont_Output->QueryInterface(IID_IVectorSignal, (void **)&pIVSDomOutput);
		if(pIVSDomOutput == NULL)	return !S_OK;

		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		memcpy(mysa->pvData,m_dAveragedOutput,sizeof(double)*NUM_AXES);
		pIVSDomOutput->SetCurrentVector(mysa);
		SafeArrayDestroy(mysa);
		pIVSDomOutput->Release();
		
	}

	// Analyze if controller should sequence to next controller
	// If the cumulative error of the first controller is low, it will be ready to move on to the next controller
	CheckError();

	return S_OK;
}

/************************************************************************
**************************  Member Functions  ***************************
************************************************************************/

/****************************************************
* Set_Gains()
* Sets the gains for the pertinent robot
****************************************************/
void CControlBasis::SetGains()
{
	if(m_sWhatRobot == ISAC_ROBOT)
	{
		m_dPositionGain[0] = 0.2;		m_dForceGain[0] = 0.2;	m_dMomentGain[0] = 0;	
		m_dPositionGain[1] = 0.2;		m_dForceGain[1] = 0.2;	m_dMomentGain[1] = 0;	
		m_dPositionGain[2] = 0.2;		m_dForceGain[2] = 0.2;	m_dMomentGain[2] = 0;	
		m_dPositionGain[3] = 0.2;		m_dForceGain[3] = 0;	m_dMomentGain[3] = 0.2;	
		m_dPositionGain[4] = 0.2;		m_dForceGain[4] = 0;	m_dMomentGain[4] = 0.2;	
		m_dPositionGain[5] = 0.2;		m_dForceGain[5] = 0;	m_dMomentGain[5] = 0.2;	
	}

	if(m_sWhatRobot == HP3JC_ROBOT)
	{				
		m_dPositionGain[0] = 0.0000425;		m_dIKinGain[0] = 0.50;		m_dForceGain[0] = 0.0001;/*001*/m_dMomentGain[0] =  0; 	
		m_dPositionGain[1] = 0.00002;		m_dIKinGain[1] = 0.50;		m_dForceGain[1] = 0.001;		m_dMomentGain[1] =  0; 	
		m_dPositionGain[2] = 0.00002;		m_dIKinGain[2] = 0.50;		m_dForceGain[2] = 0.00025;		m_dMomentGain[2] =  0; 	
		m_dPositionGain[3] = 0.00056;		m_dIKinGain[3] = 0.50;		m_dForceGain[3] = 0;			m_dMomentGain[3] =  0.05;					// 0.01 //  0.200; 	
		m_dPositionGain[4] = 0.00056;		m_dIKinGain[4] = 0.50;		m_dForceGain[4] = 0;			m_dMomentGain[4] = -0.025;		   //-0.05; //-0.01 //  0.200; 	
		m_dPositionGain[5] = 0.00056;		m_dIKinGain[5] = 0.50;		m_dForceGain[5] = 0;			m_dMomentGain[5] =  0.01; // 0.025 // 0.05; // 0.01 //  0.200; 	

		m_dCartesianGain[0] = 0.2;	// 0.05;
		m_dCartesianGain[1] = 0.2;	// It's more stable for side motions. //0.05;
		m_dCartesianGain[2] = 0.2;	// 0.05;
		m_dCartesianGain[3] = 0.2;	// 0.05;
		m_dCartesianGain[4] = 0.2;	// 0.05;
		m_dCartesianGain[5] = 0.2;	// 0.05;
	}

	// POSITION/FORCE
	if(m_sWhatRobot == HP3JC_ROBOT && m_sWhichIsDomController == DOMINANT_POSITION_CONTROLLER && m_sWhichIsSubController == SUBORDINATE_FORCE_CONTROLLER)
	{
		m_dForceGain[0] = m_dPositionGain[0];
		m_dForceGain[1] = m_dPositionGain[1];
		m_dForceGain[2] = m_dPositionGain[2];
	}

}

/****************************************************
* Set_Jacobians()
* Sets the Jacobian for the pertinent robot and for 
* the pertinent controller. This function requires us to
* obtain the current joint angles of the robot. 
*
* The derivation and programming of the Jacobian was done
* by modifying the Jacobian file from DiProdi's Matlab 
* Robotic Toolkit. The derivation was done for both ISAC
* and the HP3JC robot. Some manipulation was done to then
* run this Jacobian through Mathematica and simplify it further.
* The form in Mathematica was copied over to C++.
* 
* The Matlab and Mathematica file can be found at: 
* O:\Components\ArmComponents\MatlabFiles
*
* Note!! 
* The Jacobian used here is the TRANSFORM of the original 
* matrix. The transform of the Jacobian is used in all
* controllers.
*
* This function also defines the Jacobian differently
* according to what controller is selected. The reasoning
* is related to the fact that we are separating the force
* and moment components. We have two vectors and two 
* controllers to deal with these elements separately.
*
* When using the force controller we have to zero-out
* the elements multiplied with moment components. In
* essence we will keep the first 3 cols of the Jacobian
* and we will zero out the right 3 cols. The opposite is true
* if we are using the moment controller.
*
* For the POSITION controller the full Jacobian is used.
* For the new IKin controller Jacobian is not used.
* No additional code is necessary. All steps will be skipped for this controller.
****************************************************/
HRESULT CControlBasis::ComputeJacobian(short TypeOfController)
{
	// Local Variables
/*	SAFEARRAY		*mysa;
	IVectorSignal	*pIVSAngle;

	// 1) Get pointers to object and interface of Angle and fill Angle vector.
	m_Bindings->get_Pointers(SysAllocString(L"ActualAngle"), &m_pIUnkAngle);
	if(m_pIUnkAngle == NULL) return !S_OK;
	m_pIUnkAngle->QueryInterface(IID_IVectorSignal, (void**)&pIVSAngle);
	if(pIVSAngle == NULL)	return !S_OK;

	// Copy data to Angle member variable. Used when executing the Jacobian.
	mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
	pIVSAngle->GetCurrentVector(mysa);
	memcpy(Angle,mysa->pvData,sizeof(double)*NUM_AXES);
	SafeArrayDestroy(mysa);
	m_pIUnkAngle->Release();
*/
	// There are problems loading the home position through the VS2Files component. 
	// So we are doing it here directly.
	if(m_bHomePositionFlag)
	{
		WriteJointAngleHomePosition();
		m_bHomePositionFlag = false;
	}

	// Convert angles to radians 
	for(int i=0; i<NUM_AXES;i++)
		Angle[i] = Angle[i] * 3.141592/180;


	// 2) Determine which robot is active
	if(m_sWhatRobot == ISAC_ROBOT)
	{

	// 3) Determine the type of controller used:
	//  ** POSITION CONTROLLER  ** 
	// If using the position controller arrange for the full jacobian
	if(TypeOfController == DOMINANT_POSITION_CONTROLLER || TypeOfController == SUBORDINATE_POSITION_CONTROLLER)
		{
			// 1st row
			J11 = 10 * (cos(Angle[2]) * cos(Angle[5]) * sin(Angle[3]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2])) - 20 * ( cos(Angle[1] + Angle[2]) * sin(Angle[3]) * sin(Angle[5]) + cos(Angle[5]) * sin(Angle[4]) * sin( Angle[1] + Angle[2])) + cos(Angle[3]) * (20 * cos(Angle[4]) * cos(Angle[5]) * cos(Angle[1] + Angle[2]) + sin(Angle[5]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2]))));
			J12 = -10 * (20 * cos(Angle[5]) * cos(Angle[1] + Angle[2]) * sin(Angle[3]) + cos(Angle[3]) * (20 * cos(Angle[4]) * cos(Angle[1] + Angle[2]) * sin(Angle[5]) + cos(Angle[5]) * (33 * cos(Angle[1]) - 29 * sin(Angle[1] + Angle[2]))) + sin(Angle[5]) * (-20 * sin(Angle[4]) * sin(Angle[1] + Angle[2]) + cos(Angle[4]) * sin(Angle[3]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2]))));
			J13 = 10 * (20 * cos(Angle[3]) * cos(Angle[1] - Angle[2]) * sin(Angle[4]) - cos(Angle[2]) * (20 * cos(Angle[4]) + 29 * sin(Angle[3]) * sin(Angle[4])) * sin(Angle[1]) + cos(Angle[1]) * (sin(Angle[3]) * sin(Angle[4]) * (33 - 29 * sin(Angle[2])) - 20 * cos(Angle[4]) * sin(Angle[2])));
			J14 = sin(Angle[3]) * sin(Angle[5]) * sin(Angle[1] + Angle[2]) - cos(Angle[5]) * (cos(Angle[1] + Angle[2]) * sin(Angle[4]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[1] + Angle[2]));
			J15 = cos(Angle[1] + Angle[2]) * sin(Angle[4]) * sin(Angle[5]) + ( cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[5]) ) * sin( Angle[1] + Angle[2] );
			J16 = -cos(Angle[4]) * cos( Angle[1] + Angle[2] ) + cos(Angle[3]) * sin(Angle[4]) * sin( Angle[1] + Angle[2] );
			
			// 2nd row
			J21 = 10 * ( cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2])) - 20 * (cos(Angle[1] + Angle[2]) * sin(Angle[3]) * sin(Angle[5]) + cos(Angle[5]) * sin(Angle[4]) * sin(Angle[1] + Angle[2])) + cos(Angle[3]) * (20 * cos(Angle[4]) * cos(Angle[5]) * cos(Angle[1] + Angle[2]) + sin(Angle[5]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2]))));
			J22 = -10 * (20 * cos(Angle[5]) * cos(Angle[1] + Angle[2]) * sin(Angle[3]) + cos(Angle[3]) * (20 * cos(Angle[4]) * cos(Angle[1] + Angle[2]) * sin(Angle[5]) + cos(Angle[5]) * (33 * cos(Angle[1]) - 29 * sin(Angle[1] + Angle[2]))) + sin(Angle[5]) * (-20 * sin(Angle[4]) * sin(Angle[1] + Angle[2]) + cos(Angle[4]) * sin(Angle[3]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2]))));
			J23 = 5 * (-49 * cos(Angle[3] - Angle[1] - Angle[2]) + 9 * cos(Angle[3] + Angle[1] + Angle[2]) + 66 * cos(Angle[1]) * sin(Angle[3])) * sin(Angle[4]) - 200 * cos(Angle[4]) * sin(Angle[1] + Angle[2]);
			J24 = sin(Angle[3]) * sin(Angle[5]) * sin(Angle[1] + Angle[2]) - cos(Angle[5]) * (cos(Angle[1] + Angle[2]) * sin(Angle[4]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[1] + Angle[2]));
			J25 = cos(Angle[1] + Angle[2]) * sin(Angle[4]) * sin(Angle[5]) + (cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[5])) * sin(Angle[1] + Angle[2]);
			J26 = -cos(Angle[4]) * cos(Angle[1] + Angle[2]) + cos(Angle[3]) * sin(Angle[4]) * sin(Angle[1] + Angle[2]);
			
			// 3rd row
			J31 = 10 * (33 * cos(Angle[5]) * cos(Angle[2]) * sin(Angle[4]) + sin(Angle[3]) * sin(Angle[5]) * (29 - 33 * sin(Angle[2])) + cos(Angle[3]) * cos(Angle[4]) * cos(Angle[5]) * (-29 + 33 * sin(Angle[2])));
			J32 = -10 * (cos(Angle[5]) * sin(Angle[3]) * (-29 + 33 * sin(Angle[2])) + sin(Angle[5]) * (33 * cos(Angle[2]) * sin(Angle[4]) + cos(Angle[3]) * cos(Angle[4]) * (-29 + 33 * sin(Angle[2]))));
			J33 = 10 * (33 * cos(Angle[4]) * cos(Angle[2]) + cos(Angle[3]) * sin(Angle[4]) * (29 - 33 * sin(Angle[2])));
			J34 = -cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) - cos(Angle[3]) * sin(Angle[5]);
			J35 = -cos(Angle[3]) * cos(Angle[5]) + cos(Angle[4]) * sin(Angle[3]) * sin(Angle[5]);
			J36 = sin(Angle[3]) * sin(Angle[4]);
			
			// 4th row
			J41 = 290 * (-cos(Angle[3]) * cos(Angle[4]) * cos(Angle[5]) + sin(Angle[3]) * sin(Angle[5]));
			J42 = 290 * (cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[5]));
			J43 = 290 * cos(Angle[3]) * sin(Angle[4]);
			J44 = -cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) - cos(Angle[3]) * sin(Angle[5]);
			J45 = -cos(Angle[3]) * cos(Angle[5]) + cos(Angle[4]) * sin(Angle[3]) * sin(Angle[5]);
			J46 = sin(Angle[3]) * sin(Angle[4]);
			
			// 5th row
			J51 = 0.0;
			J52 = 0.0;
			J53 = 0.0;
			J54 = cos(Angle[5]) * sin(Angle[4]);
			J55 = -sin(Angle[4]) * sin(Angle[5]);
			J56 = cos(Angle[4]);
			
			// 6th row
			J61 = 0.0;
			J62 = 0.0;
			J63 = 0.0;
			J64 = -sin(Angle[5]);
			J65 = -cos(Angle[5]);
			J66 = 0.0;

		}

		// ** FORCE CONTROLLER** 
		// Fill left half
		if(TypeOfController == DOMINANT_FORCE_CONTROLLER || TypeOfController == SUBORDINATE_FORCE_CONTROLLER) 
		{
			// 1st row
			J11 = 10 * (cos(Angle[2]) * cos(Angle[5]) * sin(Angle[3]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2])) - 20 * ( cos(Angle[1] + Angle[2]) * sin(Angle[3]) * sin(Angle[5]) + cos(Angle[5]) * sin(Angle[4]) * sin( Angle[1] + Angle[2])) + cos(Angle[3]) * (20 * cos(Angle[4]) * cos(Angle[5]) * cos(Angle[1] + Angle[2]) + sin(Angle[5]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2]))));
			J12 = -10 * (20 * cos(Angle[5]) * cos(Angle[1] + Angle[2]) * sin(Angle[3]) + cos(Angle[3]) * (20 * cos(Angle[4]) * cos(Angle[1] + Angle[2]) * sin(Angle[5]) + cos(Angle[5]) * (33 * cos(Angle[1]) - 29 * sin(Angle[1] + Angle[2]))) + sin(Angle[5]) * (-20 * sin(Angle[4]) * sin(Angle[1] + Angle[2]) + cos(Angle[4]) * sin(Angle[3]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2]))));
			J13 = 10 * (20 * cos(Angle[3]) * cos(Angle[1] - Angle[2]) * sin(Angle[4]) - cos(Angle[2]) * (20 * cos(Angle[4]) + 29 * sin(Angle[3]) * sin(Angle[4])) * sin(Angle[1]) + cos(Angle[1]) * (sin(Angle[3]) * sin(Angle[4]) * (33 - 29 * sin(Angle[2])) - 20 * cos(Angle[4]) * sin(Angle[2])));

			// 2nd row
			J21 = 10 * ( cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2])) - 20 * (cos(Angle[1] + Angle[2]) * sin(Angle[3]) * sin(Angle[5]) + cos(Angle[5]) * sin(Angle[4]) * sin(Angle[1] + Angle[2])) + cos(Angle[3]) * (20 * cos(Angle[4]) * cos(Angle[5]) * cos(Angle[1] + Angle[2]) + sin(Angle[5]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2]))));
			J22 = -10 * (20 * cos(Angle[5]) * cos(Angle[1] + Angle[2]) * sin(Angle[3]) + cos(Angle[3]) * (20 * cos(Angle[4]) * cos(Angle[1] + Angle[2]) * sin(Angle[5]) + cos(Angle[5]) * (33 * cos(Angle[1]) - 29 * sin(Angle[1] + Angle[2]))) + sin(Angle[5]) * (-20 * sin(Angle[4]) * sin(Angle[1] + Angle[2]) + cos(Angle[4]) * sin(Angle[3]) * (-33 * cos(Angle[1]) + 29 * sin(Angle[1] + Angle[2]))));
			J23 = 5 * (-49 * cos(Angle[3] - Angle[1] - Angle[2]) + 9 * cos(Angle[3] + Angle[1] + Angle[2]) + 66 * cos(Angle[1]) * sin(Angle[3])) * sin(Angle[4]) - 200 * cos(Angle[4]) * sin(Angle[1] + Angle[2]);

			// 3rd row
			J31 = 10 * (33 * cos(Angle[5]) * cos(Angle[2]) * sin(Angle[4]) + sin(Angle[3]) * sin(Angle[5]) * (29 - 33 * sin(Angle[2])) + cos(Angle[3]) * cos(Angle[4]) * cos(Angle[5]) * (-29 + 33 * sin(Angle[2])));
			J32 = -10 * (cos(Angle[5]) * sin(Angle[3]) * (-29 + 33 * sin(Angle[2])) + sin(Angle[5]) * (33 * cos(Angle[2]) * sin(Angle[4]) + cos(Angle[3]) * cos(Angle[4]) * (-29 + 33 * sin(Angle[2]))));
			J33 = 10 * (33 * cos(Angle[4]) * cos(Angle[2]) + cos(Angle[3]) * sin(Angle[4]) * (29 - 33 * sin(Angle[2])));

			// 4th row
			J41 = 290 * (-cos(Angle[3]) * cos(Angle[4]) * cos(Angle[5]) + sin(Angle[3]) * sin(Angle[5]));
			J42 = 290 * (cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[5]));
			J43 = 290 * cos(Angle[3]) * sin(Angle[4]);

			// 5th row
			J51 = 0.0;
			J52 = 0.0;
			J53 = 0.0;

			// 6th row
			J61 = 0.0;
			J62 = 0.0;
			J63 = 0.0;

			// Set the right side of the Jacobian transform to zero. 
			J14 = J15 = J16 = 0.0;
			J24 = J25 = J26 = 0.0;
			J34 = J35 = J36 = 0.0;
			J44 = J45 = J46 = 0.0;
			J54 = J55 = J56 = 0.0;
			J64 = J65 = J66 = 0.0;

		}
		
		//  ** MOMENT CONTROLLER  ** 
		// Fill right half. 
		if(TypeOfController == DOMINANT_MOMENT_CONTROLLER || TypeOfController == SUBORDINATE_MOMENT_CONTROLLER) 
		{
			// Set the left side of the Jacobian transform to zero. 
			J11 = J12 = J13 = 0.0;
			J21 = J22 = J23 = 0.0;
			J31 = J32 = J33 = 0.0;
			J41 = J42 = J43 = 0.0;
			J51 = J52 = J53 = 0.0;
			J61 = J62 = J63 = 0.0;

			// 1st row
			J14 = sin(Angle[3]) * sin(Angle[5]) * sin(Angle[1] + Angle[2]) - cos(Angle[5]) * (cos(Angle[1] + Angle[2]) * sin(Angle[4]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[1] + Angle[2]));
			J15 = cos(Angle[1] + Angle[2]) * sin(Angle[4]) * sin(Angle[5]) + ( cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[5]) ) * sin( Angle[1] + Angle[2] );
			J16 = -cos(Angle[4]) * cos( Angle[1] + Angle[2] ) + cos(Angle[3]) * sin(Angle[4]) * sin( Angle[1] + Angle[2] );

			// 2nd row
			J24 = sin(Angle[3]) * sin(Angle[5]) * sin(Angle[1] + Angle[2]) - cos(Angle[5]) * (cos(Angle[1] + Angle[2]) * sin(Angle[4]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[1] + Angle[2]));
			J25 = cos(Angle[1] + Angle[2]) * sin(Angle[4]) * sin(Angle[5]) + (cos(Angle[5]) * sin(Angle[3]) + cos(Angle[3]) * cos(Angle[4]) * sin(Angle[5])) * sin(Angle[1] + Angle[2]);
			J26 = -cos(Angle[4]) * cos(Angle[1] + Angle[2]) + cos(Angle[3]) * sin(Angle[4]) * sin(Angle[1] + Angle[2]);

			// 3rd row
			J34 = -cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) - cos(Angle[3]) * sin(Angle[5]);
			J35 = -cos(Angle[3]) * cos(Angle[5]) + cos(Angle[4]) * sin(Angle[3]) * sin(Angle[5]);
			J36 = sin(Angle[3]) * sin(Angle[4]);

			// 4th row
			J44 = -cos(Angle[4]) * cos(Angle[5]) * sin(Angle[3]) - cos(Angle[3]) * sin(Angle[5]);
			J45 = -cos(Angle[3]) * cos(Angle[5]) + cos(Angle[4]) * sin(Angle[3]) * sin(Angle[5]);
			J46 = sin(Angle[3]) * sin(Angle[4]);

			// 5th row
			J54 = cos(Angle[5]) * sin(Angle[4]);
			J55 = -sin(Angle[4]) * sin(Angle[5]);
			J56 = cos(Angle[4]);

			// 6th row
			J64 = -sin(Angle[5]);
			J65 = -cos(Angle[5]);
			J66 = 0.0;

		}
	}



	// HP3JC ROBOT
	if(m_sWhatRobot == HP3JC_ROBOT)
	{
		// If using the position controller arrange for the full jacobian
		if(TypeOfController == DOMINANT_POSITION_CONTROLLER || TypeOfController == SUBORDINATE_POSITION_CONTROLLER)
		{
			J11 = (3*sin(Angle[0])*sin(Angle[1])*(cos(Angle[2])*(180 + 163*cos(Angle[4])) - 20*sin(Angle[2])) - 489*(cos(Angle[3])*sin(Angle[0])*sin(Angle[1])*sin(Angle[2]) + cos(Angle[0])*sin(Angle[3]))*sin(Angle[4]) - cos(Angle[1])*sin(Angle[0])*(520 + (540 + 489*cos(Angle[4]))*sin(Angle[2]) + cos(Angle[2])*(60 + 489*cos(Angle[3])*sin(Angle[4]))))/2;
			J12 = (-489*sin(Angle[0])*sin(Angle[3])*sin(Angle[4]) + cos(Angle[0])*(3*sin(Angle[1])*(-(cos(Angle[2])*(180 + 163*cos(Angle[4]))) + sin(Angle[2])*(20 + 163*cos(Angle[3])*sin(Angle[4]))) + cos(Angle[1])*(520 + (540 + 489*cos(Angle[4]))*sin(Angle[2]) + cos(Angle[2])*(60 + 489*cos(Angle[3])*sin(Angle[4])))))/2;
			J13 = 0;
			J14 = 0;
			J15 = 0;
			J16 = 1;

			// 2nd row of transform matrix, J'
			J21 = -(cos(Angle[0])*(cos(Angle[1])*(cos(Angle[2])*(540 + 489*cos(Angle[4])) - 3*sin(Angle[2])*(20 + 163*cos(Angle[3])*sin(Angle[4]))) + sin(Angle[1])*(520 + (540 + 489*cos(Angle[4]))*sin(Angle[2]) + cos(Angle[2])*(60 + 489*cos(Angle[3])*sin(Angle[4])))))/2;
			J22 =  -(sin(Angle[0])*(cos(Angle[1])*(cos(Angle[2])*(540 + 489*cos(Angle[4])) - 3*sin(Angle[2])*(20 + 163*cos(Angle[3])*sin(Angle[4]))) + sin(Angle[1])*(520 + (540 + 489*cos(Angle[4]))*sin(Angle[2]) + cos(Angle[2])*(60 + 489*cos(Angle[3])*sin(Angle[4])))))/2;
			J23 = (-520*cos(Angle[1]) + 3*(180 + 163*cos(Angle[4]))*sin(Angle[1] - Angle[2]) - 3*cos(Angle[1] - Angle[2])*(20 + 163*cos(Angle[3])*sin(Angle[4])))/2;
			J24 = -sin(Angle[0]);
			J25 = -sin(Angle[0]);
			J26 = 0;

			// 3rd row of transform matrix, J'
			J31 = (3*cos(Angle[0])*(360*cos(Angle[1] - Angle[2]) + 163*cos(Angle[1] - Angle[2] - Angle[4]) + 163*cos(Angle[1] - Angle[2] + Angle[4]) + 2*sin(Angle[1] - Angle[2])*(20 + 163*cos(Angle[3])*sin(Angle[4]))))/4;
			J32 = (3*sin(Angle[0])*(360*cos(Angle[1] - Angle[2]) + 163*cos(Angle[1] - Angle[2] - Angle[4]) + 163*cos(Angle[1] - Angle[2] + Angle[4]) + 2*sin(Angle[1] - Angle[2])*(20 + 163*cos(Angle[3])*sin(Angle[4]))))/4;
			J33 = (3*(-((180 + 163*cos(Angle[4]))*sin(Angle[1] - Angle[2])) + cos(Angle[1] - Angle[2])*(20 + 163*cos(Angle[3])*sin(Angle[4]))))/2;
			J34 = sin(Angle[0]);
			J35 = sin(Angle[0]);
			J36 = 0;

			// 4th row of transform matrix, J'
			J41 = (-489*(cos(Angle[3])*sin(Angle[0]) + cos(Angle[0])*cos(Angle[1] - Angle[2])*sin(Angle[3]))*sin(Angle[4]))/2;
			J42 = (489*(cos(Angle[0])*cos(Angle[3]) - cos(Angle[1] - Angle[2])*sin(Angle[0])*sin(Angle[3]))*sin(Angle[4]))/2;
			J43 = (489*sin(Angle[1] - Angle[2])*sin(Angle[3])*sin(Angle[4]))/2;
			J44 = cos(Angle[0])*sin(Angle[1] - Angle[2]);
			J45 = cos(Angle[0])*sin(Angle[1] - Angle[2]);
			J46 = cos(Angle[1] - Angle[2]);

			// 5th row of transform matrix, J'
			J51 = (489*(-(cos(Angle[4])*sin(Angle[0])*sin(Angle[3])) + cos(Angle[0])*(cos(Angle[1] - Angle[2])*cos(Angle[3])*cos(Angle[4]) + sin(Angle[1] - Angle[2])*sin(Angle[4]))))/2;
			J52 = (489*(cos(Angle[1] - Angle[2])*cos(Angle[3])*cos(Angle[4])*sin(Angle[0]) + cos(Angle[0])*cos(Angle[4])*sin(Angle[3]) + sin(Angle[0])*sin(Angle[1] - Angle[2])*sin(Angle[4])))/2;
			J53 = (489*(cos(Angle[2])*(-(cos(Angle[3])*cos(Angle[4])*sin(Angle[1])) + cos(Angle[1])*sin(Angle[4])) + sin(Angle[2])*(cos(Angle[1])*cos(Angle[3])*cos(Angle[4]) + sin(Angle[1])*sin(Angle[4]))))/2;
			J54 = cos(Angle[3])*sin(Angle[0]) + cos(Angle[0])*cos(Angle[1] - Angle[2])*sin(Angle[3]);
			J55 = cos(Angle[3])*sin(Angle[0]) + cos(Angle[0])*cos(Angle[1] - Angle[2])*sin(Angle[3]);
			J56 = -(sin(Angle[1] - Angle[2])*sin(Angle[3]));

			// 6th row of transform matrix, J'
			J61 = 0;
			J62 = 0;
			J63 = 0;
			J64 = sin(Angle[0])*sin(Angle[3])*sin(Angle[4]) + cos(Angle[0])*(cos(Angle[4])*sin(Angle[1] - Angle[2]) - cos(Angle[1] - Angle[2])*cos(Angle[3])*sin(Angle[4]));
			J65 = sin(Angle[0])*sin(Angle[3])*sin(Angle[4]) + cos(Angle[0])*(cos(Angle[4])*sin(Angle[1] - Angle[2]) - cos(Angle[1] - Angle[2])*cos(Angle[3])*sin(Angle[4]));
			J66 = cos(Angle[1] - Angle[2])*cos(Angle[4]) + cos(Angle[3])*sin(Angle[1] - Angle[2])*sin(Angle[4]);

		}

		// Force Controller
		if(TypeOfController == DOMINANT_FORCE_CONTROLLER || TypeOfController == SUBORDINATE_FORCE_CONTROLLER) 
		{
			J11 = (3*sin(Angle[0])*sin(Angle[1])*(cos(Angle[2])*(180 + 163*cos(Angle[4])) - 20*sin(Angle[2])) - 489*(cos(Angle[3])*sin(Angle[0])*sin(Angle[1])*sin(Angle[2]) + cos(Angle[0])*sin(Angle[3]))*sin(Angle[4]) - cos(Angle[1])*sin(Angle[0])*(520 + (540 + 489*cos(Angle[4]))*sin(Angle[2]) + cos(Angle[2])*(60 + 489*cos(Angle[3])*sin(Angle[4]))))/2;
			J12 = (-489*sin(Angle[0])*sin(Angle[3])*sin(Angle[4]) + cos(Angle[0])*(3*sin(Angle[1])*(-(cos(Angle[2])*(180 + 163*cos(Angle[4]))) + sin(Angle[2])*(20 + 163*cos(Angle[3])*sin(Angle[4]))) + cos(Angle[1])*(520 + (540 + 489*cos(Angle[4]))*sin(Angle[2]) + cos(Angle[2])*(60 + 489*cos(Angle[3])*sin(Angle[4])))))/2;
			J13 = 0;

			// 2nd row of transform matrix, J'
			J21 = -(cos(Angle[0])*(cos(Angle[1])*(cos(Angle[2])*(540 + 489*cos(Angle[4])) - 3*sin(Angle[2])*(20 + 163*cos(Angle[3])*sin(Angle[4]))) + sin(Angle[1])*(520 + (540 + 489*cos(Angle[4]))*sin(Angle[2]) + cos(Angle[2])*(60 + 489*cos(Angle[3])*sin(Angle[4])))))/2;
			J22 = 0.0; // This should be zero given that a push from the side should not change q2 // -(sin(Angle[0])*(cos(Angle[1])*(cos(Angle[2])*(540 + 489*cos(Angle[4])) - 3*sin(Angle[2])*(20 + 163*cos(Angle[3])*sin(Angle[4]))) + sin(Angle[1])*(520 + (540 + 489*cos(Angle[4]))*sin(Angle[2]) + cos(Angle[2])*(60 + 489*cos(Angle[3])*sin(Angle[4])))))/2;
			J23 = (-520*cos(Angle[1]) + 3*(180 + 163*cos(Angle[4]))*sin(Angle[1] - Angle[2]) - 3*cos(Angle[1] - Angle[2])*(20 + 163*cos(Angle[3])*sin(Angle[4])))/2;

			// 3rd row of transform matrix, J'
			J31 = (3*cos(Angle[0])*(360*cos(Angle[1] - Angle[2]) + 163*cos(Angle[1] - Angle[2] - Angle[4]) + 163*cos(Angle[1] - Angle[2] + Angle[4]) + 2*sin(Angle[1] - Angle[2])*(20 + 163*cos(Angle[3])*sin(Angle[4]))))/4;
			J32 = 0.0; // This should be zero given that a push from the side should not change q3 // (3*sin(Angle[0])*(360*cos(Angle[1] - Angle[2]) + 163*cos(Angle[1] - Angle[2] - Angle[4]) + 163*cos(Angle[1] - Angle[2] + Angle[4]) + 2*sin(Angle[1] - Angle[2])*(20 + 163*cos(Angle[3])*sin(Angle[4]))))/4;
			J33 = (3*(-((180 + 163*cos(Angle[4]))*sin(Angle[1] - Angle[2])) + cos(Angle[1] - Angle[2])*(20 + 163*cos(Angle[3])*sin(Angle[4]))))/2;

			// 4th row of transform matrix, J'
			J41 = 0;//(-489*(cos(Angle[3])*sin(Angle[0]) + cos(Angle[0])*cos(Angle[1] - Angle[2])*sin(Angle[3]))*sin(Angle[4]))/2;
			J42 = 0;//(489*(cos(Angle[0])*cos(Angle[3]) - cos(Angle[1] - Angle[2])*sin(Angle[0])*sin(Angle[3]))*sin(Angle[4]))/2;
			J43 = 0;//(489*sin(Angle[1] - Angle[2])*sin(Angle[3])*sin(Angle[4]))/2;

			// 5th row of transform matrix, J'
			J51 = 0;//(489*(-(cos(Angle[4])*sin(Angle[0])*sin(Angle[3])) + cos(Angle[0])*(cos(Angle[1] - Angle[2])*cos(Angle[3])*cos(Angle[4]) + sin(Angle[1] - Angle[2])*sin(Angle[4]))))/2;
			J52 = 0;//(489*(cos(Angle[1] - Angle[2])*cos(Angle[3])*cos(Angle[4])*sin(Angle[0]) + cos(Angle[0])*cos(Angle[4])*sin(Angle[3]) + sin(Angle[0])*sin(Angle[1] - Angle[2])*sin(Angle[4])))/2;
			J53 = 0;//(489*(cos(Angle[2])*(-(cos(Angle[3])*cos(Angle[4])*sin(Angle[1])) + cos(Angle[1])*sin(Angle[4])) + sin(Angle[2])*(cos(Angle[1])*cos(Angle[3])*cos(Angle[4]) + sin(Angle[1])*sin(Angle[4]))))/2;

			// 6th row of transform matrix, J'
			J61 = 0;
			J62 = 0;
			J63 = 0;

			// Set the right side of the Jacobian transform to zero. 
			J14 = J15 = J16 = 0.0;
			J24 = J25 = J26 = 0.0;
			J34 = J35 = J36 = 0.0;
			J44 = J45 = J46 = 0.0;
			J54 = J55 = J56 = 0.0;
			J64 = J65 = J66 = 0.0;
		}
		
		// Moment Controller
		if(TypeOfController == DOMINANT_MOMENT_CONTROLLER || TypeOfController == SUBORDINATE_MOMENT_CONTROLLER) 
		{
			// Set the left side of the Jacobian transform to zero. 
			J11 = J12 = J13 = 0.0;
			J21 = J22 = J23 = 0.0;
			J31 = J32 = J33 = 0.0;
			J41 = J42 = J43 = 0.0;
			J51 = J52 = J53 = 0.0;
			J61 = J62 = J63 = 0.0;

			// You will see some equations commented below.
			// After some testing it seemed like the latest jacobian i computed did 
			// not produce the right motion for when a moment about y is generated. 
			// Ie instead of having the robot wrist move up/down it moved side to side.

			// Adapt the base/lateral motion if we have a dominant force controller and a subordinate moment controller
			if(m_sWhichIsDomController == DOMINANT_FORCE_CONTROLLER)
			{
				J14 = 0;
				J15 = 0;
				J16 = 0;//1;		// This last value produces a rotation about "S" - a lateral motion. We do not desire this behavior for the moment controller. The force controller is the one that moves "S".
			}

			else
			{
				J14 = 0;
				J15 = 0;
				J16 = 1;				// If the moment controller is the only one working, then we desire lateral motion. Ideally this should happen in the wrist but so far we have only been able to move latteraly by the "S" joint.
			}

			// 2nd row of transform matrix, J'
			J24 = 0;//-sin(Angle[0]);//sin(Angle[0]);
			J25 = 0;//cos(Angle[0]);//-sin(Angle[0]);
			J26 = 0;

			// 3rd row of transform matrix, J'
			J34 = 0;//sin(Angle[0]);//sin(Angle[0]);
			J35 = 0;//-cos(Angle[0]);//-sin(Angle[0]);
			J36 = 0;

			// 4th row of transform matrix, J'
			J44 = cos(Angle[0])*sin(Angle[1] - Angle[2]);
			J45 = sin(Angle[0])*sin(Angle[1] - Angle[2]);//cos(Angle[0])*sin(Angle[1] - Angle[2]);
			J46 = cos(Angle[1] - Angle[2]);

			// 5th row of transform matrix, J'
			J54 = cos(Angle[3])*sin(Angle[0]) + cos(Angle[0])*cos(Angle[1] - Angle[2])*sin(Angle[3]);
			J55 = -(cos(Angle[0])*cos(Angle[3])) + cos(Angle[1] - Angle[2])*sin(Angle[0])*sin(Angle[3]);//cos(Angle[3])*sin(Angle[0]) + cos(Angle[0])*cos(Angle[1] - Angle[2])*sin(Angle[3]);
			J56 = -(sin(Angle[1] - Angle[2])*sin(Angle[3]));

			// 6th row of transform matrix, J'
			J64 = 0;//sin(Angle[0])*sin(Angle[3])*sin(Angle[4]) + cos(Angle[0])*(cos(Angle[4])*sin(Angle[1] - Angle[2]) - cos(Angle[1] - Angle[2])*cos(Angle[3])*sin(Angle[4]));
			J65 = 0;//cos(Angle[4])*sin(Angle[0])*sin(Angle[1] - Angle[2]) - (cos(Angle[1] - Angle[2])*cos(Angle[3])*sin(Angle[0]) + cos(Angle[0])*sin(Angle[3]))*sin(Angle[4]);//sin(Angle[0])*sin(Angle[3])*sin(Angle[4]) + cos(Angle[0])*(cos(Angle[4])*sin(Angle[1] - Angle[2]) - cos(Angle[1] - Angle[2])*cos(Angle[3])*sin(Angle[4]));
			J66 = 0;//cos(Angle[1] - Angle[2])*cos(Angle[4]) + cos(Angle[3])*sin(Angle[1] - Angle[2])*sin(Angle[4]);
		}

	}

	// Convert Angle from radians back to degrees
	for(i=0; i<NUM_AXES;i++)
		Angle[i] = Angle[i] * 180/3.141592;

	return S_OK;
}



/****************************************************
* ComputeControllerOutput()
* 1) Determine if we have a dominant or subordinate controller
* 2) Determine if we have a position, force or moment controller.
*    Force elements are the first 3 from desired vector, moment 
*    elements are the last 3 from the desired vector. In both
*    cases we copy over to our private member variable.
* 3) Calculate the product between the error and the gain
* 4) Call JacobianProduct to compute the product from the 
*    prior result and the Jacobian. The result is stored in the
*    output vector.
*
*
** UPDATES
** Sept 2008 - Created a call for Inverse Kinematics for the HP3JC b/c the Jacobian Position Controller
**			   was too unstable and very slow.
**			   This controller does not require for us to multiply the (error*gain) x a jacobian matrix.
**
** Jan 2009	 - After several attempts at debugging, I was unable to fix a small but critical error produced in 
**			   the generation of the angle for the third joint. This forces me to move to a Cartesian controller 
**			   embedded in the HP3JC controller. 
**			   This move is not optimal but it seems the only feasible way of moving the robot. It's not optimal since
**			   now both controllers are not configured in the same space. The Cartesian controller will send a motion
**			   independent of the joint angle motion. 
**			   * METHOD CALL:
**			   The result generated by the TempBuffer (error*gain), will be copied to a member variable m_dIMOV. This result will be copied
**			   to the VS: DesiredXYZRPY. Then the state machine will be modified to also call the HP3JC call: move_Incremental() at the end. 
**			   In this way, the State Machine will call move_JointAngles() and immediately after that it will call move_Incremental(), hopefully
**			   minimizing as much as possible the damage caused by this structural change.
**
**			   * PROJECTION:
**			   We don't have to worry about the projection since the DomContOutput[] will all be zero's. So the projection of the subordinate controller
**			   unto the dominant controller will be without change and later on passed to the 
****************************************************/
int CControlBasis::ComputeControllerOutput(bool SubordinateController)
{
	// Local variables
	int i;
	double TempBuffer[NUM_AXES] = {0.0,0.0,0.0,0.0,0.0,0.0};	// Holds product: Gain * Error;

	// 1) Determine if this is a dominant or subordinate controller.
	if(SubordinateController == DOMINANT) // We have a dominant controller
	{
		// 2) Check to see if we have a position controller
		if(m_sWhichIsDomController == DOMINANT_POSITION_CONTROLLER)
		{
			// 3) Calculate error and its product with position gain.
			// We are ignoring the wrist position. Error was initialized to zero in all elements, so all three remain zero.
			for(i = 0; i<3/*NUM_AXES*/; i++)
			{
				m_dDomCont_Error[i] = m_dDomCont_DesInput[i] - m_dDomCont_ActualInput[i];
				TempBuffer[i] = m_dDomCont_Error[i] * m_dPositionGain[i];
			}

			// 4) Calculate product between Jacobian transform and TempBuffer. Store result in OUTPUT vector.
			JacobianProduct(DOMINANT_POSITION_CONTROLLER,TempBuffer);
		}

		// 2) Check to see if we have an Inverse Kinematic controller -- Added Sept 2008 to have a more robust position control method.
		/** ** ** Jan 2009. After implementing/debugging IKin's for the HP3JC, noted that there is some bug in the 3rd joing angle and I have not been able to fix. */
		/* We are now forced to create a cartesian controller. It is shown as the following option. This is problematic b/c now we operate in two different spaces: cartesian/joint angles.
		/* Hoping that it will work. */
		else if(m_sWhichIsDomController == DOMINANT_IKIN_CONTROLLER)
		{
			// First convert the desired XYZRPY position to joint angles. Make sure RPY is in radians, the matlab computation will change it.
			// Then subtract the value from actual joint angles. Get a difference that is then added to the previous controller joint position. 
			m_iRetVal = ComputeInverseKinematics(m_dDomCont_DesInput);
			if(m_iRetVal!=0)	return FAILURE;

			// 3) Calculate error between Desired_Joint_Angles and Actual Joint Angles. Also computed its product with position gain.
			for(i = 0; i<NUM_AXES; i++)
			{
				m_dDomCont_Error[i] = m_dDomCont_DesInput[i] - m_dDomCont_ActualInput[i];
				TempBuffer[i] = m_dDomCont_Error[i] * m_dIKinGain[i];
			}

			// 4) Calculate the update for joint angles and add current joint angles
			JacobianProduct(DOMINANT_IKIN_CONTROLLER,TempBuffer);
		}

		/**** 2) Jan. 2009. Check to see if we have cartesian controller  ***/
		else if(m_sWhichIsDomController == DOMINANT_CARTESIAN_CONTROLLER)
		{
			// 3) Calculate the error between desired cartesian position and actual position for cartesian quantities. The wrist never changes.
			for(i = 0; i<3; i++)
			{
				m_dDomCont_Error[i] = m_dDomCont_DesInput[i] - m_dDomCont_ActualInput[i];
				TempBuffer[i] = m_dDomCont_Error[i] * m_dCartesianGain[i];
			}

			// 4) Calculate the update for joint angles and add current joint angles
			JacobianProduct(DOMINANT_CARTESIAN_CONTROLLER,TempBuffer);
		}

		// 2) Check to see if we have a force controller
		else if(m_sWhichIsDomController == DOMINANT_FORCE_CONTROLLER)
		{

			// For force controller we need to clear the LAST three entries of the vector.
			for(i=3; i<NUM_AXES; i++) 
			{
				m_dDomCont_DesInput[i]		= 0.0;
				m_dDomCont_ActualInput[i]	= 0.0;
			}

			// 3) Calculate error and its product with position gain for the FIRST three entries
			//    For the force controller we have to also multiply by the force gain
			for(i = 0; i<NUM_AXES-3; i++)
			{
				m_dDomCont_Error[i] = m_dDomCont_DesInput[i] - m_dDomCont_ActualInput[i];
				TempBuffer[i] = m_dForceGain[i] * m_dDomCont_Error[i]; // Adjust the values of the gains to represent this equation. But needed to work on the position gain independently. * m_dPositionGain[i];
			}

			// 4) Calculate product between Jacobian transform and TempBuffer. Store result in OUTPUT vector.
			JacobianProduct(DOMINANT_FORCE_CONTROLLER,TempBuffer);
		}

		// 2) Check to see if we have a moment controller
		else if(m_sWhichIsDomController == DOMINANT_MOMENT_CONTROLLER)
		{
			// For moment controller we need to clear the first three entries of the vector that belong to the force
			for(i=0;i<NUM_AXES-3;i++)
			{
				m_dDomCont_DesInput[i]		= 0.0;
				m_dDomCont_ActualInput[i]	= 0.0;
			}
			
			// 3) Calculate error and its product with position gain for the LAST three entries of the vectors
			//    Also need to include the moment gain.
			for(i = 3; i<NUM_AXES; i++)
			{
				m_dDomCont_Error[i] = m_dDomCont_DesInput[i] - m_dDomCont_ActualInput[i];
				TempBuffer[i] = m_dMomentGain[i] * m_dDomCont_Error[i]; // Adjust the values of the gains to represent this equation. But needed to work on the position gain independently. * m_dPositionGain[i];
			}

			// 4) Calculate product between Jacobian transform and TempBuffer. Store result in OUTPUT vector.
			JacobianProduct(DOMINANT_MOMENT_CONTROLLER,TempBuffer);
		}
	}

	// 1) Determine if we have a subordinate controller
	if(SubordinateController == SUBORDINATE) 
	{
		// 2) Check to see if we have a position controller
		if(m_sWhichIsSubController == SUBORDINATE_POSITION_CONTROLLER)
		{
			// 3) Calculate error and its product with position gain.
			for(i = 0; i<NUM_AXES; i++)
			{
				m_dSubCont_Error[i] = m_dSubCont_DesInput[i] - m_dSubCont_ActualInput[i];
				TempBuffer[i] = m_dSubCont_Error[i] * m_dPositionGain[i];
			}

			// 4) Calculate product between Jacobian transform and TempBuffer. Store result in OUTPUT vector.
			JacobianProduct(SUBORDINATE_POSITION_CONTROLLER,TempBuffer);
		}

		// Check to see if this is the subordinate IKin controller
		else if(m_sWhichIsSubController == SUBORDINATE_IKIN_CONTROLLER)
		{
			// First convert the desired XYZRPY position to joint angles. Then subtract the value from actual joint angles. Get a difference that is then added to the previous controller joint position. 
			m_iRetVal = ComputeInverseKinematics(m_dSubCont_DesInput);
			if(m_iRetVal!=0)	return FAILURE;

			// 3) Calculate error between Desired_Joint_Angles and Actual Joint Angles. Also computed its product with position gain.
			for(i = 0; i<NUM_AXES; i++)
			{
				m_dSubCont_Error[i] = m_dSubCont_DesInput[i] - m_dSubCont_ActualInput[i];
				TempBuffer[i] = m_dSubCont_Error[i] * m_dIKinGain[i];
			}

			// 4) Calculate the update for joint angles and add current joint angles
			JacobianProduct(SUBORDINATE_IKIN_CONTROLLER,TempBuffer);
		}

		/**** 2) Jan. 2009. Check to see if we have cartesian controller  ***/
		else if(m_sWhichIsSubController == SUBORDINATE_CARTESIAN_CONTROLLER)
		{
			// 3) Calculate the error between desired cartesian position and actual position for all 6 vector quantities.
			for(i=0; i<NUM_AXES; i++)
			{
				m_dSubCont_Error[i] = m_dSubCont_DesInput[i] - m_dSubCont_ActualInput[i];
				TempBuffer[i] = m_dSubCont_Error[i] * m_dCartesianGain[i];
			}

			// 4) Calculate the update for joint angles and add current joint angles
			JacobianProduct(SUBORDINATE_CARTESIAN_CONTROLLER,TempBuffer);
		}

		// 2) Check to see if we have a force controller
		//	  Also need to include the force gain
		else if(m_sWhichIsSubController == SUBORDINATE_FORCE_CONTROLLER)
		{
			// For force controller we need to clear the LAST three entries of the vector.
			for(i=3; i<NUM_AXES; i++) 
			{
				m_dSubCont_DesInput[i]		= 0.0;
				m_dSubCont_ActualInput[i]	= 0.0;
			}
			// 3) Calculate error and its product with position gain for the FIRST three entries
			for(i = 0; i<NUM_AXES-3; i++)
			{
				m_dSubCont_Error[i] = m_dSubCont_DesInput[i] - m_dSubCont_ActualInput[i];
				TempBuffer[i] = m_dForceGain[i] * m_dSubCont_Error[i]; // Adjust the values of the gains to represent this equation. But needed to work on the position gain independently. * m_dPositionGain[i];
			}

			// 4) Calculate product between Jacobian transform and TempBuffer. Store result in OUTPUT vector.
			JacobianProduct(SUBORDINATE_FORCE_CONTROLLER,TempBuffer);
		}

		// 2) Check to see if we have a moment controller
		//	  Also need to include the moment gain
		else if(m_sWhichIsSubController == SUBORDINATE_MOMENT_CONTROLLER)
		{
			// For moment controller we need to clear the FIRST three entries of the vector 
			for(i=0;i<3;i++)
			{
				m_dSubCont_DesInput[i]		= 0.0;
				m_dSubCont_ActualInput[i]	= 0.0;
			}
			// 3) Calculate error and its product with position gain for the LAST three entries.
			for(i = 3; i<NUM_AXES; i++)
			{
				m_dSubCont_Error[i] = m_dSubCont_DesInput[i] - m_dSubCont_ActualInput[i];
				TempBuffer[i] = m_dMomentGain[i] * m_dSubCont_Error[i]; // Adjust the values of the gains to represent this equation. But needed to work on the position gain independently. * m_dPositionGain[i];
			}

			// 4) Calculate product between Jacobian transform and TempBuffer. Store result in OUTPUT vector.
			JacobianProduct(SUBORDINATE_MOMENT_CONTROLLER,TempBuffer);
		}
	}

	return SUCCESS;
}

/****************************************************
* JacobianProduct()
* Returns the control basis output.
* 
* This function performs the following:
* 1) Calls: ComputeJacobian() which creates the 
*    the individual elements of the Jacobian transform.
* 2) Multiply by the Intermediate product of the error 
*    and the gain to obtain the control basis controller
*    output.
* 3) Write results to file according to robot and controller.
* 4) Add the update in joint Angle to the current 
*    angle position (only when we are working with one controller - Dominant).
*	 q_new = q_old + delta_q.
* 5) A new functionality has been added to compute output having used
*    inverse kinematics. This part does not multiply by a jacobian.
****************************************************/
void CControlBasis::JacobianProduct(short TypeOfController, double * TempBuffer)
{
	// Local variables
	int i; 

	// 1) Call the ComputeJacobian() method to resolve the Jacobian according to current joint angles
	// Except for the IKIN or CARTESIAN controllers
	if(TypeOfController != DOMINANT_IKIN_CONTROLLER && TypeOfController != SUBORDINATE_IKIN_CONTROLLER && TypeOfController != DOMINANT_CARTESIAN_CONTROLLER && TypeOfController != SUBORDINATE_CARTESIAN_CONTROLLER)
		ComputeJacobian(TypeOfController);

	// Determine if we are working with the dominant or subordinate controller
	if(TypeOfController == DOMINANT_POSITION_CONTROLLER || TypeOfController == DOMINANT_FORCE_CONTROLLER || TypeOfController == DOMINANT_MOMENT_CONTROLLER)
	{
		// 2) Compute the elements of the output vector
		/** 1st **/
		m_dDomCont_Output[0] = (J11 * TempBuffer[0]) + (J12 * TempBuffer[1]) + (J13 * TempBuffer[2]) + 
								  (J14 * TempBuffer[3]) + (J15 * TempBuffer[4]) + (J16 * TempBuffer[5]);
		/** 2nd **/
		m_dDomCont_Output[1] = (J21 * TempBuffer[0]) + (J22 * TempBuffer[1]) + (J23 * TempBuffer[2]) + 
								  (J24 * TempBuffer[3]) + (J25 * TempBuffer[4]) + (J26 * TempBuffer[5]);
		/** 3rd **/
		m_dDomCont_Output[2] = (J31 * TempBuffer[0]) + (J32 * TempBuffer[1]) + (J33 * TempBuffer[2]) + 
								  (J34 * TempBuffer[3]) + (J35 * TempBuffer[4]) + (J36 * TempBuffer[5]);
		/** 4th **/
		m_dDomCont_Output[3] = (J41 * TempBuffer[0]) + (J42 * TempBuffer[1]) + (J43 * TempBuffer[2]) + 
								  (J44 * TempBuffer[3]) + (J45 * TempBuffer[4]) + (J46 * TempBuffer[5]);	
		/** 5th **/
		m_dDomCont_Output[4] = (J51 * TempBuffer[0]) + (J52 * TempBuffer[1]) + (J53 * TempBuffer[2]) + 
								  (J54 * TempBuffer[3]) + (J55 * TempBuffer[4]) + (J56 * TempBuffer[5]);
		/** 6th **/
		m_dDomCont_Output[5] = (J61 * TempBuffer[0]) + (J62 * TempBuffer[1]) + (J63 * TempBuffer[2]) + 
								  (J64 * TempBuffer[3]) + (J65 * TempBuffer[4]) + (J66 * TempBuffer[5]);


		// 4) Add the update in joint Angle to the actual joint angle position if we are working with one controller/
		//    If there are two controllers this will be done at the end.
		if(m_sNumControllers == 1)
			for(i = 0; i<NUM_AXES; i++)
				m_dDomCont_Output[i] = m_dDomCont_Output[i] + Angle[i];
			
		if(m_bWrite2File == TRUE)
			if(m_sWhatRobot == HP3JC_ROBOT)
				Write2File("HP3JC", sample_time, m_dDomCont_Output, "UpdateJointAngles.txt");	// Write updated joint angles to file
			if(m_sWhatRobot == ISAC_ROBOT)
				Write2File("ISAC", sample_time, m_dDomCont_Output, "UpdateJointAngles.txt");	// Write updated joint angles to file
		
	}

	if(TypeOfController == SUBORDINATE_POSITION_CONTROLLER || TypeOfController == SUBORDINATE_FORCE_CONTROLLER || TypeOfController == SUBORDINATE_MOMENT_CONTROLLER)
	{
		// 2) Compute the elements of the output vector
		/** 1st **/
		m_dSubCont_Output[0] = (J11 * TempBuffer[0]) + (J12 * TempBuffer[1]) + (J13 * TempBuffer[2]) + 
								  (J14 * TempBuffer[3]) + (J15 * TempBuffer[4]) + (J16 * TempBuffer[5]);
		/** 2nd **/
		m_dSubCont_Output[1] = (J21 * TempBuffer[0]) + (J22 * TempBuffer[1]) + (J23 * TempBuffer[2]) + 
								  (J24 * TempBuffer[3]) + (J25 * TempBuffer[4]) + (J26 * TempBuffer[5]);
		/** 3rd **/
		m_dSubCont_Output[2] = (J31 * TempBuffer[0]) + (J32 * TempBuffer[1]) + (J33 * TempBuffer[2]) + 
								  (J34 * TempBuffer[3]) + (J35 * TempBuffer[4]) + (J36 * TempBuffer[5]);
		/** 4th **/
		m_dSubCont_Output[3] = (J41 * TempBuffer[0]) + (J42 * TempBuffer[1]) + (J43 * TempBuffer[2]) + 
								  (J44 * TempBuffer[3]) + (J45 * TempBuffer[4]) + (J46 * TempBuffer[5]);	
		/** 5th **/
		m_dSubCont_Output[4] = (J51 * TempBuffer[0]) + (J52 * TempBuffer[1]) + (J53 * TempBuffer[2]) + 
								  (J54 * TempBuffer[3]) + (J55 * TempBuffer[4]) + (J56 * TempBuffer[5]);
		/** 6th **/
		m_dSubCont_Output[5] = (J61 * TempBuffer[0]) + (J62 * TempBuffer[1]) + (J63 * TempBuffer[2]) + 
								  (J64 * TempBuffer[3]) + (J65 * TempBuffer[4]) + (J66 * TempBuffer[5]);

		//////////////////////////////////////////////////////////////////////////////////////////////////////
		// 4) There is no addition of current angles to subordinate output. That happens after the projection.
		//////////////////////////////////////////////////////////////////////////////////////////////////////
	}

	/***************** IKIN_CONTROLLER ************************/
	// 5) Copy the temp_buffer result over to m_dDomCont_Output	
	if(TypeOfController == DOMINANT_IKIN_CONTROLLER)
	{
		memcpy(m_dDomCont_Output,TempBuffer,sizeof(double)*NUM_AXES);
		// If dominant controller, then add updated joint angles positions to the current position. 
		if(m_sNumControllers == 1)
			for(i = 0; i<NUM_AXES; i++)
				m_dDomCont_Output[i] = m_dDomCont_Output[i] + Angle[i];
	}

	else if(TypeOfController == SUBORDINATE_IKIN_CONTROLLER)
	{
		memcpy(m_dSubCont_Output,TempBuffer,sizeof(double)*NUM_AXES);
	}

	/****************** Cartesian Controller ***********************/
	// 5) Copy the temp_buffer result over to m_dDomCont_Output. We don't add the actual joint angle position to our output since its in cartesian coordinates.
	if(TypeOfController == DOMINANT_CARTESIAN_CONTROLLER)
	{
		// Copy results to output member variable
		memcpy(m_dDomCont_Output,TempBuffer,sizeof(double)*NUM_AXES);

		// Add updated cartesian positions to the current position
		for(i = 0; i<NUM_AXES; i++)
			m_dDomCont_Output[i] = m_dDomCont_Output[i] + m_dDomCont_ActualInput[i];
	}

	// For the subordinate case we will have to output elsewhere, and perform no null space projection...
	else if(TypeOfController == SUBORDINATE_CARTESIAN_CONTROLLER)
	{
		// Copy results to output member variable
		memcpy(m_dSubCont_Output,TempBuffer,sizeof(double)*NUM_AXES);

		// Add updated cartesian positions to the current position
		for(i = 0; i<NUM_AXES; i++)
			m_dSubCont_Output[i] = m_dSubCont_Output[i] + m_dSubCont_ActualInput[i];

	}

	// 3) Write to file
	if(m_bWrite2File == TRUE)	
	{

		/*********************************** TIMING ********************************************/
		// Read timing data
		QueryPerformanceCounter(&end_ticks);
		// Compute time between sample readings
		sample_time = (double)(end_ticks.QuadPart - start_ticks.QuadPart)/(double)ticksPerSecond.QuadPart;
		// Copy end_ticks time to start_ticks time, to compute the difference for the next run.
		end_ticks.QuadPart = start_ticks.QuadPart;

		// Write to file

		/************************* HP3JC *****************************************************/
		if(m_sWhatRobot == HP3JC_ROBOT)
		{
			/********************************** DOMINANT *****************************************/
			// Position Control
			if(m_sWhichIsDomController == DOMINANT_POSITION_CONTROLLER)
			{				
				Write2File("HP3JC", sample_time, m_dDomCont_Error,  "Error_DomPos.txt");
				Write2File("HP3JC", sample_time, m_dDomCont_Output, "JointUpdate_DomPos.txt");
			}

			// IKin Control
			else if(m_sWhichIsDomController == DOMINANT_IKIN_CONTROLLER) 
			{				
				Write2File("HP3JC", sample_time, m_dDomCont_Error,  "Error_DomIKin.txt");
				Write2File("HP3JC", sample_time, m_dDomCont_Output, "JointUpdate_DomIKin.txt");
			}

			// Cartesian Control
			else if(m_sWhichIsDomController == DOMINANT_CARTESIAN_CONTROLLER) 
			{				
				Write2File("HP3JC", sample_time, m_dDomCont_Error,  "Error_DomCartesian.txt");
				Write2File("HP3JC", sample_time, m_dDomCont_Output, "JointUpdate_DomCartesian.txt");
			}

			// Force Control
			else if(m_sWhichIsDomController == DOMINANT_FORCE_CONTROLLER) 
			{				
				Write2File("HP3JC", sample_time, m_dDomCont_Error,  "Error_DomForce.txt");
				Write2File("HP3JC", sample_time, m_dDomCont_Output, "JointUpdate_DomForce.txt");
			}
			
			// Moment Control
			else if(m_sWhichIsDomController == DOMINANT_MOMENT_CONTROLLER) 
			{				
				Write2File("HP3JC", sample_time, m_dDomCont_Error,  "Error_DomMoment.txt");
				Write2File("HP3JC", sample_time, m_dDomCont_Output, "JointUpdate_DomMoment.txt");
			}

			/************************** SUBORDINATE ***********************************************/
			// Position Control
			if(m_sWhichIsSubController == SUBORDINATE_POSITION_CONTROLLER)
			{				
				Write2File("HP3JC", sample_time, m_dSubCont_Error,  "Error_SubPos.txt");
				Write2File("HP3JC", sample_time, m_dSubCont_Output, "JointUpdate_SubPos.txt");
			}

			// IKin Control
			else if(m_sWhichIsSubController == SUBORDINATE_IKIN_CONTROLLER) 
			{				
				Write2File("HP3JC", sample_time, m_dSubCont_Error,  "Error_SubIKin.txt");
				Write2File("HP3JC", sample_time, m_dSubCont_Output, "JointUpdate_SubIKin.txt");
			}

			// Cartesian Control
			else if(m_sWhichIsSubController == SUBORDINATE_CARTESIAN_CONTROLLER) 
			{				
				Write2File("HP3JC", sample_time, m_dSubCont_Error,  "Error_SubCartesian.txt");
				Write2File("HP3JC", sample_time, m_dSubCont_Output, "JointUpdate_SubCartesian.txt");
			}

			// Force Control
			else if(m_sWhichIsSubController == SUBORDINATE_FORCE_CONTROLLER) 
			{				
				Write2File("HP3JC", sample_time, m_dSubCont_Error,  "Error_SubForce.txt");
				Write2File("HP3JC", sample_time, m_dSubCont_Output, "JointUpdate_SubForce.txt");
			}
			
			// Moment Control
			else if(m_sWhichIsSubController == SUBORDINATE_MOMENT_CONTROLLER) 
			{				
				Write2File("HP3JC", sample_time, m_dSubCont_Error,  "Error_SubMoment.txt");
				Write2File("HP3JC", sample_time, m_dSubCont_Output, "JointUpdate_SubMoment.txt");
			}
		
		}
		
		/***************************** ISAC *****************************************************/
		else	
		{
			/********************************* DOMINANT *****************************************/
			// Position Control
			if(m_sWhichIsDomController == DOMINANT_POSITION_CONTROLLER)
			{				
				Write2File("ISAC", sample_time, m_dDomCont_Error,  "Error_DomPos.txt");
				Write2File("ISAC", sample_time, m_dDomCont_Output, "JointUpdate_DomPos.txt");
			}

			// IKin Control
			else if(m_sWhichIsDomController == DOMINANT_IKIN_CONTROLLER) 
			{				
				Write2File("ISAC", sample_time, m_dDomCont_Error,  "Error_DomIKin.txt");
				Write2File("ISAC", sample_time, m_dDomCont_Output, "JointUpdate_DomIKin.txt");
			}

			// Cartesian Control
			else if(m_sWhichIsDomController == DOMINANT_CARTESIAN_CONTROLLER) 
			{				
				Write2File("ISAC", sample_time, m_dDomCont_Error,  "Error_DomCartesian.txt");
				Write2File("ISAC", sample_time, m_dDomCont_Output, "JointUpdate_DomCartesian.txt");
			}

			// Force Control
			else if(m_sWhichIsDomController == DOMINANT_FORCE_CONTROLLER) 
			{				
				Write2File("ISAC", sample_time, m_dDomCont_Error,  "Error_DomForce.txt");
				Write2File("ISAC", sample_time, m_dDomCont_Output, "JointUpdate_DomForce.txt");
			}
			
			// Moment Control
			else if(m_sWhichIsDomController == DOMINANT_MOMENT_CONTROLLER) 
			{				
				Write2File("ISAC", sample_time, m_dDomCont_Error,  "Error_DomMoment.txt");
				Write2File("ISAC", sample_time, m_dDomCont_Output, "JointUpdate_DomMoment.txt");
			}

			/************************ SUBORDINATE ***********************************************/
			// Position Control
			if(m_sWhichIsSubController == SUBORDINATE_POSITION_CONTROLLER)
			{				
				Write2File("ISAC", sample_time, m_dSubCont_Error,  "Error_SubPos.txt");
				Write2File("ISAC", sample_time, m_dSubCont_Output, "JointUpdate_SubPos.txt");
			}

			// IKin Control
			else if(m_sWhichIsSubController == SUBORDINATE_IKIN_CONTROLLER) 
			{				
				Write2File("ISAC", sample_time, m_dSubCont_Error,  "Error_SubIKin.txt");
				Write2File("ISAC", sample_time, m_dSubCont_Output, "JointUpdate_SubIKin.txt");
			}

			// Cartesian Control
			else if(m_sWhichIsSubController == SUBORDINATE_CARTESIAN_CONTROLLER) 
			{				
				Write2File("ISAC", sample_time, m_dSubCont_Error,  "Error_SubCartesian.txt");
				Write2File("ISAC", sample_time, m_dSubCont_Output, "JointUpdate_SubCartesian.txt");
			}

			// Force Control
			else if(m_sWhichIsSubController == SUBORDINATE_FORCE_CONTROLLER) 
			{				
				Write2File("ISAC", sample_time, m_dSubCont_Error,  "Error_SubForce.txt");
				Write2File("ISAC", sample_time, m_dSubCont_Output, "JointUpdate_SubForce.txt");
			}
			
			// Moment Control
			else if(m_sWhichIsSubController == SUBORDINATE_MOMENT_CONTROLLER) 
			{				
				Write2File("ISAC", sample_time, m_dSubCont_Error,  "Error_SubMoment.txt");
				Write2File("ISAC", sample_time, m_dSubCont_Output, "JointUpdate_SubMoment.txt");
			}
		}
	}
}

/********************************************************************************
* ProjectToNullSpace()
* This function projects the output of the subordinate
* controller to the null space of the dominant controller.
* It is important to note that the dominant output is the update
* produced by that controller but is not the updated position.
* Ie the update might be 0.4 degrees and the position might be 90.4 degrees.
* 
* We multiply m_dSubCont_Output * null_space_matrix and 
* place the result in m_dNullSpaceProjection
*
* This controller consider a 6D space, given that the input
* and output vectors will always be the change in joint 
* coordinates, m_sDomCont_OutputIndex(q1,q2,q3,q4,q5,q6).
*
* In the following explanation, m_sDomCont_OutputIndex will be
* represented by x_out:
* 
* From Platt's work, the null space operator, N, is defined as:
* 
* N = I - [x_out * inv(x_out' * x_out) * x_out']
*
* N = I - [ 1/(q1^2 + q2^2 + q3^2 + q4^2 + q5^2 + q6) * |q1^2 q1q2 q13 ... q1q6 |
*														|q2q1 q2^2 ...     q2q6 |
*														|q6q1  ... ...      q6^2|
*
* Notice that the identity matrix is subtracted from 
* the outer product normalized by the dot product of x_out.
*
* Variables:
* Denominator - we compute the value of the denominator ahead of time.
* Matrix multiplication - the product of the null_space_matrix
* with the subordinate controller output will be implemented by the use
* of 2 'for-loops'.
* The results will be stored in: m_dNullSpaceProjection
* 
* SPECIAL CASE: there may be a time where the dominant controller is all zeros
* If this is the case, we need to code the value of denominator to 1, otherwise
* there will be a division by zero.
*
* A simple way to understand the projection matrix (I did this in matlab) is
* that when the dominant controller has a zero value, the diagonal element
* in the projection matrix belonging to that element will be 1. This means
* that given there is no contribution by the dom controller the subordinate
* controller can changae this element in a linear fashion.
*******************************************************************************/
void CControlBasis::ProjectToNullSpace()
{
	// Local variables
	double denominator;
	double x[NUM_AXES]={0};

	// Make a local copy of the dominant controller output for convencience:
	memcpy(x,m_dDomCont_Output,sizeof(double)*NUM_AXES);

	// 1) Implement the denominator term of the projection matrix. The denominator is computed by adding the squares of the diagonal:
	//    It uses the values of the dominant controller.
	//	  Watch out for the special case in which all elements of the dominant output are zero.
	if(x[0]+x[1]+x[2]+x[3]+x[4]+x[5] == 0.0)
		denominator = 1.0;
	else
		denominator = pow(x[0],2) + pow(x[1],2) + pow(x[2],2) + pow(x[3],2) + pow(x[4],2) + pow(x[5],2);

	// 2) Two things happen inside the for-loop:
	//    The first thing is the implementation of the projection matrix itself. The projection matrix is the identity matrix - (the outer matrix product / the inner matrix product).
	//
	//    The second thing that happens is that this projection matrix is multiplied by the subordinate controller output. 
	//    This is a 6x6 times 6x1 multiplication. The first row of this output is the sum of the products of the (row_element) x (column_element), ie
	//	  output_row1 = [proj(0,0) * sub_output(0) + proj(0,1) * sub_output(1) + ... + proj(0,5) * sub_output(5)]
	//	  
	//    We are carrying out both things in the same for-loop.
	for(int i=0;i<NUM_AXES;i++)
	{
		for(int j=0;j<NUM_AXES;j++)
		{
			m_dNullSpaceProjectionMatrix[i][j] = ( eye[i][j] - (x[i]*x[j])/denominator );
			m_dNullSpaceProjectionOutput[i] = m_dNullSpaceProjectionOutput[i] + (m_dNullSpaceProjectionMatrix[i][j] * m_dSubCont_Output[j]);			
		}
	}
}

/****************************************************
* GetDominantVectorData()
* Retrieves object and interface pointers of:
* the Desired, Actual, output, angle, and cartesian vectors.
*
* Also passes VS data to private member variables.
*
* At the end, we free memory and release interface
* handles.
*
* Update - Jan 2009
* Given that we had to change from a joint position controller
* to a cartesian position controller, the data retrieved is no longer
****************************************************/
HRESULT CControlBasis::GetDominantVectorData()
{
	// Local Variables
	int				i		= 0;
	short			Counter = 0;
	SAFEARRAY*		mysa;
	IVectorSignal *pIVSDomDesInput, *pIVSDomActualInput, *pIVSAngle, *pIVSCartesian;


	// (1) Get dominant vector data. Get (a) object pointers, (b) interface pointers, (c) VS data.
	m_Bindings->get_Pointers(SysAllocString(L"DomCont_DesiredInput"), &m_pIUnkDomCont_DesInput);
	m_Bindings->get_Pointers(SysAllocString(L"DomCont_ActualInput"), &m_pIUnkDomCont_ActualInput);

	// The two below only don't need to be repeated in GetSubordinateVectorData() since once they are copied here they are useful throughout the whole program
	m_Bindings->get_Pointers(SysAllocString(L"ActualAngle"), &m_pIUnkAngle);
	m_Bindings->get_Pointers(SysAllocString(L"ActualCartesian"), &m_pIUnkCartesian);

	// Check to make sure that all pointers work. Otherwise exit function.
	if(m_pIUnkDomCont_ActualInput == NULL || m_pIUnkDomCont_ActualInput == NULL || m_pIUnkDomCont_DesInput == NULL || m_pIUnkCartesian == NULL)
	{
		MessageBox(NULL, "GetDominantVectorData()::Error. Object pointer could not be found", "Error::get_Pointers()",MB_OK);
		return !S_OK;
	}

	// (b) Get Interface pointers
	m_pIUnkDomCont_DesInput->QueryInterface(IID_IVectorSignal, (void **)&pIVSDomDesInput);
	m_pIUnkDomCont_ActualInput->QueryInterface(IID_IVectorSignal, (void **)&pIVSDomActualInput);
	m_pIUnkAngle->QueryInterface(IID_IVectorSignal, (void**)&pIVSAngle);	
	m_pIUnkCartesian->QueryInterface(IID_IVectorSignal, (void**)&pIVSCartesian);


	// (c) Desired VS Data
	if(pIVSDomDesInput != NULL)	
	{
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		pIVSDomDesInput->GetCurrentVector(mysa);
		memcpy(m_dDomCont_DesInput,mysa->pvData,sizeof(double)*NUM_AXES);
		SafeArrayDestroy(mysa);
		pIVSDomDesInput->Release();
	}

	// (c) Actual VS Data
	if(pIVSDomActualInput != NULL)
	{
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		pIVSDomActualInput->GetCurrentVector(mysa);
		memcpy(m_dDomCont_ActualInput,mysa->pvData,sizeof(double)*NUM_AXES);
		SafeArrayDestroy(mysa);
		pIVSDomActualInput->Release();
	}

	// (c) Joint Angle VS Data
	// ****Now also repeat the process to get the Actual Joint Angles for the robot. Data is used throughout.****//
	// Don't need to repeat this call in GetSubordinateVectorData() given that this will always be called if the subordinate call is made. 
	if(pIVSAngle != NULL)
	{
		// Copy data to Angle member variable. Used when executing the Jacobian.
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		pIVSAngle->GetCurrentVector(mysa);
		memcpy(Angle,mysa->pvData,sizeof(double)*NUM_AXES);
		SafeArrayDestroy(mysa);
		m_pIUnkAngle->Release();
	}

	// (c) Actual Cartesian Data
	if(pIVSCartesian != NULL)
	{
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		pIVSCartesian->GetCurrentVector(mysa);
		memcpy(m_dActualCartesian,mysa->pvData,sizeof(double)*NUM_AXES);
		SafeArrayDestroy(mysa);
		pIVSCartesian->Release();
	}

	//************************************************************************************************************//
	//****************************************  SPECIAL CASES  ***************************************************//
	//************************************************************************************************************//
	
	// (A) Force Controllers: Clear Noise 
	if(m_sWhichIsDomController == DOMINANT_FORCE_CONTROLLER || m_sWhichIsDomController == DOMINANT_MOMENT_CONTROLLER)
	{
		for(i=0; i<NUM_AXES;i++)
			if(m_dDomCont_ActualInput[i] != 0.0 && fabs(m_dDomCont_ActualInput[i]) < 0.3) /*** THRESHOLD ****/
				m_dDomCont_ActualInput[i] = 0.0;
	}

	// (B) Cartesian Controller: convert incremental data from file into desired cartesian position
	// The vision system in the Assembly demo provides this component with incremental cartesian data (ie change 10 cm in X direction).
	// After some testing, it was decided that absolute world coordinates are best.
	// So, the incremental data will be added to the current cartesian position, accessible through the HP3JC component.
	// This desired value will not change unless the incremental value is changed. 
	// The way this demo is structured, that should not happen but once but this structure contemplates future changes.
	if(m_sWhichIsDomController == DOMINANT_CARTESIAN_CONTROLLER)
	{
		int nFileStat;

		// Initial run through at the beginning of the program
		if(bCartesianFlag == 0)
		{
			// Get incremental data from file
			// Open file
			stream = fopen("O:\\Demos\\AssemblyDemo\\GoalPosition.txt","r+t");
			// Read from file
			for(i=0;i<3;i++)
				nFileStat = fscanf(stream ,"%lf\t",&(m_dDomCont_DesInput[i]));
			// Close File
			fclose(stream);
			stream = NULL;

			// Continue only when the data is not null.
			if(fabs(m_dDomCont_DesInput[0]) + fabs(m_dDomCont_DesInput[1]) + fabs(m_dDomCont_DesInput[2]) != 0)
			{
				// (1) Add incremental data to actual data
				m_dDomCont_DesInput[0] = m_dDomCont_DesInput[0] - 27.5; // compensate for some error
				m_dDomCont_DesInput[2] = m_dDomCont_DesInput[2] - 15; // compnesates for arms moving up

				for(i=0; i<NUM_AXES; i++)
					m_dDesiredXYZRPY[i] = m_dDomCont_DesInput[i] + m_dActualCartesian[i];
				
				// Change the flag.
				bCartesianFlag = 1;
			}
			
			// Still add the null results to the actual position
			else
			{
				// (1) Add incremental data to actual data
				for(i=0; i<NUM_AXES; i++)
					m_dDesiredXYZRPY[i] = m_dDomCont_DesInput[i] + m_dActualCartesian[i];

			}
		}

		// Copy the permant value for the DesiredXYZRPY to the m_dDomCont_DesInput
		memcpy(m_dDomCont_DesInput, m_dDesiredXYZRPY, sizeof(double)*NUM_AXES);
	}
	

	return S_OK;
}

/****************************************************
* GetSubordinateVectorData()
* Retrieves object and interface pointers of:
* the Desired, Actual, and Output vectors.
*
* Also passes VS data to private member variables.
*
* At the end, we free memory and release interface
* handles.
****************************************************/
HRESULT CControlBasis::GetSubordinateVectorData()
{
	// Local Variables
	int				i		= 0;
	short			Counter = 0;
	SAFEARRAY*		mysa;
	IVectorSignal *pIVSSubDesInput, *pIVSSubActualInput;

	// Get object pointers for all three vectors.
	m_Bindings->get_Pointers(SysAllocString(L"SubCont_DesiredInput"), &m_pIUnkSubCont_DesInput);
	m_Bindings->get_Pointers(SysAllocString(L"SubCont_ActualInput"), &m_pIUnkSubCont_ActualInput);
	
	if(m_pIUnkSubCont_DesInput == NULL || m_pIUnkSubCont_ActualInput == NULL)	return !S_OK;

	// (b) Get Interface pointers
	m_pIUnkSubCont_DesInput->QueryInterface(IID_IVectorSignal, (void **)&pIVSSubDesInput);
	m_pIUnkSubCont_ActualInput->QueryInterface(IID_IVectorSignal, (void **)&pIVSSubActualInput);

	if(pIVSSubDesInput != NULL)
	{
		// (c) Get data from VS for Desired subordinate input
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		pIVSSubDesInput->GetCurrentVector(mysa);
		memcpy(m_dSubCont_DesInput,mysa->pvData,sizeof(double)*NUM_AXES);
		SafeArrayDestroy(mysa);
		m_pIUnkSubCont_DesInput->Release();
	}

	if(pIVSSubActualInput != NULL)
	{
		// (c) Get data from VS for Acutal subordinate input. If a cartesian controller is selected this will be skipped b/c binding is of type IHP3JC
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		pIVSSubActualInput->GetCurrentVector(mysa);
		memcpy(m_dSubCont_ActualInput,mysa->pvData,sizeof(double)*NUM_AXES);
		SafeArrayDestroy(mysa);
		m_pIUnkSubCont_ActualInput->Release();
	}

	
	//************************************************************************************************************//
	//****************************************  SPECIAL CASES  ***************************************************//
	//************************************************************************************************************//

	// (A) Force Controllers: Clear Noise 
	if(m_sWhichIsSubController == SUBORDINATE_FORCE_CONTROLLER || m_sWhichIsSubController == SUBORDINATE_MOMENT_CONTROLLER)
	{
		for(i=0; i<NUM_AXES;i++)
		if(m_dSubCont_ActualInput[i] != 0.0 && fabs(m_dSubCont_ActualInput[i]) < 0.2)
			m_dSubCont_ActualInput[i] = 0.0;
	}


	// (B) Cartesian Controller: convert incremental data from file into desired cartesian position
	// The vision system in the Assembly demo provides this component with incremental cartesian data (ie change 10 cm in X direction).
	// After some testing, it was decided that absolute world coordinates are best.
	// So, the incremental data will be added to the current cartesian position, accessible through the HP3JC component.
	// This desired value will not change unless the incremental value is changed. 
	// The way this demo is structured, that should not happen but once but this structure contemplates future changes.
	if(m_sWhichIsSubController == SUBORDINATE_CARTESIAN_CONTROLLER)
	{
		int nFileStat;

		// Initial run through at the beginning of the program
		if(bCartesianFlag == 0)
		{
			// Get incremental data from file
			// Open file
			stream = fopen("O:\\Demos\\AssemblyDemo\\GoalPosition.txt","r+t");
			// Read from file
			for(i=0;i<3;i++)
				nFileStat = fscanf(stream ,"%lf\t",&(m_dSubCont_DesInput[i]));
			// Close File
			fclose(stream);
			stream = NULL;

			// (1) Add incremental data to actual data
			for(i=0; i<NUM_AXES; i++)
				m_dDesiredXYZRPY[i] = m_dSubCont_DesInput[i] + m_dActualCartesian[i];
			
			// Change the flag.
			bCartesianFlag = 1;
		}

		// Copy the permant value for the DesiredXYZRPY to the m_dDomCont_DesInput
		memcpy(m_dSubCont_DesInput, m_dDesiredXYZRPY, sizeof(double)*NUM_AXES);
	}	
	return S_OK;
}

// Will write to a file the values passed to the input argument.
void CControlBasis::Write2File(char * title, double time, double * data , char * textfile)
{
	int i;
	USES_CONVERSION;

	/* String concatenation to allow for different file names*/
	char path[200] = "U:\\School\\Ph_D\\Experiments\\ControlBasis\\Data\\HP3JC\\";

	// Concatenate
	strcat(path,textfile);	

	// Open the file
	stream = fopen(path,"a+t");

	// Write result to the file

	// Time
	//fprintf(stream, "%.2f\t", time);

	// Print data 
	for(i=0;i<NUM_AXES;i++)
		fprintf(stream,"%.2f ", data[i]);

	// Newline
	fprintf(stream, "\n");

	// Close the file
	fclose(stream);
	stream = NULL;

}

/****************************************************
* WriteJointAngleHomePosition()
*
* This function is called from Initial and it is
* used to initially set the value for Angles[]
* to the joint angle home position.
*
* This is done for the HP3JC
****************************************************/


void CControlBasis::WriteJointAngleHomePosition()
{

	if(m_sWhatRobot == HP3JC_ROBOT)
	{
		Angle[0] =    0.0;
		Angle[1] = - 90.0;
		Angle[2] =    0.0;
		Angle[3] =  180.0;
		Angle[4] = - 90.0;
		Angle[5] =    0.0;
	}

	// Previous controllers (JointAngle and Cartesian) should be equal to the starting configuration of the robot.
	// We read these positions and copy them one time at the beginning ofthe program here.

	// Local Methods
	int				i		= 0;
	SAFEARRAY*		mysa;
	IVectorSignal *pIVSAngle, *pIVSCartesian;


	// The two below only don't need to be repeated in GetSubordinateVectorData() since once they are copied here they are useful throughout the whole program
	// Get object pointers
	m_Bindings->get_Pointers(SysAllocString(L"ActualAngle"), &m_pIUnkAngle);
	m_Bindings->get_Pointers(SysAllocString(L"ActualCartesian"), &m_pIUnkCartesian);
	if(m_pIUnkAngle != NULL || m_pIUnkCartesian != NULL)
	{	
		// Get interface pointers:
		m_pIUnkAngle->QueryInterface(IID_IVectorSignal, (void**)&pIVSAngle);	
		m_pIUnkCartesian->QueryInterface(IID_IVectorSignal, (void**)&pIVSCartesian);

		// Joint Angle VS Data
		if(pIVSAngle != NULL)
		{
			// Copy data to Angle member variable. Used when executing the Jacobian.
			mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
			pIVSAngle->GetCurrentVector(mysa);
			memcpy(Angle,mysa->pvData,sizeof(double)*NUM_AXES);
			SafeArrayDestroy(mysa);
			m_pIUnkAngle->Release();
		}

		// Actual Cartesian Data
		if(pIVSCartesian != NULL)
		{
			mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
			pIVSCartesian->GetCurrentVector(mysa);
			memcpy(m_dActualCartesian,mysa->pvData,sizeof(double)*NUM_AXES);
			SafeArrayDestroy(mysa);
			pIVSCartesian->Release();
		}
	}

	else
		MessageBox(NULL, "WriteJointAngleHomePositions(). Object pointer could not be found", "Error::get_Pointers()",MB_OK);

	/**** PREVIOUS CONTROLLER OUTPUT VARIABLES ****/ 
	// If we have a dominant cartesian controller, we are working in cartesiana space, and want jointspace history values to be initialized to zero.
	if(m_sWhichIsDomController == DOMINANT_CARTESIAN_CONTROLLER)
	{
		m_dPreviousControllerOutput[0] =  m_dActualCartesian[0];
		m_dPreviousControllerOutput[1] =  m_dActualCartesian[1];
		m_dPreviousControllerOutput[2] =  m_dActualCartesian[2];
		m_dPreviousControllerOutput[3] =  m_dActualCartesian[3];
		m_dPreviousControllerOutput[4] =  m_dActualCartesian[4];
		m_dPreviousControllerOutput[5] =  m_dActualCartesian[5];
	}

	// If we have a subordinate controller, the member variable associated with the PreviousCartOutput is 0, but the joint variable history variable is set to the home position.
	else if(m_sWhichIsSubController == SUBORDINATE_CARTESIAN_CONTROLLER)
	{

		d_PreviousCartOutput[0] =  m_dActualCartesian[0];
		d_PreviousCartOutput[1] =  m_dActualCartesian[1];
		d_PreviousCartOutput[2] =  m_dActualCartesian[2];
		d_PreviousCartOutput[3] =  m_dActualCartesian[3];
		d_PreviousCartOutput[4] =  m_dActualCartesian[4];
		d_PreviousCartOutput[5] =  m_dActualCartesian[5];

		m_dPreviousControllerOutput[0] = Angle[0];
		m_dPreviousControllerOutput[1] = Angle[1];
		m_dPreviousControllerOutput[2] = Angle[2];
		m_dPreviousControllerOutput[3] = Angle[3];
		m_dPreviousControllerOutput[4] = Angle[4];
		m_dPreviousControllerOutput[5] = Angle[5];
	}
	
	// For all non-cartesian controllers
	else
	{
		m_dPreviousControllerOutput[0] = Angle[0];
		m_dPreviousControllerOutput[1] = Angle[1];
		m_dPreviousControllerOutput[2] = Angle[2];
		m_dPreviousControllerOutput[3] = Angle[3];
		m_dPreviousControllerOutput[4] = Angle[4];
		m_dPreviousControllerOutput[5] = Angle[5];

	}
}

STDMETHODIMP CControlBasis::get_AveragingWeight_JointAngles(double *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
		*pVal = alpha;
	return S_OK;
}

STDMETHODIMP CControlBasis::put_AveragingWeight_JointAngles(double newVal)
{
	// TODO: Add your implementation code here
	if(newVal >= 0 && newVal <= 1)
		alpha = newVal;
	return S_OK;
}

/********************************************************************************************************
* ComputeInverseKinematics()
* Several attempts of computing the HP3JC's IK were carried out.
* The base, shoulder, and elbow angles could be computed accurately
* but was unable to do the same with the wrist. The approach 
* followed were several, including the geometrical and algebraic
* approaches introduced in Sponge's et al. text. Also, Dr. Cook's
* derivation for an NR Robot were tried, and finally publicly available
* derivations for the PUMA560 robot were attempted without success.
*
* After trying Peter Corke's robotic toolkit in matlab, the wrist angles
* were identical with minor adjustments of adding/subtracting n*pi.
*
* Input to function: an XYZ cartesian position in mm.
*				   : an RPY (Euler angles) in radians.
* Output: a 1x6 array of doubles that represent the joint angles. This result is then going to be subtracted from
*		  the actual joint angles of the robot to compute an error and update the robot's joint angle position. 
*
* Calling MATLAB routines from C++.
* Matlab has an ENGINE that makes this simple. Please see matlab's documenation on external interfaces to learn how to configure the environment.
* Need to include libraries for the input option in project settings, need to add some dll's, need to include engine.h, need to change Window's Environment Variable: PATH.
*
* Mostly routines are called by passing the string name of the call and the
* variables. The other difference is that the matlab variables that receive
* and output information needs to be created as type: mxArray. 
* See below.
*
* The Matlab m-files that is called contains all the information necessary
* to compute the IKin's for the HP3JC. 
* Look at: O:\Components\ArmComponents\Matlab\Kinematics\HP3JC\Inverse Kinematics\Corke_IKin_HP3JC.m
*
* At the end the original code used to compute the IK was comented out.
* Oct. 2008
********************************************************************************************************/
int CControlBasis::ComputeInverseKinematics(double XYZRPY[6])
{

	// Copy the user input positions to the matlab mxArray variable
	memcpy((void *)mxGetPr(m_MatXYZRPY), (void *)XYZRPY, 6*sizeof(double));	
	// Copy the tooltype to the matlab mxArray
	memcpy((void *)mxGetPr(m_MatToolType), (void *)m_dToolType, sizeof(double));

	// Place the local variable "XYZRPY" into the MATLAB workspace "XYZRPY".
	// engPutVariable(Engine *ep, const char *name, const mxArray *pm);
	engPutVariable(ep, "XYZRPY", m_MatXYZRPY);											// You should be able to look up this variable in matlab.
	engPutVariable(ep, "ToolType", m_MatToolType);										// Place Tool Type in matlab variable
	
	// Evaluate the inverse kinematics call
	// int engEvalString(Engine *ep,const char *string);
	m_iRetVal = engEvalString(ep, "Q = Corke_IKin_HP3JC(XYZRPY, ToolType)");		// The Joint Angle result should also be visible in matlab.
	if(m_iRetVal != 0)
	{
		m_bstrError = SysAllocString(L"ComputeInverseKinematics:: engEvalString was not successful.");
		return !S_OK;
	}

	// Get the output variable. The function will create an mxArray* of the same name as the string character.
	// engGetVariable(Engine *ep, const char *name);
	m_MatJointAngles = engGetVariable(ep, "Q");

	// Copy matlab output over to C++ variable. Need to call mxGetPr, to get the result.
	memcpy((void *)XYZRPY, (void *)mxGetPr(m_MatJointAngles), 6*sizeof(double));

	// For the time being, we are going to do a little hack. The 3rd joint is around 96% of the actual value.
	// When we do actual value over obtained value we get an average of 1.3975.
	// Until we find the real deal...
	//XYZRPY[2] = XYZRPY[2]*0.40;// 0.40 is good when z changes. // 1.040 is good when x changes.

	return 0;

/****************************************************
* ComputeInverseKinematics()
* Inverse Kinematics equations in this function come from two aproaches.
* The goemetric approach and the algebraic approach. Given that no Inverse
* Kinematics are given for the HP3JC we have to compute them. However the slight
* differences between the robots do not lead to trivial derivations. Hence
* trying to use the best of both approaches. 
* 1) Geometric approach for q1 and q3.
* 2) Algebraic approach for q2, q4,5,6.
* Although the algebraic approach is used to compute q3 first and then q2. 
* The value of q3 is then replaced with the geometric approach.Inverse Kinematics Derivation
*
* Equations/images for the derivation can be found at: O:\Documentation\Component Description\Arm\Kinematics
*
*
* A couple of things have to happen before we actually computed the inverse kinematics:
* 1) We must subtract the length of d6 and the barret hand from the incoming desired coordinate. 
* 2) Formulate values for the R06 matrix from the desired orientation for the wrist, ie RPY angles. We do this through the RPY_2_R06() function.
*
* Remember that all angle computations result in radians.
****************************************************/

/*
	// Declaration of Variables
	// DH parameters
	double a2, a3, d3, d4, d6, a22, a32, d32, d42	= 0.0;

	// Link lengths
	double link2, link3, link22, link32				= 0.0;

	// Distances
	double x, y, z, x2, y2, z2, rho, rho2, R, R2	= 0.0;

	// Joint Angles
	double q1, q2, q3, q4, q5, q6, q23, q4_old		= 0.0;

	// Temporary local variables
	double K, K2, A, B, C							= 0.0;

	// Rotation elements in Rotation Matrix
	double r11, r12, r13, r21, r22, r23, r31, r32, r33, homogeneous_transformation_matrix[16];
	


	// Directions for Inverse Kinematics
	short DIRECTION = 1, ELBOW = 1;	// Computes direction for right/left shoulder. In fact this is irrelevant for the HP3JC b/c it's a symmetrical robot. But thought it would be appropriate to include as part of a formal derivation.
								// DIRECTION: 1 = left shoulder; -1 = right shoulder. 
								// ELBOW	: 1 = elbow up;      -1 = elbow down. 
	

	// ************* Operations necessary before continuing with Inverse Kinematics ********************
	// Implement computations necessary before doing the Inverse Kinematics.
	// 1) Compute the R06 Matrix.
	RPY_2_R06(XYZRPY, homogeneous_transformation_matrix);	
	
	// 2) Compute the P-point on the wrst
	ComputePPos(homogeneous_transformation_matrix);
	// ***************************************************************************************************

	// Initialization of DH Parameters	
	
	// Assign local r element values
	x =   homogeneous_transformation_matrix[3];
	y =   homogeneous_transformation_matrix[7];
	z =   homogeneous_transformation_matrix[11];

	r11 = homogeneous_transformation_matrix[0];
	r12 = homogeneous_transformation_matrix[1];
	r13 = homogeneous_transformation_matrix[2];
	r21 = homogeneous_transformation_matrix[4];
	r22 = homogeneous_transformation_matrix[5];
	r23 = homogeneous_transformation_matrix[6];
	r31 = homogeneous_transformation_matrix[8];	
	r32 = homogeneous_transformation_matrix[9];
	r33 = homogeneous_transformation_matrix[10];

	// Link 2
	a2  =  260.00;
	a3  =   29.98;
	link2 = a2 + a3;

	// //  For manipulator without offset between base joint and shoulder and elbow.
	d3 = 0.0;

	// Link 3
	d4  = -270.000; 
	d6  = 0; 				// This value not used. Info for p-point is all that is necessary. -244.503; From the p-point to the end of the barret hand.
	link3 = -(d4 + d6);
	
	// Cartesian Values


	// Joint Angles
	q1 = m_dDesired_Joint_Angles[0];
	q2 = m_dDesired_Joint_Angles[1];
	q3 = m_dDesired_Joint_Angles[2];
	q4 = m_dDesired_Joint_Angles[3];
	q5 = m_dDesired_Joint_Angles[4];
	q6 = m_dDesired_Joint_Angles[5];

	// Squared values
	link22 = pow(link2,2);
	link32 = pow(link3,2);

	x2 = pow(x,2);
	y2 = pow(y,2);
	z2 = pow(z,2);

	a22 = pow(a2,2);
	a32 = pow(a3,2);
	d32 = pow(d3,2);
	d42 = pow(d4,2);

	// Diagonal distances
	rho = sqrt(x2+y2);
	R   = sqrt(x2+y2+z2);
	rho2= pow(rho,2);
	R2 = pow(R,2);

		
	// Inverse Kinematics. 
	// Now perform the computations for the joint angles.

	// *****Joint Angle 1*****
	// Check for singularity case. If x==0, the set q1 to 0.
	if(x == 0)
		q1 = 0.0;

	else 
		q1 = atan2(y,x) - atan2( (d3/rho),DIRECTION*(sqrt(1 - (d32/rho2))));						// Algebraic approach
		 //m_dDesired_Joint_Angles[0] = atan2(m_dDomCont_DesInput[1],m_dDomCont_DesInput[0]);	// Geometric approach

	
    // *****Joint Angle 3 - Algebraic method - Used to compute q2*****      
    // Temporary variable used in derivation of q3.
    K = (x2+y2+z2-a22-a32-d32-d42)/(2*a2);
	K2 = pow(K,2);
    q3 = atan2(a3,d4) - atan2(K, ELBOW*sqrt(a32+d42-K2));
    
    // *****Joint Angle 2*****
    // Need to declare a couple of temporary variables as in slide 48 of the inverse kinematics presentation. The solutions depends on
    // values of theta1 and theta3
    A = (-a3-a2*cos(q3))*z+(cos(q1)*x+sin(q1)*y)*(a2*sin(q3)-d4);
    B = (a2*sin(q3)-d4)*z-(-a3-a2*cos(q3))*(cos(q1)*x+sin(q1)*y);
    
    // We can extract a common variable of q23 and then solve for q2
    q23 = atan2(A,B);
    q2 = q23 - q3;
    
    // With the algebraic approach the q3 result is not accurate. So we recomputed based on geometry.           
    // Compute the law of cosines
    C = acos( (R2 - link22 - link32)/(-2*link2*link3) );

    
    // Elbow up
    if(ELBOW == 1)       
        q3 = fabs(3.1416/2 - C);
        
    // Elbow down
    else
        q3 = fabs(3.1416/2*PI - C);
    

    //**********************************************
    //*  WRIST ANGLES accroding to Dr. Cook's class
    //**********************************************
    
    // The value for the following variables are computing in the
    // following way:
    // (LHS) R36 = (RHS) R(03)'*R06;
    // Then we equate the corresponding elements of the LHS with
    // elements in the RHS that help us solve for q4, q5, q6.
    
    // In summary, the joint angles are represented by:
    // q4 = atan2(s4s5,c4s5) = atan2(-r23c1+r13s1, r13c1c23+c2(r23c3s1+r33s3)+s2(r33c3-r23s1s3))
    // q5 = atan2(s5,c5)     = atan2(c4(c23(r13c1+r23s1)+r33s23)+s4(-r23c1+r13s1)),-r33c23+s23(r13c1+r23s1))
    // q6 = atan2(s6,c6)     = atan2(c4(-r21c1+r11s1))-(c23(r11c1+r21s1)+r31s23)s4,c4(-r22c1+r12s1)-(c23(r12c1+r22s1)+r32s23)s4)              

    // ***** Joint Angle 4*****       
    // Check for singularity. 
    // Singularity takes place when q5 = 0 or 180. This can be checked
    // when the two arguments of the atan2() function for q4 approach
    // zero. 
    // In such a case, we make q4 equal the value it had right before
    // the robot when into a singular configuration.         
    
    // atan2 variables:
    A = -r23*cos(q1)+r13*sin(q1);
    B = r13*cos(q1)*cos(q2+q3)+cos(q2)*(r23*cos(q3)*sin(q1)+r33*sin(q3))+sin(q2)*(r33*cos(q3)-r23*sin(q1)*sin(q3));
    
    // Singuarlity check
    if ((fabs(A) < 0.001) && (fabs(B) < 0.001))
        // If arguments are close to zero, keep the value before
        // reaching the singularity. We'll adjust q6 nex
        q4 = q4_old;
    else
        q4 = atan2(A, B);
    
	// Keep a history of old values
	q4_old = q4;
    
    // ***** Joint Angle 5*****
    // For motoman, the angle that would be home for the puma is -90.
    // Hence we have to make up for this disparity.
    q5 = -PI/2 + atan2(cos(q4)*(cos(q2+q3)*(r13*cos(q1)+r23*sin(q1))+r33*sin(q2+q3))+sin(q4)*(-r23*cos(q1)+r13*sin(q1)),-r33*cos(q2+q3)+sin(q2+q3)*(r13*cos(q1)+r23*sin(q1)));
    
    // ***** Joint Angle 6*****
    q6 = atan2(cos(q4)*(-r21*cos(q1)+r11*sin(q1))-(cos(q2+q3)*(r11*cos(q1)+r21*sin(q1))+r31*sin(q2+q3))*sin(q4),cos(q4)*(-r22*cos(q1)+r12*sin(q1))-(cos(q2+q3)*(r12*cos(q1)+r22*sin(q1))+r32*sin(q2+q3))*sin(q4));
    
	// Copy data to private members.
    m_dDesired_Joint_Angles[0] = q1* 180/PI;
	m_dDesired_Joint_Angles[1] = q2* 180/PI;
	m_dDesired_Joint_Angles[2] = q3* 180/PI;
	m_dDesired_Joint_Angles[3] = q4* 180/PI;
	m_dDesired_Joint_Angles[4] = q5* 180/PI;
	m_dDesired_Joint_Angles[5] = q6* 180/PI;
  */
}

/*******************************************************************
* SetRPYMatrix()
*
* In deriving the inverse kinematics, we need to obtain the values
* for the rotation matrix R06. This is our goal. To generate these
* values we convert given RPY values into the Rotation matrix.
* 
* Takes command vector in the form of: X Y Z  Rot X Rot Y  Rot Z
* Where the rotations are about the fixed base frame axes.
*******************************************************************/
void CControlBasis::RPY_2_R06(double RPY[6], double oM[16])
{
	double ca,cb,cg;		// Cosine arguments
	double sa,sb,sg;		// Sine arguments

	// Precompute Trig Functions to save on evaluations
	ca = cos(RPY[5]); sa = sin(RPY[5]);
	cb = cos(RPY[4]); sb = sin(RPY[4]);
	cg = cos(RPY[3]); sg = sin(RPY[3]);

	/* The following procedure is standard in converting roll-pitch-yaw angles into a 3x3 rotation matrix.
	 * You can look at Equation 2.38 of the Robot Modeling and Control by Spong et al book.
	 * Do a roll about x, a pitch about y, and a yaw about z.
	 * Since the rotations take place about a fixed frame, R is defined as follows:
	 * 
	 *   R = Rz(alpha)Ry(Beta)Rx(gamma) = 
	 *	 | ca -sa 0 || cB  0 sB || 1  0 0  |		| r11 r12 r13  Px|
	 *	 | sa ca  0 || 0   1  0 || 0 cy -sy| = oM = | r21 r22 r23  Py|	// See Robot Simulation by Dr. Cook page A-12
	 *   | 0   0  1 ||-sB  0 cB || 0 sy cy |		| r31 r32 r33  Pz|
	 *												|   0   0   0   1|
	 */


	// First Column
	oM[0] = ca*cb;					// r11
	oM[1] = sa*cb;					// r21
	oM[2] = -sb;					// r31
	oM[3] = 0.0;					// r41

	// Second Column
	oM[4] = ca*sb*sg - sa*cg;		// r12
	oM[5] =	sa*sb*sg + ca*cg;		// r22
	oM[6] =	cb*sg;					// r32
	oM[7] = 0.0;					// r42
	
	// Third Column
	oM[8] = ca*sb*cg + sa*sg;		// r13
	oM[9] = sa*sb*cg - ca*sg;		// r23
	oM[10] = cb*cg;					// r33
	oM[11] = 0.0;					// r43

	// Fourth Column -  position vector.
	oM[12] = RPY[0];				// X	
	oM[13] = RPY[1];				// Y
	oM[14] = RPY[2];				// Z
	oM[15] = 1.0;
}

/*****************************************************
* ComputePPos()
* Computes the position of the P-point, ie the wrist
* from the end-effector position.
*
* Inputs: RPY[6] which contains the desired XYZ and RPY values
*		  oM[16] which contains the homogeneous transformation which includes the rotation matrix
*
* Outputs:PPoint[3] which is the newly computed position for the wrist.
*
* This is done by extracting the distance d6*Rz from 
* the wrist. Note that we are multiplying d6 times the
* z-element of the rotation matrix given that the 
* is pointing in the z-direction of the joint.
*****************************************************/
void CControlBasis::ComputePPos(double oM[16])
{
	// Initialize
    // DH Parameters d6 for the Motoman HP3JC robot.
    // This number includes the distance from the P-point to the wrist ( -90)  and then the length of the barrett hand (-144.5).
    double d6 = -244.5; 

	// Compute the new updated position
    // Subtract from the wrist position the distance d6 x the z-element of the
    // rotation matrix, R06.

	oM[3]  = oM[3]  - d6*oM[2];  // The index for oM, basically selects two sets of elements: 
	oM[7]  = oM[7]  - d6*oM[6];  // 1) X, Y, Z, which are elements 3, 7, and 10 and
	oM[11] = oM[11] - d6*oM[10]; // 2) elements 2, 6, and 10 which correspond to Rzx, Rzy, Rzz of the R06 rotation matrix.
}


/************************************************************
* get_ToolType()
* get_ToolType
* Determines whether we have mounted:
* 0: Nothing on the HP3JC
* 1: Barret hand
* 2: The Assembly tool (barret hand + extension stick)
************************************************************/
STDMETHODIMP CControlBasis::get_ToolType(BSTR *pVal)
{
	if(pVal != NULL)
	{
		if (*m_dToolType == 0)
			*pVal = SysAllocString(L"EMPTY");
		if (*m_dToolType == 1)
			*pVal = SysAllocString(L"BARRET");
		if (*m_dToolType == 3)
			*pVal = SysAllocString(L"ASEEMBLY");
	}

	return S_OK;
}

STDMETHODIMP CControlBasis::put_ToolType(BSTR newVal)
{
	USES_CONVERSION;

	// make lower case letters before comparing
	if(strcmp(_strupr(OLE2T(newVal)),"EMPTY")==0)
	{
		*m_dToolType = EMPTY;
		m_bstrError = SysAllocString(L"No tool was selected for the end-effector.");
		
		return S_OK;
	}

	if(strcmp(_strupr(OLE2T(newVal)),"BARRET")==0)
	{
		*m_dToolType = BARRET;
		m_bstrError = SysAllocString(L"The Barret Hand tool was selected for the end-effector.");
		
		return S_OK;
	}

	if(strcmp(_strupr(OLE2T(newVal)),"ASSEMBLY")==0)
	{
		*m_dToolType = ASSEMBLY;
		m_bstrError = SysAllocString(L"The Assembly tool was selected for the end-effector.");
		
		return S_OK;
	}

	else
	{
		*m_dToolType = EMPTY;
		m_bstrError = SysAllocString(L"Please selected EMPTY or BARRET or ASEEMBLY.");
		
		return S_OK;
	}
}

//***********************************************************************************//
// CheckError()
//
// This function looks at the error produced by a function. Based on a given threshold 
// different forms of action are taken later:
/*
/* (1) For the Cart_MF combined sequence:
/*     The first controller is the cartesian controller. We want to transition to the MF
/*     controller when the error is BELOW a certain threshold.
/*     If the threshold is reached, then the SM machine is sent a signal = "Next".
/*
/* (2) Then the MF controller is activated. At this point in time the insertion point
/*     is still in the air and approaching entry point. During this course of the process
/*	   we used reference values for desired force of DES_FX AND DES_FZ.
/*
/*	   Once the insertion point is reached we want to make DES_FS = 1 and DES_FZ = 0.
/*	   The transition takes place when there is a first measure of moment data. So, 
/*	   as opposed to the Cartesian controller transition in this case we want to change
/*	   the reference values when an error greater than THRESHOLD is recorded.
//***********************************************************************************/
void CControlBasis::CheckError()
{
	// Local variables
	int THRESHOLD_CART  = 2;
	int THRESHOLD_MF	= 2;
	int THRESHOLD		= 0;

	SAFEARRAY       *mysa;
	IVectorSignal	*pIVSCumError;
	IStateMachine	*pIStateMachine;
	IVectorSignal   *pIVSSubDesInput;
	/******************************************** ACCUMULATE ERROR ****************************************************/
	// Reset the error each time to avoid accumulation. The error for the controllers is computed anew each iteration.
	CumulativeError = 0;

	// (1) We will measure if one controller has reached its basin of attraction if its error is ~ 0.
	// The threshold is chosen empirically and can be changed upon further experimentation.
	for(int i=0; i<NUM_AXES; i++)
		CumulativeError += fabs(m_dDomCont_Error[i]);		
	
	// Print to debut output mode
	ATLTRACE("\nCumulative Error = %d\n", CumulativeError);

	// (2) Send Cumulative Error to VS
	// Get pointer for the object
	m_Bindings->get_Pointers(SysAllocString(L"CumulativeError"),&m_pIUnkCumError);	
	if(m_pIUnkCumError != NULL)	
	{
		// Get pointer for the interface
		m_pIUnkCumError->QueryInterface(IID_IVectorSignal,(void **)&pIVSCumError);
		if(pIVSCumError != NULL)
		{
			mysa = SafeArrayCreateVector(VT_R8,0,1);
			memcpy(mysa->pvData,&CumulativeError, sizeof(double));
			pIVSCumError->SetCurrentVector(mysa);
			pIVSCumError->Release();
		}
	}

	else
	{
		ATLTRACE("CheckError(). Object pointers could not be found", "Error::get_Pointers()");
		pIVSCumError = NULL;
	}
			
	/******************************************* RESULTING ACTIONS ************************************************/

	// CARTESIAN CONTROLLER
	if(m_sWhichIsDomController == DOMINANT_CARTESIAN_CONTROLLER && bCartesianFlag == 1) // The flag tells us we have a valid cartesian position
	{
		// CartController" If the sum of the errors is less than our threshold, then send the SM signal
		if(CumulativeError < THRESHOLD_CART)
		{
			// (3)  Send signal to the state machine	
			// Get pointer for the state machine object
			m_Bindings->get_Pointers(SysAllocString(L"_StateMachine"),&m_pIUnkCumError);	
			if(m_pIUnkCumError != NULL)	
			{
				// Get pointer for the interface
				m_pIUnkCumError->QueryInterface(IID_IStateMachine,(void **)&pIStateMachine);
				if(pIStateMachine != NULL)
				{
					pIStateMachine->Signal(SysAllocString(L"Next"));
					pIStateMachine->Release();
				}

				else
					pIStateMachine = NULL;			
			}
		}
	}

	// MOMENT CONTROLLER
	if(m_sWhichIsDomController == DOMINANT_MOMENT_CONTROLLER)
	{		
		// If error is greater proceed
		if(CumulativeError > THRESHOLD_MF)
		{
			// Set our reference value to new values
			//m_dFTReferenceValue[0] = Des_Fx_Insert;
			//m_dFTReferenceValue[1] = Des_Fy_Insert;
			//m_dFTReferenceValue[2] = Des_Fz_Insert;
			// The rest of the values are initialized to zero

			// Set the DesiredForce (Subordinate controller in the MF controller) reference values
			// (1) Get dominant vector data. Get (a) object pointers, (b) interface pointers, (c) VS data.
			m_Bindings->get_Pointers(SysAllocString(L"SubCont_DesiredInput"), &m_pIUnkSubCont_DesInput);
			if(m_pIUnkSubCont_ActualInput != NULL)
			{
				// (b) Get Interface pointers
				m_pIUnkSubCont_DesInput->QueryInterface(IID_IVectorSignal, (void **)&pIVSSubDesInput);

				// (c) Desired VS Data
				if(pIVSSubDesInput != NULL)	
				{
					mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
					memcpy(mysa->pvData,m_dFTReferenceValue,sizeof(double)*NUM_AXES);
					pIVSSubDesInput->SetCurrentVector(mysa);
					SafeArrayDestroy(mysa);
					pIVSSubDesInput->Release();
				}
			}

			else
				ATLTRACE("CheckError-MomentController. Object pointer could not be found", "Error::get_Pointers()");
		}
	}	
}

/**************************************************************/
/* Close()
/*
/* This function is called after an experiment is done.
/* It will move the HP3JC in a backwards direction, in a very slow
/* manner to try to free itself up from a particluar insertion.
/*
/* To do so, it will set the HP3JC DesXYZ Vector, which is the 
/* Des_DomCont for the Cartesian Controller, to a value of {-10,0,0,0,0,0}
/* which is 1cm, and then call move_Incremental()
/**************************************************************/
STDMETHODIMP CControlBasis::Close()
{
	// Local Variables
	double tempBuff[NUM_AXES]={-1,0,0,0,0,0};
	
	SAFEARRAY     *mysa;
	IVectorSignal *pIVSXYZ;
	IHP3JC        *pIHP3JC;

	// (1) Get dominant vector data. Get (a) object pointers, (b) interface pointers, (c) VS data.
	m_Bindings->get_Pointers(SysAllocString(L"DomCont_Output"), &m_pIUnkDomCont_Output);
	m_Bindings->get_Pointers(SysAllocString(L"HP3JC"),           &m_pIUnkHP3JC);
	if(m_pIUnkDomCont_Output != NULL || m_pIUnkHP3JC != NULL)
	{
		// (b) Get Interface pointers
		m_pIUnkDomCont_Output->QueryInterface(IID_IVectorSignal, (void **)&pIVSXYZ);
		m_pIUnkHP3JC->QueryInterface(IID_IHP3JC,                 (void **)&pIHP3JC);

		// (c) Set data in the VS
		if(pIVSXYZ != NULL)	
		{
			mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
			memcpy(mysa->pvData,tempBuff,sizeof(double)*NUM_AXES);
			pIVSXYZ->SetCurrentVector(mysa);
			SafeArrayDestroy(mysa);
			pIVSXYZ->Release();

			if(pIHP3JC != NULL)
			{
				// Call Incremental move 100 times x 0.1cm
				for(int i=0;i<75; i++)
				{
					pIHP3JC->move_Incremental();
					Sleep(100);
				}
				pIHP3JC->Release();
			}
		}
	}

	else
		MessageBox(NULL, "Close() Error. Object pointers could not be found", "Error::get_Pointers()",MB_OK);

	Reset();

	return S_OK;
}

// Resets all variables so that the component can be called again after it has been executed.
void CControlBasis::Reset()
{
	int i,j;

	// Controller Vectors
	for(i = 0; i<NUM_AXES; i++)
	{
		// Dominant Controllers
		m_dDomCont_DesInput[i] = m_dDomCont_ActualInput[i] = m_dDomCont_Error[i] = m_dDomCont_Output[i] = m_dPreviousControllerOutput[i] = m_dAveragedOutput[i] = 0.0;

		// Subordinate Controllers
		m_dSubCont_DesInput[i] = m_dSubCont_ActualInput[i] = m_dSubCont_Error[i] = m_dSubCont_Output[i] = 0.0;

		// Other Matrices
		m_dNullSpaceProjectionOutput[i] = 0.0;
		m_dCompositeControllerOutput[i] = 0.0;
		m_dDesired_Joint_Angles[i]		= 0.0;

		// Cartesian matrices
		d_AverageOutputCart[i]			= 0.0;
		d_PreviousCartOutput[i]			= 0.0;
		m_dDesiredXYZRPY[i]				= 0.0;
		m_dActualCartesian[i]			= 0.0;
		m_dFTReferenceValue[i]			= 0.0;
	}

	// Reference Value Index
	m_sFTReferenceValueIndex = 0;

	// Null Space Projected Vector
	for(i=0;i<NUM_AXES;i++)
	{
		for(j=0;j<NUM_AXES;j++)	
		{
			// Initialize the identity matrix, with a diagonal of 1's
			if(i==j)
				eye[i][j] = 1.0;
			else
				eye[i][j] = 0.0;
		
			// Zero the null_space projection matrix
			m_dNullSpaceProjectionMatrix[i][j] = 0.0;
		}
	}

	// Indeces

	// Gains
	m_sPositionGainIndex		= 0;
	m_sForceGainIndex			= 0;
	m_sMomentGainIndex			= 0;
	m_sIKinGainIndex			= 0;

	// Dominant Controllers
	m_sDomCont_DesInputIndex = m_sDomCont_ActualInputIndex = m_sDomCont_OutputIndex = 0;

	// Subordinate Controllers
	m_sSubCont_DesInputIndex = m_sSubCont_ActualInputIndex = m_sSubCont_OutputIndex = 0;

	// Jacobian
	// Angles
	for (i = 0; i<NUM_AXES; i++)
		Angle[i] = 0.0;

	// File
	stream = NULL;

	// Timing Variables
	ticksPerSecond.QuadPart	= 0;
	start_ticks.QuadPart	= 0;
	end_ticks.QuadPart		= 0;
	sample_time				= 0.0;

	// CumulativeError
	CumulativeError = 0;

	// Finally, set the cartesian flag back to zero. This allows us to restart the function calling without having to destroy the component.
	bCartesianFlag = 0;

}
