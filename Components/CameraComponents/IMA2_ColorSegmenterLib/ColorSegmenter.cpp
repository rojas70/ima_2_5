////////////////////////////////////////////////////////////
// ColorSegmenter.cpp : Implementation of CColorSegmenter //
//														  //
// The class can segment an incoming image either based on//
// the LUV color model or another technique called RGNorm //
// Its input/output images are obtained/delivered  via    //
// an ImageRep interface. The segmented output image has  //
// features that can be activated/deactivaed			  //
////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "IMA2_ColorSegmenterLib.h"
#include "ColorSegmenter.h"
#include "math.h"
#include "string.h"
/////////////////////////////////////////////////////////////////////////////
// CColorSegmenter

///////////////////////////////
// Get/Put Interface Methods //
///////////////////////////////

////////////////////////////////
// Draw a box around the image
////////////////////////////////
STDMETHODIMP CColorSegmenter::get_display_CrossMarker(BOOL * pVal)
{
	// TODO: Add your implementation code here
	*pVal = m_bDrawCrossMarker;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_display_CrossMarker(BOOL newVal)
{
	// TODO: Add your implementation code here
	m_bDrawCrossMarker = newVal;
	return S_OK;
}


STDMETHODIMP CColorSegmenter::get_CIEWhitePointX(float * pVal)
{
	// TODO: Add your implementation code here
	*pVal=m_fXn;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_CIEWhitePointX(float newVal)
{
	// TODO: Add your implementation code here
	m_fXn=newVal;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::get_CIEWhitePointY(float * pVal)
{
	// TODO: Add your implementation code here
	*pVal=m_fYn;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_CIEWhitePointY(float newVal)
{
	// TODO: Add your implementation code here
	m_fYn=newVal;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::get_CIEWhitePointZ(float * pVal)
{
	// TODO: Add your implementation code here
	*pVal=m_fZn;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_CIEWhitePointZ(float newVal)
{
	// TODO: Add your implementation code here
	m_fZn=newVal;
	return S_OK;
}

////////////////////////////////////////////////////////////////
// Used to type the path of the folder that contains that data 
// for segmentation. This data is automatically generated by a
// program that was created in-house called ColorModeller.
// It can be found in I:\ drive.
////////////////////////////////////////////////////////////////
STDMETHODIMP CColorSegmenter::get_ColorModelFileName(BSTR * pVal)
{
	*pVal = SysAllocString(m_sColorModelFileName);
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_ColorModelFileName(BSTR newVal)
{
	SysReAllocString(&m_sColorModelFileName,newVal);

	return S_OK;
}

//////////////////////////////////////////////////////
// Automatically loaded when color model is loaded.
// Used to inform the user in a more intuitive way.
//////////////////////////////////////////////////////
STDMETHODIMP CColorSegmenter::get_ColorModelName(BSTR * pVal)
{
	*pVal = m_csColorModelName.Copy();	
	return S_OK;
}

STDMETHODIMP CColorSegmenter::get_ColorModelType(BSTR * pVal)
{
	*pVal = m_sColorModelType.Copy();	
	return S_OK;
}

//////////////////////////////////////////////////////////////
// If activated it does an Open and Close Image Processing
// manipulation on the image to create a smoother blob. It 
// helps improve performance due to the effects of noise and
// constantly changing input image.
//////////////////////////////////////////////////////////////
STDMETHODIMP CColorSegmenter::get_display_FilterOutputImage(short * pVal)
{
	// TODO: Add your implementation code here
	*pVal = m_sFilterOutput;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_display_FilterOutputImage(short newVal)
{
	// TODO: Add your implementation code here
	m_sFilterOutput = newVal;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::get_LuminenceLowerLimit(float * pVal)
{
	// TODO: Add your implementation code here
	*pVal=m_nLLimit;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_LuminenceLowerLimit(float newVal)
{
	// TODO: Add your implementation code here
	m_nLLimit=newVal;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::get_LuminenceUpperLimit(float * pVal)
{
	// TODO: Add your implementation code here
	*pVal=m_nULimit;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_LuminenceUpperLimit(float newVal)
{
	// TODO: Add your implementation code here
	m_nULimit = newVal;
	return S_OK;
}

//////////////////////////////////////////////////////////////////
// One can manually change the No. of Std. Devs in order to 
// increase/decrease the effects of the segmentation.
// If the number is increased more of the image will be segmented.
// It's intended to be used in run-time.
//////////////////////////////////////////////////////////////////
STDMETHODIMP CColorSegmenter::get_seg_NumOfStdDevs(float * pVal)
{
	// TODO: Add your implementation code here
	*pVal=m_fLambda;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_seg_NumOfStdDevs(float newVal)
{
	// TODO: Add your implementation code here
	if(newVal > 0.0f)
		m_fLambda = newVal;

	return S_OK;
}



/////////////////////////////////////////////////////////
// Skips the number of pixels indicated. It is useful
// to reduce noise in a picture. The segmented image
// will pick up the coarser details in the image.
/////////////////////////////////////////////////////////
STDMETHODIMP CColorSegmenter::get_seg_SkipPixels(short * pVal)
{
	*pVal = SkipX;

	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_seg_SkipPixels(short newVal)
{
	// Only accept values for skip of 1, 2, 4.
	if(newVal == 1 || newVal == 2 || newVal == 4) 
	{		
		Lock();
		SkipX = newVal;
		SkipY = newVal;
		Unlock();
	}

	return S_OK;
}

////////////////////////////////////////////////////////////////
// The window properties serve to indicate the characteristics
// of the image. Normally untouched.
////////////////////////////////////////////////////////////////
STDMETHODIMP CColorSegmenter::get_WindowHeight(short * pVal)
{
	// TODO: Add your implementation code here
	*pVal = WindowHeight;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_WindowHeight(short newVal)
{
	// TODO: Add your implementation code here
	if(newVal <= ImageHeight) {
		WindowHeight = newVal;
		//Initial();
		WindowTop = (ImageHeight-WindowHeight)/2;
	}
	return S_OK;
}

STDMETHODIMP CColorSegmenter::get_WindowLeft(short * pVal)
{
	// TODO: Add your implementation code here
	*pVal = WindowLeft;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_WindowLeft(short newVal)
{
	// TODO: Add your implementation code here
	if(newVal + WindowWidth <= ImageWidth)
	 WindowLeft = newVal;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::get_WindowTop(short * pVal)
{
	// TODO: Add your implementation code here
	*pVal = WindowTop;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_WindowTop(short newVal)
{
	// TODO: Add your implementation code here
	if(newVal + WindowHeight <= ImageHeight)
	 WindowTop = newVal;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::get_WindowWidth(short * pVal)
{
	// TODO: Add your implementation code here
	*pVal = WindowWidth;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_WindowWidth(short newVal)
{
	// TODO: Add your implementation code here
	if(newVal <= ImageWidth) {
	 WindowWidth = newVal;

	 WindowLeft = (ImageWidth-WindowWidth)/2;
	}
	return S_OK;
}


STDMETHODIMP CColorSegmenter::get_seg_NumSegmentedPixels(double *pVal)
{
	// TODO: Add your implementation code here
	*pVal = m_dNoSegmentedPixels;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_seg_NumSegmentedPixels(double newVal)
{
	// TODO: Add your implementation code here
	m_dNoSegmentedPixels = newVal;
	return S_OK;
}

/*************************************************************************
/* filt_StdDevGain();
/* 
/* Used to filter noise from the region outside the centroid of the blob
/* defined as mean +/- filt_StdDevGain*StdDev
/* See DoSegment() for it's use.
*************************************************************************/
STDMETHODIMP CColorSegmenter::get_filter_StdDevGain(double *pVal)
{
	*pVal = filt_StdDevGain;

	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_filter_StdDevGain(double newVal)
{
	if(newVal > 0)
		filt_StdDevGain = newVal;
	
	return S_OK;
}


///////////////////////////////
// Callable Methods          //
///////////////////////////////

/************************************************************************
/* DoCenteringObject(ObjectCenterX, ObjectCenterY, SegmentedImage)
/* 
/* 1) Compute the total number of segmented pixels
/* 2) Compute the statistical parameters (median, mean, std. dev).
/* 3) Use statistical parameters to further filter the image from noise
/* 4) Use the median to compute the centroid of the image
/* 5) Draw a cross at the center of the segmented blob and at the center of the image 
***********************************************************************/
HRESULT CColorSegmenter::DoCenteringObject(int * x, int * y, BYTE * pbDataIn)
{
	// Local Variables
	//IVectorSignal	*pIVS;
	//SAFEARRAY		*mysa;

	int rowsize		= m_pHeaderOut.biWidth;
	int pixeldepth	= m_pHeaderOut.biBitCount/8;	// RGB image = 24, monochrome = 1.
	int colsize		= abs(m_pHeaderOut.biHeight);

	// Counters
	int lSumX		= 0;
	int lSumY		= 0;
	int lCount		= 0;
	int lMedian		= 0;
	long lCountBuff = 0;
	int index,i,j;

	// Buffers
	double buff		= 0.0;
	double x_buff	= 0.0;
	double y_buff	= 0.0;
	double x_stddev_buff = 0.0;
	double y_stddev_buff = 0.0;

	/***** 1) Compute Segmented Pixels  *****/
	// This loop computes the total number of segmented pixels, as well as number of pixels segmented in the x and y directions.
	for(i=0; i<WindowHeight/SkipY; i++) 
	{
		for(j=0; j<WindowWidth/SkipX; j++) 
		{
			index = (i*rowsize+j)*pixeldepth;
			
			// If we have a segmented pixel increase the counters
			if(pbDataIn[index] > 0) 
			{
				lCount++;					// Tot. no. of segmentedpixels
				x_buff+=j;					// X counter
				y_buff+=i;					// Y counter
			}				
		}
	}

	// Save the number of pixels that have been segmented
	// Could be used to detect if a reliable object has been found.
	m_dNoSegmentedPixels = (double)lCount;

	// Send m_dNoSegmentedPixels to a VectorSignal
	// Connect to object and interface
	/*	
	m_Bindings->get_Pointers(SysAllocString(L"NumSegmentedPixels"),&m_pIUnkNumSegmentedPixels);
	if(m_pIUnkNumSegmentedPixels != NULL)
	{
		m_pIUnkNumSegmentedPixels->QueryInterface(IID_IVectorSignal, (void **)&pIVS);
		if(pIVS != NULL)
		{
			 mysa=SafeArrayCreateVector(VT_R8,0,1);
			 memcpy(mysa->pvData,&m_dNoSegmentedPixels,sizeof(double)*1);
			 pIVS->SetCurrentVector(mysa);									// Set NumSegmentedPixels to the first index always
			 SafeArrayDestroy(mysa);									// Sometimes this value will come from different components: i.e. colorBarney, colorRed, colorBlue...

			 pIVS->Release();	
		}

		else
			pIVS->Release();
	}
	*/
	/***** 2) Compute Statistical Parameters  *****/
	// Compute the mean values and standard deviations for 
	// the position of the X-centroid and the Y-centroid. Mean of blob in x,y 
	if(lCount != 0)
	{
		// Compute the Mean
		x_Mean = x_buff/lCount;
		y_Mean = y_buff/lCount;

		// Compute the Standard Deviation, where Std Dev = sqrt{ mean[ (val - mean)^2 ] }
		for(i=0; i<WindowHeight/SkipY; i++) 
		{
			for(j=0; j<WindowWidth/SkipX; j++) 
			{
				index = (i*rowsize+j)*pixeldepth;
		
				if(pbDataIn[index] > 0) 
				{
								
					buff = (x_Mean-j);				// Difference between X and mean
					x_stddev_buff+=buff*buff;		// Square quantity

					buff = (y_Mean-i);
					y_stddev_buff+=buff*buff;
				}				
			}
		}

		// Finalize the computation of the std dev.
		x_StandardDev = sqrt(x_stddev_buff/lCount);	// Compute the square root of the mean
		y_StandardDev = sqrt(y_stddev_buff/lCount);


		// Compute the median: total sample / 2.
		lMedian = lCount/2;	
		
		/***** 3) Further Filtering  *****/
		// We can use these statistical parameters to erase any segmented pixels outside the area around the mean values.
		// We will erase any pixels outside a region of mean +/- 2xStandard Deviations
		for(i=0; i<WindowHeight/SkipY; i++) 
		{
			// For regions outside the Y_mean +/- Y_StdDev
			if(  (i <= (y_Mean - filt_StdDevGain*y_StandardDev))  || (i >= (y_Mean + filt_StdDevGain*y_StandardDev))   )
			{
				for(j=0; j<WindowWidth/SkipX; j++) 
				{
					// For regions outside the X_mean +/- X_StdDev
					if( (j <= (x_Mean - filt_StdDevGain*x_StandardDev)) || (j >= (x_Mean + filt_StdDevGain*x_StandardDev))   )
					{
						// For these areas compute the index
						index = (i*rowsize+j)*pixeldepth;

						// Zero out the selected pixel
						pbDataIn[index] = 0;
					}
				}

			}
		}

	}

	// Otherwise the mean, std. dev. and Blob area = 0.
	else
	{
		x_Mean = y_Mean = 0.0;

		// Also the std. deviation which is computed next
		x_StandardDev = y_StandardDev = 0.0;
	
		// Return number of blob's pixels
		BlobArea = 0;

		// Median is 0
		lMedian = 0;

	}


	/***** 4) Compute Centroid *****/
	// Check to see that the median is not zero:
	// Traverse the segmented image until the middle of the segmented number of pixels is reached.
	if(lMedian != 0)
	{
		for(i=0; i<WindowHeight/SkipY; i++) {
			for(j=0; j<WindowWidth/SkipX; j++) {
				index = (i*rowsize+j)*pixeldepth;

				// If pixel is segmented, find the row and column where the middle point is.
				if(pbDataIn[index] > 0) 
				{
					if(lCountBuff != lMedian) 
						lCountBuff++;
			
					 else // We have found the row where the middle of the blob is
					 {										
						*y		= i*SkipY;	// This is the Y-center point. This value is returned by this function.
						lSumY	= i;
						goto herex;			// Now compute the middle column (X-value).
					 }	
				}
			}
		}


		herex:

			// Reset counter
			lCountBuff = 0;

			// Traverse image
			for(j=0; j<WindowWidth/SkipX; j++) {
				for(i=0; i<WindowHeight/SkipY; i++) {
					index = (i*rowsize+j)*pixeldepth;

					// If pixel is segmented, find the row and column where the middle point is.
					if(pbDataIn[index] > 0) 
					{
						if(lCountBuff != lMedian) 
							lCountBuff++;
						 
						else
						{
								*x    = j*SkipX;	// This is the X-center point. This value is also returned by this function.
								lSumX = j;
						 }					
					}
				}
			}
	}

	else
	{
		// Zero out the centroid position and buffers
		*x = *y = 0;
		lSumX = 0;
		lSumY = 0;
	}


	/***** 5) Draw Cross markers  *****/
	if(m_bDrawCrossMarker) 
	{

		// First draw lines that cut through the center of the segmented blob
		// Column: vertical
		for(i=0; i<WindowHeight/SkipY;i++) 
		{
			index=(i*rowsize+lSumX)*pixeldepth;
			pbDataIn[index]   = (BYTE)200;
		}

		// Row: horizontal
		for(j=0; j<WindowWidth/SkipX;j++) 
		{
			index=(lSumY*rowsize+j)*pixeldepth;
			pbDataIn[index]   = (BYTE)200;
		}

		// Second draw a small cross marker that points the center of the image
		// Draw vertical marker
		// Set the intensity value to 128
		for(i=m_iImageCenterY-15; i<m_iImageCenterY+15;i++) 
		{
			index=(i*rowsize+m_iImageCenterX)*pixeldepth;
			pbDataIn[index]   = (BYTE)128;
		}

		// Draw horizontal marker
		// Set the intensity value to 128
		for(j=m_iImageCenterX-15; j<m_iImageCenterX+15;j++) 
		{
			index = (m_iImageCenterY*rowsize+j)*pixeldepth;
			pbDataIn[index]   = (BYTE)128;
		} 
	}
	return S_OK;
}

/*******************************************************************************
// DoSegment 
* 1) Check to see if component has been initialized
* 2) Check to see if color model has been loaded
* 3) Get input image
* 4) Do segmentation
* 5) Compute the center of the blob			
/********************************************************************************/
STDMETHODIMP CColorSegmenter::DoSegment()
{
	// Local variables
	int i;
	HRESULT hRes;
	long	lIn, lOut;				// Image data buffers
	IImageRep*	pImgIn = NULL;
	IImageRep*	pImgOut = NULL;


	// Check to see if user has Initialized routine
	if(m_bInitialFlag == FALSE) 
	{
		Initialize();
		m_bInitialFlag = TRUE;
	}

	// If the ColorModel has been loaded, do the segmentation
	if(m_bColorModelReady == TRUE) 
	{

		// Get object pointers to input and output image representations
		m_Bindings->get_Pointers(SysAllocString(L"InputImage"),&m_pIUnkImgIn);
		m_Bindings->get_Pointers(SysAllocString(L"OutputImage"),&m_pIUnkImgOut);

		if(m_pIUnkImgIn==NULL || m_pIUnkImgOut == NULL)
			return !S_OK;	
		
		// Get interface pointer to the input and output image representations
		m_pIUnkImgIn->QueryInterface(IID_IImageRep,(void **)&pImgIn);
		m_pIUnkImgOut->QueryInterface(IID_IImageRep,(void **)&pImgOut);
		// Check pointers to the interface
		if( pImgIn == NULL || pImgOut == NULL)			
			return !S_OK;

		// Get input image data
		pImgIn->Data( 0, &lIn );	// Place data in lIn
		InputImage=(BYTE*)lIn;		// Cast from long to BYTE* (which is the image type).

		// Prepare output image data
		// Allocate memory for the output image and place it lOut.
		OutputImage = new BYTE[(WindowHeight/SkipY)*(WindowWidth/SkipX)];
		lOut=(long)OutputImage;

		// Compute the segmentation depending on what color model it is 
		// (1) RGNorm
		// (2) LUVSegment
		switch(m_iColorModelType)
		{
		 case 0: RGNormSegment(InputImage,OutputImage);
				 break;
		 case 1: LUVSegment(InputImage,OutputImage);
				 break;
		}

	// Filter image output from noise using IPL methods.
	if(m_sFilterOutput == 1)		// Flag
		FilterOutput(lOut,lOut);

	// Compute the centroid and draw a cross marker around the center
	DoCenteringObject(&m_iObjectCenterX,&m_iObjectCenterY,OutputImage);

	// Draw a border around the image
	DrawBorder(WindowLeft,WindowTop,WindowWidth,WindowHeight,3,InputImage);

		// Get the difference in position between center of object and center of image.
		WindowLeft += m_iObjectCenterX-(WindowWidth/(2));
		WindowTop  += m_iObjectCenterY-(WindowHeight/(2));
		
		if(WindowLeft < 0)
			WindowLeft = 0;
		if(WindowLeft >= ImageWidth-WindowWidth)
			WindowLeft = ImageWidth-WindowWidth;
		if(WindowTop < 0)
			WindowTop = 0;
		if(WindowTop >= ImageHeight-WindowHeight)
			WindowTop = ImageHeight-WindowHeight;

		// If the segmented blob is greater than a threshold (or not zero), then normalize the output.
		if(m_dNoSegmentedPixels > m_lBlobArea)
		{
			/** Normalize output ***/
			// Result is a value from 0.0 to 1.0
			m_dCentroidVector[0] = (double)(m_iObjectCenterX+WindowLeft)/ImageWidth;
			m_dCentroidVector[1] = (double)(m_iObjectCenterY+WindowTop) /ImageHeight;
		}
		
		else
		{
			m_dCentroidVector[0] = 0.0f;
			m_dCentroidVector[1] = 0.0f;
		}

		// Averaging:
		// Actual and Previous Centroid Values for the right and the left centroid.
		for(i=0; i<2; i++)
		{
			// Filtering:
			// The averaging also filters values that change dramatically. These changes often represent noise in the color segmentation.
			// If, the new value is greather than a threshold, beta, keep the previous value.					  
			/*if(m_bCentroidFlag == false)
			{
				m_dAveragedCentroidVector[i] = m_dCentroidVector[i];
				m_bCentroidFlag = true;
			}
			

			else if(m_dCentroidVector[i] - m_dPreviousCentroidVector[i] > m_dBeta)
			{
				m_dCentroidVector[i] = m_dPreviousCentroidVector[i];
			}
			*/
			// Combine current and previous values by a factor of alpha or 1-alpha.
			m_dAveragedCentroidVector[i] = (1 - m_dAlpha) * m_dPreviousCentroidVector[i] + m_dAlpha * m_dCentroidVector[i];
			m_dPreviousCentroidVector[i] = m_dAveragedCentroidVector[i];
		}

		// Pass the centroid information to the Vector Signal
		hRes = SetCentroid(m_dAveragedCentroidVector);
		if(hRes!=S_OK) MessageBox(NULL,"Error writing to Centroid Vector Signal","Error",MB_ICONERROR);
		
		// *** OUTPUT IMAGE *** 
		// Pass/display output image data to/in output image representation
		pImgOut->Update(OutputImage);

		// Free allocated Memory
		delete OutputImage;

		// Deallocate dynamic memory
		pImgIn->Release();	
		pImgOut->Release();		
	}
	
	else 
	{		// color model not loading
		LoadColorModel();
		return !S_OK;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////
// DrawBorder(Left, Top, Width, Height, Depth, InputImage)
//
// Draws a box on the border of the Input image.
//////////////////////////////////////////////////////////
HRESULT CColorSegmenter::DrawBorder(int x, int y, int width, int height, int depth, BYTE * image)
{
	// Local indeces
	int i,j,index;

	// 2 horizontal lines
	for(i=x;i<x+width;i++)
	{
		// At the very top of the image
		index = (y*ImageWidth+i)*depth;
		image[index] = 255;

		// At the very bottom of the image
		index = ((y+height)*ImageWidth+i)*depth;
		image[index] = 255;
	}

	// 2 vertical lines
	for(j=y;j<y+height;j++)
	{
		// To the utmost left of the image
		index = (j*ImageWidth+x)*depth;
		image[index] = 255;

		// To the utmost right of the image
		index = (j*ImageWidth+x+width)*depth;
		image[index] = 255;
	}
	return S_OK;
}
////////////////////////////////////////////////////////////
// Initial -- 	get info for BITMAPINHEADER for segmenter //
//				Called only once from OnConstruct()		  //
////////////////////////////////////////////////////////////
STDMETHODIMP CColorSegmenter::Initialize()
{
	// Local Variables
	long		width, height, depth;
	BOOL		flag	= FALSE;

	// Interface types
	IImageRep*	pImgIn	= NULL;
	IImageRep*  pImgOut = NULL;
	IIntelIPL*  pLink	= NULL;

	// LoadColorModel
	LoadColorModel(); 

	/**** INPUT IMAGE ***/
	// Get pointer to object and interface for the Input Image from the IMA "Image Representation".
	m_Bindings->get_Pointers(SysAllocString(L"InputImage"),&m_pIUnkImgIn);
	if(m_pIUnkImgIn!=NULL)
		m_pIUnkImgIn->QueryInterface(IID_IImageRep,(void **)&pImgIn);

	if( pImgIn != NULL && m_pIUnkImgIn != NULL)	
	{
		// DEBUG
		ATLTRACE("Initial:got ImgRep ptr OK\n");
		
		// Retrieve image dimensions from the input image: Height, Width, Depth
		pImgIn->get_Height( &height);
		pImgIn->get_Width ( &width );
		pImgIn->get_Depth ( &depth );

		// Set up the input DIB header:
		m_pHeaderIn.biSize			= sizeof(BITMAPINFOHEADER);			// BITMAPINFOHEADER is a structure. m_pHeaderIn is of this type. 
		m_pHeaderIn.biWidth			= ImageWidth  = (short) width;		// Width of bitmap
		m_pHeaderIn.biHeight		= ImageHeight = (short) abs(height);// Height of bitmap
		m_pHeaderIn.biBitCount		= (WORD) depth * (WORD)8;			// No. of bits
		m_pHeaderIn.biPlanes		= 1;								// No. of planes
		m_pHeaderIn.biCompression	= BI_RGB;							// Bitmap compression rate
		m_pHeaderIn.biSizeImage		= 0;								// Size of image
		m_pHeaderIn.biXPelsPerMeter = 0;								// No. of pixels in X-direction
		m_pHeaderIn.biYPelsPerMeter = 0;								// No. of pixels in Y-direction
		m_pHeaderIn.biClrUsed		= 0;
		m_pHeaderIn.biClrImportant	= 0;

		// Release I/F
		pImgIn->Release();
		flag = TRUE;		// Input ImageRep ok
	}
	
	// Error handling
	else	
	{
		// DEBUG
		MessageBox(NULL,"Initial: Cannot connect to input ImgRep!","Initial Fail",MB_ICONERROR);
		pImgIn->Release();
		return !S_OK;
	}

	/**** OUTPUT IMAGE ***/
	// Get pointer to output object and interface
	m_Bindings->get_Pointers(SysAllocString(L"OutputImage"),&m_pIUnkImgOut);
	if(m_pIUnkImgOut!=NULL)
		m_pIUnkImgOut->QueryInterface(IID_IImageRep,(void **)&pImgOut);

	if( pImgOut != NULL && m_pIUnkImgOut != NULL)	// Successful query?
	{	
		// 1) Get the Output image height and width. The size of these may be smaller depending on variable SkipX/Y
		// 2) Re-initialize the value of "depth". This variable is used immediately here but also later. 
		depth = 1;
		WindowHeight = (short)height;
		WindowWidth  = (short)width;
		pImgOut->put_Height( (long)(WindowHeight/SkipY)); 
		pImgOut->put_Width(  (long)(WindowWidth/SkipX) );		
		pImgOut->put_Depth(depth);							// Binary image

		// Set up the output DIB header:
		m_pHeaderOut.biSize			= sizeof(BITMAPINFOHEADER);
		m_pHeaderOut.biWidth		= (LONG) (WindowWidth/SkipX);
		m_pHeaderOut.biHeight		= (LONG) abs(WindowHeight/SkipY);
		m_pHeaderOut.biBitCount		= (WORD)depth * (WORD) 8;	
		m_pHeaderOut.biPlanes		= 1;
		m_pHeaderOut.biCompression	= BI_RGB;
		m_pHeaderOut.biSizeImage		= 0;
		m_pHeaderOut.biXPelsPerMeter	= 0;
		m_pHeaderOut.biYPelsPerMeter	= 0;
		m_pHeaderOut.biClrUsed			= 0;
		m_pHeaderOut.biClrImportant		= 0;

		// Calculate the center of the image:
		m_iImageCenterX =     m_pHeaderOut.biWidth  / 2;
		m_iImageCenterY = abs(m_pHeaderOut.biHeight / 2);

		// Release I/F
		pImgOut->Release();
		if(flag == TRUE)
			m_bInitialFlag = TRUE;
	}

	// Error handling
	else	
	{
		MessageBox(NULL,"Initial: Cannot connect to output ImgRep!","Initial Fail",MB_ICONERROR);
		pImgOut->Release();
		return !S_OK;
	}

	/****** This is your code to initialize IPL component. *****/
	/****** You only call this Initial() once as long as you work on same ****/
	/****** image dimension. ****/
	/****** get IPL interface *****/

	// Get pointer to the object and interface of the ImageProcessing class
	m_Bindings->get_Pointers(SysAllocString(L"ImageProcessing"),&m_pIUnkIPL);
	if(m_pIUnkIPL!=NULL)
		m_pIUnkIPL->QueryInterface(IID_IIntelIPL,(void **)&pLink);

	if( pLink != NULL )
	{
		// Create the IPL Image headers (left and right images) for a monochrome output image
		pLink->Initial( WindowWidth/SkipX, WindowHeight/SkipY, 1); 
		pLink->Release();
	}
	else
		pLink->Release();

	// Call a function that adjusts parameters based on they type of color model it is.
	AdjustParameters();

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// LoadColorModel -- Loads the appropriate color model which is created by the color modeller //
////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CColorSegmenter::LoadColorModel()
{
	// Local variables
	FILE	*fptr;
	TCHAR	*str1,*str2;		// TCHAR is a string type that adapts to the character scheme adopted by the machine.
	USES_CONVERSION;

	// Convert BSTR to a generic string
	str1 = OLE2T(m_sColorModelFileName);	// Color model NAME
	str2 = OLE2T((BSTR)m_sColorModelType);	// Color model TYPE

	// Compare strings to see if no color model has been loaded
	if (!strcmp(str1,"None"))
	{
		::MessageBox(NULL,"LoadColorModel: No color model file name!","Error",MB_ICONERROR);
		return FALSE;
	}	

	// Open the file for reading
	if((fptr = fopen(str1,"r")) == NULL)
	{
		::MessageBox(NULL,"LoadColorModel: Can't load color model file!","Error",MB_ICONERROR);
		return !S_OK;
	}

	/************** NOW READ FROM THE FILE *****************/
	
	/******** RGNorm *********/
	char model[256];
	
	// Check to see if the string is RGN
	if(!strcmp(str2,"rgn"))
	{
		fseek( fptr, 0L, SEEK_SET );
		
		// Load the RG Norm model
		fscanf(fptr,"%s", model);					// Save the color model name
		fscanf(fptr,"%f", &m_fLambda);				// Save the value of lambda, the standard deviation.

		// Save other statistical values to local member variables
		// For more info on these, See Barile 1997 Master's Thesis.
		fscanf(fptr,"%f", &m_RGNormEllipse.fCorr);		
		fscanf(fptr,"%f", &m_RGNormEllipse.fVarR);
		fscanf(fptr,"%f", &m_RGNormEllipse.fVarG);
		fscanf(fptr,"%f", &m_RGNormEllipse.fNumPts);
		fscanf(fptr,"%f", &m_RGNormEllipse.fStdDevR);
		fscanf(fptr,"%f", &m_RGNormEllipse.fStdDevG);
		fscanf(fptr,"%f", &m_RGNormEllipse.fMR);
		fscanf(fptr,"%f", &m_RGNormEllipse.fMG);
		fscanf(fptr,"%f", &m_RGNormEllipse.fRGpW2);	

		// Close file.
		fclose(fptr);
		
		// Set flag for color model type
		m_iColorModelType	= 0;		// RGNorm
		m_bColorModelReady	= TRUE;		
		m_csColorModelName	= model;
	}
	
	// Check to see if the string is LUV
	else if(!strcmp(str2,"luv"))
	{
		fseek( fptr, 0L, SEEK_SET );

		// Copy file data to member variables
		fscanf(fptr,"%s", model);			// Save the color model name
		fscanf(fptr,"%d", &m_nLLimit);		// Save the luminence upper and lower limits
		fscanf(fptr,"%d", &m_nULimit);
		fscanf(fptr,"%f", &m_fUn);
		fscanf(fptr,"%f", &m_fVn);			// Precalculations
		fscanf(fptr,"%f", &m_fXn);
		fscanf(fptr,"%f", &m_fYn);
		fscanf(fptr,"%f", &m_fZn);			// White point in CIE XYZ
		fscanf(fptr,"%f", &m_fDenom);		// Precalculated denominator
		fscanf(fptr,"%f", &m_fLambda);		// Number of Std Dev's to include
		fscanf(fptr,"%f", &m_LUVSlice.fCorr);		
		fscanf(fptr,"%f", &m_LUVSlice.fVarU);
		fscanf(fptr,"%f", &m_LUVSlice.fVarV);
		fscanf(fptr,"%f", &m_LUVSlice.fNumPts);
		fscanf(fptr,"%f", &m_LUVSlice.fStdDevU);
		fscanf(fptr,"%f", &m_LUVSlice.fStdDevV);
		fscanf(fptr,"%f", &m_LUVSlice.fMU);
		fscanf(fptr,"%f", &m_LUVSlice.fMV);
		fscanf(fptr,"%f", &m_LUVSlice.fLUVpW2);

		// Close file
		fclose(fptr);

		// Set flag for color model type
		m_iColorModelType	= 1;		// LUV	
		m_bColorModelReady	= TRUE;		
		m_csColorModelName	= model;

	}

	else
		return !S_OK;

	return S_OK;
}

/////////////////////////////////////////////////
// LUVSegment -- Segment image using LUV model //
/////////////////////////////////////////////////
HRESULT CColorSegmenter::LUVSegment(BYTE* pbDataIn,BYTE* pbDataOut)
{
	// TODO: Add your implementation code here
	static LONG col;							// "col" indexes down a column, "row" indexes along a row
	static LONG colLength, lColInc;
	static LONG i, lSliceIndex;					// which slice structure to use
	static float fW2, fW3, fValue;
	static LONG lIndexIn,lIndexOut;				// indexes through the output image
	static LONG lRowStartIn, lRowStartOut;		// Index value at start of row
	static LONG lOffsetIn, lOffsetOut;			// number of bytes to next pixel in array
	static LONG lRowBytesIn, lRowBytesOut;		// number of bytes in a row (input, output)
	static LONG lNextRowIncIn, lNextRowIncOut;
	
	static float   fR, fG, fB;					// normalized RGB
	static float   fL, fU, fV;					// converted from RGB to L*u*v*
	static float   fUp, fVp;					// part of the calculation
	static float   fX, fY, fZ;					// used in conversion process
	static float   fYcheck;
	static float   fConvert; 

	fConvert = (float) .96590909;				// 255/264

	lOffsetIn	= m_pHeaderIn.biBitCount / 8;			// number of bytes to next pixel (input)
	lOffsetOut	= m_pHeaderOut.biBitCount / 8;			// number of bytes to next pixel (output)

	// Get some metrics about the image:
	lRowBytesIn		= (m_pHeaderIn.biWidth * lOffsetIn);	// width in bytes of input row
	lRowBytesOut	= (m_pHeaderOut.biWidth * lOffsetOut);	// width in bytes of output row
	colLength		= abs((m_pHeaderIn.biHeight));

	// Calculate proper index values if output is smaller than input:
	lColInc		= abs(m_pHeaderIn.biHeight) / abs(m_pHeaderOut.biHeight);
	lOffsetIn	*= (m_pHeaderIn.biWidth / m_pHeaderOut.biWidth);
	
	// Index through the input image to match the output image:
	if((m_pHeaderIn.biHeight) < 0) {	
		
		// Input image is stored in Top-Down fashion:
		if((m_pHeaderOut.biHeight) < 0) {
			// Output is stored Top-Down:
			lNextRowIncIn	= lRowBytesIn*lColInc;
			lNextRowIncOut	= lRowBytesOut;
			lRowStartIn		= 0;
			lRowStartOut	= 0;
		}
		else {
			// Output is stored Bottom-Up:
			lNextRowIncIn	= lRowBytesIn*lColInc;
			lNextRowIncOut	= -lRowBytesOut;
			lRowStartIn		= 0;
			lRowStartOut	= ((m_pHeaderOut.biHeight)*lRowBytesOut) - lRowBytesOut;
		}
	}

	else {
		// Input image is stored in Bottom-Up fashion:

		if((m_pHeaderOut.biHeight) < 0) {
			// Output is stored Top-Down:
			lNextRowIncIn	= lRowBytesIn*lColInc;
			lNextRowIncOut	= -lRowBytesOut;
			lRowStartIn		= 0;
			lRowStartOut	= (abs(m_pHeaderOut.biHeight)*lRowBytesOut) - lRowBytesOut;
		}
		else {
			// Output is stored Bottom-Up:
			lNextRowIncIn	= lRowBytesIn*lColInc;
			lNextRowIncOut	= lRowBytesOut;
			lRowStartIn		= 0;
			lRowStartOut	= 0;
		}
	}

	// Do the skintone segmentation from the frame image into the mask image:
	for(col=0; col<colLength; col+=lColInc) {	// Count down columns

		lIndexOut = 0;							// index along an output row

		for(lIndexIn=0; lIndexIn<lRowBytesIn; lIndexIn+=lOffsetIn) {	// index across a row

			//
			// convert the point from RGB to XYZ:
			//

			// Read in RGB and normalize to the range [0,1]
			fB = (float) pbDataIn[lRowStartIn + lIndexIn] / (float) 255.0;
			fG = (float) pbDataIn[lRowStartIn + lIndexIn + 1] / (float) 255.0;
			fR = (float) pbDataIn[lRowStartIn + lIndexIn + 2] / (float) 255.0;

			// Compute XYZ from this pixel:
			// From the HSV model; red, green, and blue have positions that can be used to find x,y,z
			fX = (fR * (float) 0.412453) + (fG * (float) 0.357580) + (fB * (float) 0.180423);
			fY = (fR * (float) 0.212671) + (fG * (float) 0.715160) + (fB * (float) 0.072169);
			fZ = (fR * (float) 0.019334) + (fG * (float) 0.119193) + (fB * (float) 0.950227);

			
			// Luminicence calculations
			fYcheck = fY / m_fYn;
			if (fYcheck > 0.008856)
				fL = ( (float) 116.0 * ((float) pow(fYcheck, 0.333333) ) ) - (float) 16.0;	//Luminicence
			else
				fL = (float) 903.3 * fYcheck;

			// Check the luminence to see if it's in the target range:
			if((fL >=m_nLLimit) && (fL <= m_nULimit)) {

				// If yes, then continue on with the calculations:
				fUp = ((float) 4.0*fX) / ( fX + ((float) 15.0*fY) + ((float) 3.0*fZ) );
				fVp = ((float) 9.0*fX) / ( fX + ((float) 15.0*fY) + ((float) 3.0*fZ) );

				fU = ((float) 13.0*fL) * (fUp - m_fUn);
				fV = ((float) 13.0*fL) * (fVp - m_fVn);	

				// Normalize to the range [0,255]
				fU = (fConvert * (fU + (float) 84.0)) + (float) 0.5; 
				fV = fV + (float) 135.5;

				// Normalize to the range [0,1]:
				fU /= (float) 255.0;
				fV /= (float) 255.0;

				//
				// Find out if the UV values of the current pixel are within the slice ellipse:
				// 
				// The model data is normalized to the range [0,1]
				// The current LUV data is normalized to the range [0,1]
				fU -= m_LUVSlice.fMU;
				fV -= m_LUVSlice.fMV;

				fW2 = m_LUVSlice.fLUVpW2 * fU * fV;
				fW3 =   ( (fU*fU) / m_LUVSlice.fVarU) 
					  - ( m_fLambda * m_fLambda * ((float) 1.0 - m_LUVSlice.fCorr * m_LUVSlice.fCorr) )
					  + ( (fV*fV) / m_LUVSlice.fVarV);
				fValue = fW2 + fW3;	

				if(fValue >= 0.0) {
					pbDataOut[lRowStartOut + lIndexOut    ]=0;
	//				pbDataOut[lRowStartOut + lIndexOut + 1]=0;				
	//				pbDataOut[lRowStartOut + lIndexOut + 2]=0;			
				}
				else {
					pbDataOut[lRowStartOut + lIndexOut    ]=254;
	//				pbDataOut[lRowStartOut + lIndexOut + 1]=255;				
	//				pbDataOut[lRowStartOut + lIndexOut + 2]=255;			
				}	
			}
			else {	
				// 
				//  Luminance is not in the target range.
				//
					pbDataOut[lRowStartOut + lIndexOut    ]=0;
	//				pbDataOut[lRowStartOut + lIndexOut + 1]=0;				
	//				pbDataOut[lRowStartOut + lIndexOut + 2]=0;			

			}
			lIndexOut+=lOffsetOut;		// go to next pixel in output image
		}
		lRowStartIn  += lNextRowIncIn;			// find start of current input row
		lRowStartOut += lNextRowIncOut;			// find start of current output row
	}	

	return S_OK;
}

/***********************************************************************
/* RGNormSegment(InputImage, OutputImage)
/* This function performs color segmentation. 
/* If the pixel value in the image is found inside of the ellipse
/* generated by the ColorModeller.exe program,
/* Then the pixel is segmented to white, otherwise, it stays black.
/*
/* When calling this function make sure that the input and output
/* images have been initialized properly by the IMA2_CFrameGrabber class
/*
/* For more in depth information on the theory behind the Color Elipse
/* Look at Jason Barile's Thesis for documentation on the mathematica model.
/* I:Etc/Documentation/MSThesis					  
/***********************************************************************/
HRESULT CColorSegmenter::RGNormSegment(BYTE* pbDataIn,BYTE* pbDataOut)
{
	// TODO: Add your implementation code here
	float fW2, fW3, fPixR, fPixB, fPixG, fValue, fDenom;
	float ftransR, ftransG;
	float fR, fG;						// rgNorm chromaticity coordinates
	int   input_index, output_index;
	int   i,j;
	int   input_depth,output_depth;

	// Get the depth of the image. 3 Channels (RGB) = 24 bits. 1 Channel (Binary) = 8 bits.
	input_depth  = m_pHeaderIn.biBitCount/8;		
	output_depth = m_pHeaderOut.biBitCount/8;
	
	// Index through the input image to match the output image:
	// Do the color segmentation from the frame image into the mask image:
	for(i=0; i<WindowHeight; i+=SkipY) 
	{
		for(j=0; j<WindowWidth; j+=SkipX) 
		{	
			
			// Arrange size and dimension of input and output pictures
			input_index  = ((i+WindowTop)*m_pHeaderIn.biWidth+(j+WindowLeft))*input_depth;
			//input_index  = (i*m_pHeaderIn.biWidth+j)*input_depth;
			output_index = ((i/SkipY)*m_pHeaderOut.biWidth+(j/SkipX))*output_depth;

			// Get a pixel and normalize the intensity
			fPixB = (float) pbDataIn[input_index    ]/(float) 256.0;
			fPixG = (float) pbDataIn[input_index + 1]/(float) 256.0;
			fPixR = (float) pbDataIn[input_index + 2]/(float) 256.0;
			
			// Calculate rgNorm coordinates:
			fDenom	= (fPixR + fPixG + fPixB);	// denominator
			fR		= (fPixR / fDenom);
			fG		= (fPixG / fDenom);
			
			// Find out if the RG values are within the slice ellipse:
			ftransG = fG - m_RGNormEllipse.fMG;
			ftransR = fR - m_RGNormEllipse.fMR;

			fW2 = m_RGNormEllipse.fRGpW2 * ftransR * ftransG;
			fW3 =   ( (ftransR * ftransR) / m_RGNormEllipse.fVarR) 
				  - (m_fLambda * m_fLambda * ((float) 1.0 - m_RGNormEllipse.fCorr * m_RGNormEllipse.fCorr) )
				  + ( (ftransG * ftransG) / m_RGNormEllipse.fVarG);
			fValue = fW2 + fW3;	

			if(fValue >= 0.0) 
			{
					// set each channel to 0
					pbDataOut[output_index] = 0;								
			}
			else 
			{
					// set each channel to 1
					pbDataOut[output_index] = 255;
			}	
		}
	}	

	return S_OK;
} 


HRESULT CColorSegmenter::UpdateWindow()
{
	// TODO: Add your implementation code here
	IVectorSignal* pVectorIn;
	double window[4];
	double dNewtop = 0.0,dNewleft = 0.0;
	SAFEARRAY* mysa;

	// Get pointer to VS Class
	m_Bindings->get_Pointers(SysAllocString(L"VectorIn"),&m_pIUnkVectorIn);
	
	if(m_pIUnkVectorIn!=NULL)
	{
		// Get pointer to interface
		m_pIUnkVectorIn->QueryInterface(IID_IVectorSignal,(void **)&pVectorIn);

		if(pVectorIn != NULL)
		{
			 mysa=SafeArrayCreateVector(VT_R8,0,4);
			 pVectorIn->GetCurrentVector( mysa );
			 memcpy(window,mysa->pvData,sizeof(double)*4);
			 SafeArrayDestroy(mysa);

			 // This gives us new CENTER of windor (col,row)
			 dNewleft   = window[0] - (double)WindowWidth/2;
			 dNewtop    = window[1] - (double)WindowHeight/2;

			 if(dNewleft<0) dNewleft = 0.0;
			 if(dNewtop<0) dNewtop	 = 0.0;

			 WindowLeft = (short)dNewleft;
			 WindowTop	= (short)dNewtop;

			 pVectorIn->Release();
		}
	}

	return S_OK;
}

////////////////////////
// Internal Functions //
////////////////////////

void CColorSegmenter::FilterOutput(long lIn, long lOut)
{
	IIntelIPL*	pLink	= NULL;

	// Get pointer to IPL Class
	m_Bindings->get_Pointers(SysAllocString(L"ImageProcessing"),&m_pIUnkIPL);

	if( m_pIUnkIPL != NULL )
	{
		// Get pointer to IPL Interface
		m_pIUnkIPL->QueryInterface(IID_IIntelIPL,(void **)&pLink);

		if( pLink != NULL )
		{
			// Call IntelIPL Morphological calls. 3rd argument implies number of iterations of the algorithm.
			// Assumes a standard kernel of 3x3 with anchor at 2x2.
			// The bigger the image the more benefit a higher number of iterations.
			pLink->Open(lOut, lOut, m_sIterations);				// Eliminates random noise
			pLink->Close(lOut,lOut, m_sIterations);				// Fills segmented pixels

			// DEBUG
			pLink->Release();
		}
	}
}

/************************************************
* SetCentroid()
// Send Centroid information to Vector Signal
************************************************/
long CColorSegmenter::SetCentroid(double * OutputVector)
{
	// Local variables
	IVectorSignal*	pVectorOut	= NULL;
	SAFEARRAY* mysa;

	// Get pointer to object and interface of the Centroid Vector vector signal
	m_Bindings->get_Pointers(SysAllocString(L"CentroidVector"),&m_pIUnkVectorOut);
	if(m_pIUnkVectorOut == NULL) return !S_OK;
		
	// Get pointer to VSOut Interface
	m_pIUnkVectorOut->QueryInterface(IID_IVectorSignal,(void **)&pVectorOut);
	if(pVectorOut == NULL) return !S_OK;
		
	// Copy local data to VectorSignal (X and Y position).
	mysa=SafeArrayCreateVector(VT_R8,0,2);
	memcpy(mysa->pvData,OutputVector,sizeof(double)*2);
	pVectorOut->SetCurrentVector( mysa );	// set vector signal

	// Free memory
	SafeArrayDestroy(mysa);
	pVectorOut->Release();	
	
	return S_OK;
}

long CColorSegmenter::GetInputVector(double * InputVector, long length)
{
	IVectorSignal*	pVectorIn	= NULL;
//	double  time;

	return S_OK;
}

/*********************************************
* Internal Constructors and Serializing
*********************************************/
// The OnConstruct Function sets all the bindings for the component, and \
// also replaces FinalComponentInitialization
STDMETHODIMP CColorSegmenter::OnConstruct() {

// TODO: Bindings. Personalize the binding of your component. 
	HRESULT hRes=S_OK;

	int numiids;
	long x[1];
	IMA2_BindingInfo	m_Binding;

	numiids=1;
	x[0]=0; //specifies first element

	// Input Image
	m_Binding.Name		= SysAllocString(L"InputImage");						// Assign name to object
	m_Binding.BindType	= BT_Default;											// Condition to accept a single binding
	m_Binding.Path		= SysAllocString(L"");									// This is the path of the component you are connecting to
	m_Binding.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, 1);					// Create an empty string array
	m_Binding.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);			// Create an empty string array
	SafeArrayPutElement(m_Binding.IIDs,x,(void *)SysAllocString(L"IImageRep"));
	m_ConfigureBindings->Add(&m_Binding);										// Set up the clients bindings array.	
		// Free Binding Info
		SysFreeString(m_Binding.Name);
		SysFreeString(m_Binding.Path);
		SafeArrayDestroy(m_Binding.PIDs);
		SafeArrayDestroy(m_Binding.IIDs);

	// Output Image
	m_Binding.Name		= SysAllocString(L"OutputImage");						// Assign name to object
	m_Binding.BindType	= BT_Default;											// Condition to accept a single binding
	m_Binding.Path		= SysAllocString(L"");									// This is the path of the component you are connecting to
	m_Binding.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, 1);					// Create an empty string array
	m_Binding.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);			// Create an empty string array
	SafeArrayPutElement(m_Binding.IIDs,x,(void *)SysAllocString(L"IImageRep"));
	m_ConfigureBindings->Add(&m_Binding);										// Set up the clients bindings array.	
		// Free Binding Info
		SysFreeString(m_Binding.Name);
		SysFreeString(m_Binding.Path);
		SafeArrayDestroy(m_Binding.PIDs);
		SafeArrayDestroy(m_Binding.IIDs);

	// Vector Out - Links to the vector that holds the centroid position of the segmented blob
	m_Binding.Name		= SysAllocString(L"CentroidVector");					// Assign name to object
	m_Binding.BindType	= BT_Default;											// Condition to accept a single binding
	m_Binding.Path		= SysAllocString(L"");									// This is the path of the component you are connecting to
	m_Binding.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, 1);					// Create an empty string array
	m_Binding.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);			// Create an empty string array
	SafeArrayPutElement(m_Binding.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&m_Binding);										// Set up the clients bindings array.	
		// Free Binding Info
		SysFreeString(m_Binding.Name);
		SysFreeString(m_Binding.Path);
		SafeArrayDestroy(m_Binding.PIDs);
		SafeArrayDestroy(m_Binding.IIDs);

	// ImageProcessing - Links to components that will do imageprocessing
	m_Binding.Name		= SysAllocString(L"ImageProcessing");					// Assign name to object
	m_Binding.BindType	= BT_Default;											// Condition to accept a single binding
	m_Binding.Path		= SysAllocString(L"");									// This is the path of the component you are connecting to
	m_Binding.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, 1);					// Create an empty string array
	m_Binding.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);			// Create an empty string array
	SafeArrayPutElement(m_Binding.IIDs,x,(void *)SysAllocString(L"IIntelIPL"));
	m_ConfigureBindings->Add(&m_Binding);
		// Set up the clients bindings array.	
		// Free Binding Info
		SysFreeString(m_Binding.Name);
		SysFreeString(m_Binding.Path);
		SafeArrayDestroy(m_Binding.PIDs);
		SafeArrayDestroy(m_Binding.IIDs);
/*
	// Vector In
	m_Binding.Name		= SysAllocString(L"VectorIn");							// Assign name to object
	m_Binding.BindType	= BT_Default;											// Condition to accept a single binding
	m_Binding.Path		= SysAllocString(L"");									// This is the path of the component you are connecting to
	m_Binding.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, 1);					// Create an empty string array
	m_Binding.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);			// Create an empty string array
	SafeArrayPutElement(m_Binding.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&m_Binding);										// Set up the clients bindings array.	
		// Free Binding Info
		SysFreeString(m_Binding.Name);
		SysFreeString(m_Binding.Path);
		SafeArrayDestroy(m_Binding.PIDs);
		SafeArrayDestroy(m_Binding.IIDs);


	// NumSegmentedPixels - Links to GenerateTrajectory to do so, once there are enough segmented pixels
	m_Binding.Name		= SysAllocString(L"NumSegmentedPixels");					// Assign name to object
	m_Binding.BindType	= BT_Default;											// Condition to accept a single binding
	m_Binding.Path		= SysAllocString(L"");									// This is the path of the component you are connecting to
	m_Binding.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, 1);					// Create an empty string array
	m_Binding.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);			// Create an empty string array
	SafeArrayPutElement(m_Binding.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&m_Binding);
		// Set up the clients bindings array.	
		// Free Binding Info
		SysFreeString(m_Binding.Name);
		SysFreeString(m_Binding.Path);
		SafeArrayDestroy(m_Binding.PIDs);
		SafeArrayDestroy(m_Binding.IIDs);
*/
	
	return S_OK;
}

STDMETHODIMP CColorSegmenter::OnDestruct() { SysFreeString(m_sColorModelFileName); return S_OK; }

STDMETHODIMP CColorSegmenter::Load(VARIANT Data) {
	

	// Variables
	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	_PropertyBagWrapper*	pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	variant_t				*Var;

	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);

		if (pIPB == NULL)	
			return !S_OK;

		// Get the pointer to the real VB property bag (the VB object (defined in msvbvm60.dll (aka VBRUN)) that our wrapper class created)
		// hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
		
		// Pass Data to PropertyBag
		hRes = pIPB->SetPropertyBag(&Data);
		
		// Variable 4
		ItemName	= SysAllocString(L"SkipX");
		Var			= new variant_t;
		pIPB->GetFromPropertyBag(&ItemName,Var);  //2nd argument is return value (look retval for help)
		SkipX		= (short)*Var;
		// Deallocate
		SysFreeString(ItemName);
		delete Var;
		
		// Variable 5
		ItemName	= SysAllocString(L"SkipY");
		Var			= new variant_t;
		pIPB->GetFromPropertyBag(&ItemName,Var);  //2nd argument is return value (look retval for help)
		SkipY		= (short)*Var;
		// Deallocate
		SysFreeString(ItemName);
		delete Var;
		
		// Variable 7
		ItemName	= SysAllocString(L"WindowLeft");
		Var			= new variant_t;
		pIPB->GetFromPropertyBag(&ItemName,Var);  //2nd argument is return value (look retval for help)
		WindowLeft	= (short)*Var;
		// Deallocate
		SysFreeString(ItemName);
		delete Var;
		
		// Variable 8
		ItemName	= SysAllocString(L"WindowTop");
		Var			= new variant_t;
		pIPB->GetFromPropertyBag(&ItemName,Var);  //2nd argument is return value (look retval for help)
		WindowTop	= (short)*Var;
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Variable 9
		ItemName	= SysAllocString(L"WindowWidth");
		Var			= new variant_t;
		pIPB->GetFromPropertyBag(&ItemName,Var);  //2nd argument is return value (look retval for help)
		WindowWidth	= (short)*Var;
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Variable 10
		ItemName	= SysAllocString(L"WindowHeight");
		Var			= new variant_t;
		pIPB->GetFromPropertyBag(&ItemName,Var);  //2nd argument is return value (look retval for help)
		WindowHeight= (short)*Var;
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Variable 11
		ItemName	= SysAllocString(L"FilterOutput");
		Var			= new variant_t;
		pIPB->GetFromPropertyBag(&ItemName,Var);  //2nd argument is return value (look retval for help)
		m_sFilterOutput		= (short)*Var;
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Variable 12
		ItemName	= SysAllocString(L"BoxDrawing");
		Var			= new variant_t;
		pIPB->GetFromPropertyBag(&ItemName,Var);	//2nd argument is return value (look retval for help)
		m_bDrawCrossMarker		= (long)*Var;
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Variable 13
		ItemName	= SysAllocString(L"BlobArea");
		Var			= new variant_t;
		pIPB->GetFromPropertyBag(&ItemName,Var);	//2nd argument is return value (look retval for help)
		m_lBlobArea	= (long)*Var;
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Variable 14
		ItemName	= SysAllocString(L"ColorModelFileName");
		Var			= new variant_t;
		pIPB->GetFromPropertyBag(&ItemName,Var);	//2nd argument is return value (look retval for help)
		//m_sColorModelFileName.Empty();			// Was a CComBSTR
		if(Var->vt != NULL)
			SysReAllocString(&m_sColorModelFileName,Var->bstrVal);
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Variable 15
		ItemName	= SysAllocString(L"StandardDeviation");
		Var			= new variant_t;
		pIPB->GetFromPropertyBag(&ItemName,Var);	//2nd argument is return value (look retval for help)
		m_fLambda	= (float)*Var;
		// Deallocate
		SysFreeString(ItemName);

		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);
		
		// Release
		pIPB->Release();
		
	return S_OK;
}

STDMETHODIMP CColorSegmenter::Save(VARIANT *pData) {
	
	// Variables
	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	variant_t				*Var;
	_PropertyBagWrapper		*pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.

	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);

		if (pIPB == NULL)	
			return !S_OK;
		
		// Variable 4
		ItemName = SysAllocString(L"SkipX");
		Var = new variant_t(SkipX, VT_I2);
		hRes = pIPB->AddToPropertyBag(&ItemName, Var);
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Variable 5
		ItemName = SysAllocString(L"SkipY");
		Var = new variant_t(SkipY, VT_I2);
		hRes = pIPB->AddToPropertyBag(&ItemName, Var);
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Variable 7
		ItemName = SysAllocString(L"WindowLeft");
		Var = new variant_t(WindowLeft, VT_I2);
		hRes = pIPB->AddToPropertyBag(&ItemName, Var);
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Variable 8
		ItemName = SysAllocString(L"WindowTop");
		Var = new variant_t(WindowTop, VT_I2);
		hRes = pIPB->AddToPropertyBag(&ItemName, Var);
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Variable 9
		ItemName = SysAllocString(L"WindowWidth");
		Var = new variant_t(WindowWidth, VT_I2);
		hRes = pIPB->AddToPropertyBag(&ItemName, Var);
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Variable 10
		ItemName = SysAllocString(L"WindowHeight");
		Var = new variant_t(WindowHeight, VT_I2);
		hRes = pIPB->AddToPropertyBag(&ItemName, Var);
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Variable 11
		ItemName = SysAllocString(L"FilterOutput");
		Var = new variant_t(m_sFilterOutput, VT_I2);
		hRes = pIPB->AddToPropertyBag(&ItemName, Var);
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Variable 12
		ItemName = SysAllocString(L"BoxDrawing");
		Var = new variant_t((long)m_bDrawCrossMarker, VT_I4);
		hRes = pIPB->AddToPropertyBag(&ItemName, Var);
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Variable 13
		ItemName = SysAllocString(L"BlobArea");
		Var = new variant_t(m_lBlobArea, VT_I4);
		hRes = pIPB->AddToPropertyBag(&ItemName, Var);
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Variable 14****
		ItemName = SysAllocString(L"ColorModelFileName");
		Var = new variant_t(m_sColorModelFileName);		// Variant stores variable as a BSTR 
		hRes = pIPB->AddToPropertyBag(&ItemName, Var);
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Variable 15
		ItemName = SysAllocString(L"StandardDeviation");
		Var = new variant_t(m_fLambda);
		hRes = pIPB->AddToPropertyBag(&ItemName, Var);
		// Deallocate
		SysFreeString(ItemName);
		delete Var;

		// Returns a pointer to the PropertyBag as a VARIANT
		hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
		
		// Copy the contents of the property bag to the pData VARIANT
		VariantCopy(pData, &m_VBPropertyBag);

		// Save the size of the data 
		m_lDataSize = pData->parray->rgsabound[0].cElements;		

		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);

		// Release
		pIPB->Release();

	return S_OK;
}

/******************************************
/* Iterations()
/*
/* This function chanages the variablem m_sIterations
/* which is used in the function FilterOutput().
/* 
/* This variable changes the number of times the Open() and 
/* Close() morpohological operators are called.
*******************************************/
STDMETHODIMP CColorSegmenter::get_filter_NumIterations(short *pVal)
{
	*pVal = m_sIterations;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_filter_NumIterations(short newVal)
{
	if(newVal >= 1 && newVal <=4)
		m_sIterations = newVal;

	return S_OK;
}

// Adjusts parameters based on the type of ColorModel file
void CColorSegmenter::AdjustParameters()
{
	USES_CONVERSION;

	char* ColorModelName;
	ColorModelName = OLE2T(m_csColorModelName);

	// Compare the ColorModelName with a variety of names and adjust parameters.

	// Blue Hologram Ribon
	if( !strcmp(ColorModelName,"Blue") )
	{
		// Number of iterations
		m_sIterations = 1;

		// Number of Std Dev's
		m_fLambda = 1.2f;
	}

	// Green Hologram Ribon
	if( !strcmp(ColorModelName,"Green") )
	{
		// Number of iterations
		m_sIterations = 2;

		// Number of Std Dev's
		m_fLambda = 3.2f;//2.4f;
	}

	// Purple Hologram Ribon
	if( !strcmp(ColorModelName,"PurpleRibbon") )
	{
		// Number of iterations
		m_sIterations = 3;

		// Number of Std Dev's
		m_fLambda = 1.6f;

		// Filter parameter
		filt_StdDevGain = 2.0;

	}

	// Barney
	if( !strcmp(ColorModelName,"bar_rear_purple") )
	{
		// Number of iterations
		m_sIterations = 1;

		// Number of Std Dev's
		m_fLambda = 1.2f;
	}
	

	ColorModelName = NULL;

}

STDMETHODIMP CColorSegmenter::get_stat_Average_X_BlobPosition(double *pVal)
{
	*pVal = x_Mean;

	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_stat_Average_X_BlobPosition(double newVal)
{
	// Don't want to put anything just read
	return S_OK;
}

STDMETHODIMP CColorSegmenter::get_stat_Average_Y_BlobPosition(double *pVal)
{
	*pVal = y_Mean;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_stat_Average_Y_BlobPosition(double newVal)
{
	// Don't want to put anything just read
	return S_OK;
}

STDMETHODIMP CColorSegmenter::get_stat_StdDev_X_Blob(double *pVal)
{
	*pVal = x_StandardDev;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_stat_StdDev_X_Blob(double newVal)
{
	// Don't want to put anything just read
	return S_OK;
}


STDMETHODIMP CColorSegmenter::get_stat_StdDev_Y_Blob(double *pVal)
{
	*pVal = y_StandardDev;
	return S_OK;
}

STDMETHODIMP CColorSegmenter::put_stat_StdDev_Y_Blob(double newVal)
{
	// Don't want to put anything just read
	return S_OK;
}
