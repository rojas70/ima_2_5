// NewValveController.cpp : Implementation of CNewValveController
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This is effectively a PD Controller.
// The name is misleading.
// 
// Note:
// For this program to run adequately in IMA2.5, Winmotenc.dll has to be present in the C:\IMA2\Components folder.
// DAD will complain if there is a .dll file that does not belong to an IMA2.5 component. So, the Motenc.dll was given a 'hidden status'.
// There is a strange .dll dependency between this program and that .dll
//
// A note about this template:
// This template is autogenerated. The template code can be found in \ProgramFiles\MicrosoftVisualStudio\Common\MSDev\Templates\ATL
// Specifically customized for an IMA 2.5 component.
// Created by Juan Rojas. Jan 08.
//
// You can also look at an example compenent created by Christina Campbell at O:\Components\ExampleComp
// If you are just learning look at that component to see more details than those included in this template.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "IMA2_NNet_n_PController.h"
#include "NewValveController.h"
#include <math.h>
/////////////////////////////////////////////////////////////////////////////
// CNewValveController
// 
// Include Class comments.
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
// CNewValveController::OnConstruct() 
// OnConstruct() is called when the component is created. In addition to putting in
// whatever initialization code you need, If you are going to connect to another
// component anywhere in your code, you need to set up bindings. 
//
// The following code will create one binding. Change "DescriptiveName" to some
// appropriate string. This string will be visible as the name of the binding from
// DAD. It is *not* the name of the component you will bind to. The name of the
// specific component on the other end of the binding is determined at runtime (in DAD).
//
// If you wish to allow only one component to connect to this binding, make the BindType
// BT_Default. If you wish to allow several components, make the BindType BT_Collection.
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CNewValveController::OnConstruct()
{
// TODO: Bindings. Personalize the binding of your component. 

	IMA2_BindingInfo BindInf;
	long x[1] = {0};

	SAFEARRAYBOUND		SafeArrayBoundIn[1];										// We're making a one-dimensional SafeArray
	SafeArrayBoundIn[0].lLbound		= 0;											// Our SafeArray starts at index 0
	SafeArrayBoundIn[0].cElements	= 1;											// It's empty, doesn't have any elements yet.

	// **START**
	// DesiredAngles
	BindInf.Name		= SysAllocString(L"DesiredAngles");						// Assign name to object
	BindInf.BindType	= BT_Collection;										// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");									// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// Actual Angles
	BindInf.Name		= SysAllocString(L"CurrentAngles");						// Assign name to object
	BindInf.BindType	= BT_Collection;										// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");									// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);											// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// ValveVoltages
/*	BindInf.Name		= SysAllocString(L"ValveVoltages");						// Assign name to object
	BindInf.BindType	= BT_Collection;										// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");									// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);											// Set up the clients bindings array.	
*/	// **FINISH**

	// **START**
	// State Machine
/*	BindInf.Name		= SysAllocString(L"StateMachine");						// Assign name to object
	BindInf.BindType	= BT_Collection;										// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");									// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_StateMachineProj.StateMachine"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IStateMachine"));
	m_ConfigureBindings->Add(&BindInf);											// Set up the clients bindings array.	
*/	
	 // **FINISH**

	// Deallocate storage
	SysFreeString(BindInf.Name);
	SysFreeString(BindInf.Path);
	SafeArrayDestroy(BindInf.PIDs);
	SafeArrayDestroy(BindInf.IIDs);

  return S_OK;
}
STDMETHODIMP CNewValveController::OnDestruct() {	return S_OK; }
//////////////////////////////////////////////////////////////////////////////////////////
// CNewValveController::Save(VARIANT *pData)
// This method is called by DAD when a component is saved. Items that should be saved are the
// ones that are important to the setup of the code, or user options that should hold over
// from one use of an agent to another. (Example: size of data, filenames, etc.) 
//
// For each variable to be saved, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to GetPropertyBag). Change the
// term "DescriptiveName" to something descriptive of the item you are saving, and make
// sure not to reuse names. In the next line of code, change "m_MyPrivateVariable" to the variable
// you are saving and VarType to the VarType of that value. Valid types and VarTypes are:
// (Note: These are limited by VB/OLE compatibility, not by the list of things that Variants can be.)
// short:	VT_I2
// int:		VT_I4
// float:	VT_R4
// double:	VT_R8
// BSTR:	VT_BSTR
// char:	VT_BYTE
// All strings (char*) should be converted to BSTR (see BSTR documentation).
// A CString can be converted to a BSTR using the member function AllocSysString (see CString documentation)
//
// If you want to save an array, you have to assign a SAFEARRAY to the Variant. (Do NOT just
// use a pointer, it will save just one value). replace the line starting "ItemValue =" with the following 
// code (substituting your pointer for "variable", the array length for "numelem", int/float/double, etc. 
// for "Type", and using the VarType of one element of the array--BSTR arrays are not allowed.):
//
//	ItemValue = new variant_t;
//	ItemValue->vt=VT_ARRAY|VarType;
//	ItemValue->parray=SafeArrayCreateVector(VarType,0,numelem);
//  memcpy(ItemValue->parray->pvData,variable,numelem*sizeof(Type));
//
// Note: "delete ItemValue" will take care of destroying the safearray (do *not* call SafeArrayDestroy).
// Because of the nature of a SafeArray, you do not have to explicitly save the length of the array.
// However, due to the nature of property bags, you must call the array version of the Add function:
//
//  hRes = pIPB->AddArrayToPropertyBag(&ItemName, ItemValue);
//
// (See Load comments for how to extract arrays from the propertybag).
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CNewValveController::Save(VARIANT *pData) {
	// Variables
	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	variant_t				*ItemValue;
	_PropertyBagWrapper		*pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		
	if (pIPB == NULL)	
			return !S_OK;
		
		// **START**
		// PGain parameter control value
/*		ItemName = SysAllocString(L"PGain");
		// Store the data and the type of data into a variant_t type
		ItemValue = new variant_t;
		ItemValue->vt=VT_ARRAY|VT_R8;
		ItemValue->parray=SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		memcpy(ItemValue->parray->pvData,m_dPGain,NUM_AXES*sizeof(double));
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddArrayToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**
*/
		// **START**
		// Create string names for items to be saved
		// WhatArm
		ItemName = SysAllocString(L"WhatArm");
		// Store the data and the type of data into a variant_t type
 		ItemValue = new variant_t((short)m_bWhatArm,VT_I2);
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**

		// **START**
		// Create string names for items to be saved
		// NumOfSteps
		ItemName = SysAllocString(L"NumOfSteps");
		// Store the data and the type of data into a variant_t type
 		ItemValue = new variant_t((short)m_sNumOfSteps,VT_I2);
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**

		// Returns a pointer to the PropertyBag as a VARIANT
		hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
		
		// Copy the contents of the property bag to the pData VARIANT
		VariantCopy(pData, &m_VBPropertyBag);

		// Save the size of the data 
		m_lDataSize = pData->parray->rgsabound[0].cElements;		

		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);

		// Release
		pIPB->Release();

	return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////
// CNewValveController::Load(VARIANT Data)
// This function will load in all the data you just saved in the Save function.
// 
// For each variable to be loaded, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to VariantClear). Change the
// term "NameUsedToSave" to the name you gave this item in Save.
// On the line beginning "variable = ", change "variable" to the variable that you saved
// the value from, and change "Type" to the type of that variable (use "long" for "int")
// A CString can be directly set to a BSTR, but in order to get a char* back, you have to 
// use strcpy (I think).
//
// If you made an array, you have to load it back in now.
// Just like in the save function, you must call the array version of the Get function:
//
//  pIPB->GetArrayFromPropertyBag(&ItemName, ItemValue);
//
// If your variable is dynamically allocated, make sure to delete and reallocate it:
//
//  if(variable!=NULL)
//		delete variable;
//  variable=new Type[ItemValue->parray->rgsabound->cElements];	
//
// Then just copy the values from the parray (replace the "variable =" line with this):
//
//  memcpy(variable,ItemValue->parray->pvData,ItemValue->parray->rgsabound->cElements*sizeof(Type));
//
// Note that this means you do not have to separately save the length of the array, although if
// you have a variable that keeps track of the array length you should also set it at this point:
//
//  numelem=ItemValue->parray->rgsabound->cElements;
//
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CNewValveController::Load(VARIANT Data) {
	
	// Variables
	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	_PropertyBagWrapper*	pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	variant_t				*ItemValue;
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		
	if (pIPB == NULL)	
			return !S_OK;

		// Pass Data to PropertyBag
		hRes = pIPB->SetPropertyBag(&Data);
		
		// **START**
		// PGain control value
		// Define strings
/*		ItemName		= SysAllocString(L"PGain");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetArrayFromPropertyBag(&ItemName, ItemValue);
		memcpy(m_dPGain, ItemValue->parray->pvData, sizeof(double)*NUM_AXES);
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
*/		// **FINISH**

		// WhatArm
		ItemName		= SysAllocString(L"WhatArm");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetFromPropertyBag(&ItemName,ItemValue);  //2nd argument is return value (look retval for help)
		m_bWhatArm	= (bool)*ItemValue;
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**

		// NumOfSteps
		ItemName		= SysAllocString(L"NumOfSteps");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetFromPropertyBag(&ItemName,ItemValue);  //2nd argument is return value (look retval for help)
		m_sNumOfSteps	= (short)*ItemValue;
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**

		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);
		
		// Release
		pIPB->Release();
		
return S_OK;
}

STDMETHODIMP CNewValveController::DoHomingRoutine()
{
	int iResult;				//

	// Pass WhatArm data to the PIDController local variable.
	// This is important b/c every function in the PIDCont class allocates data depending on this variable.

	// Initialize Cards.
	InitializeCards();

	// Print message
	m_bstrError = SysAllocString(L"Initializing... Please wait.");

	// Perform the Homing Routine by calling initialize valves
	iResult = InitializeValves();
	if(iResult != 1) m_bstrError = SysAllocString(L"Error calling Initialize::InitializeValves()");
	Sleep(5000);

	// Reset Encoders
	// This is a crucial step. It is used so that the ENCODERS are reset every time before we use the arm.
	// When power is given to an encoder, it marks the current position as it's ZERO position. 
	// We have to try to find a way to have a consistent starting position. We do this after moving the
	// arms to the home position.
	// Resetting encoders at the beginning however, does not guarantee an exact home position. 
	// But this is what we are working with at this time.
	ResetEncoders();

	// Read encoders at home position
	// Arm should be in an L-position for this reading to be accurate.
	// Convert encoder values to Joint Angles
	iResult = ReadJointAngles();					// Angles are sent to the CurrentAngles VS through the ReadJointAngles methods.
	if(iResult != 0) m_bstrError = SysAllocString(L"Error calling Initialize::InitializeValves()");

	// Set the gains for the controller
	SetGains();

	// Write the desire home values
	DesiredHomeValues();

	// Print message
	m_bstrError = SysAllocString(L"Arm has successfully initialized.");

	return S_OK;
}

/*****************************************************************************************
* Closed-Loop Controller. 
* Uses only P-parameter. 
*
* This function basically moves the arms to the desired positions.
* 1) Check to make sure arm is connected.
* 2) It gets the desired angles,
* 3) Get the actual angles and computes the error, mulitplied by a gain,
* 4) It updates the voltage values to drive the joints to the desired positions.
*
* NOTE!!
* This function is closely tied to the kinematics of the robot. 
* Typically we like to assume that ISAC's arms are like a PUMA arm. Having a base, shoulder,
* elbow and a spherical wrist (roll, pitch, yaw). However, with the pressure system
* we have it's hard to practically reach workspace points produced by the kinematics. 
* Additionally, to have a PUMA configuration, we must have a L-plate on the wrist and 
* inflate both of the upper fore-arm muscle to create the ability to have a yaw motion.
* 
* For this work, we will freeze the yaw angle and only worry about the roll and pitch. 
* Hence the encoder value for the 6th angle will be ignored. 
* 
* I hope that the next idea does not confuse you too much. So we want to react to changes in roll
* angles. The natural way to do this, would be by changing the rotation angle controlled by the 
* biceps. But since these biceps do not have a wide range of motion, let's not move them and 
* instead adjust the fore-arm muscles to minimize error in the roll angle. 
*****************************************************************************************/
STDMETHODIMP CNewValveController::Move()
{
	// Local variables
	int		i;
	int		count = 0;
	double	m_dDesiredAngles[NUM_AXES];
	HRESULT hRes;

	SAFEARRAY	  *mysa;
	IVectorSignal *pIVSDesAng;
	
	//*************************************************************
	//* 1) Make sure there is a connection before calling anything. 
	//*************************************************************/
	if(m_bConnected == TRUE)
	{

		// Print message
		m_bstrError = SysAllocString(L"Moving...");

		//*****************************************************/
		// 2) ) Get desired angles.
		//*****************************************************/	
		// Get object and interface pointer
		m_Bindings->get_Pointers(SysAllocString(L"DesiredAngles"),&m_pIUnkDesiredAngles);
		if (m_pIUnkDesiredAngles == NULL) return !S_OK;
			m_pIUnkDesiredAngles->QueryInterface(IID_IVectorSignal,(void**)&pIVSDesAng);

		if (pIVSDesAng != NULL)
		{
				mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
				pIVSDesAng->GetCurrentVector(mysa);
				memcpy(m_dDesiredAngles, mysa->pvData, sizeof(double)*NUM_AXES);	// We have to do this, b/c in the memcpy cannot copy correctly 
				for(i=0;i<NUM_AXES;i++) m_dDesiredAngles[i] = m_dDesiredAngles[i];	// a mysa of type double to another member that is not a double
				SafeArrayDestroy(mysa);
				pIVSDesAng->Release();
		}
		else	// We don't have all the right connections so release and signal error.
		{
			if (pIVSDesAng != NULL)
				pIVSDesAng->Release();

			return !S_OK;
		}
	
		// Copy current angles into a previousAngles array
		//for(i=0; i<NUM_AXES; i++) m_dPreviousAngles[i] = m_dAngles[i];	// This serves to compute joint velocities
		// Used these for some experiments... erase these for normal use.
		m_dDesiredAngles[3] = 0.0;
		m_dDesiredAngles[4] = 90.0;
		m_dDesiredAngles[5] = 0.0;

		/*****************************************************/
		// 3) Run the PID loop
		/*****************************************************/
		if(m_bWhatArm == RIGHT_ARM)
		{
			// Run loop until errors are neglibilbe or a certain number of steps is reached.
			while( m_dErrorOutput[0] > 0.01 && m_dErrorOutput[1] > 0.01 && m_dErrorOutput[2] > 0.01 && m_dErrorOutput[3] > 0.01 && m_dErrorOutput[4] > 0.01 && m_dErrorOutput[5] > 0.01 || count<m_sNumOfSteps)
			{			
				ReadJointAngles();	// Computed m_dAngles.

				// 2) Compute error between desired and actual angles and multiply by gain
				for(int i=0; i<NUM_AXES; i++)	
					m_dErrorOutput[i] = m_dPGain[i] * (m_dDesiredAngles[i] - m_dAngles[i]) /*+m_dDGain * (m_dPrevDesiredAngles[i] - m_dPrevAngles[i])*/;
				
				// 3) Add Error output to current Valve output
				// Home position angles are: Right {0,-90,180,0,-90,0}

				// Note: The following section is establishing the direction of the coordinate frames
				//       for ISACs frames and will directly affect how the kinematics of the robot are computed.
				//       The conventions followed here follow those of a right PUMA arm.
				// Base Angle. 
				// If DesiredAngles > ActualAngles, move in the positive z-axes direction.
				// That means that we ought to increase the voltage in the front muscle, and decrease the voltage in the back muscle.
				m_dValveOutputs[0] = m_dValveOutputs[0] - m_dErrorOutput[0];	// Back muscle
				m_dValveOutputs[1] = m_dValveOutputs[1] + m_dErrorOutput[0];	// Front muscle
					
				// Shoulder Angles.
				// Range 45 degrees to 90 degrees.
				// If Desired Angles < Actual Angles, move arm up (in this case error is negative).
				// Inflate back muscle, deflate front muscle. 
				m_dValveOutputs[2] = m_dValveOutputs[2] + m_dErrorOutput[1];	// Front muscle. If -ve value this is deflating.
				m_dValveOutputs[3] = m_dValveOutputs[3] - m_dErrorOutput[1];	// Back muscle

				// Elbow Angles			
				// Range -180 to -90 (flexed to straight arms)
				// From 0 to -180 inflate biceps. From -180 to -90 deflate biceps	// Looking towards ISAC
				m_dValveOutputs[4] = m_dValveOutputs[4] + m_dErrorOutput[2];		// Back left-tricep
				m_dValveOutputs[5] = m_dValveOutputs[5] - m_dErrorOutput[2];		// Front left-bicep
				m_dValveOutputs[6] = m_dValveOutputs[6] - m_dErrorOutput[2];		// Front right-bicep
				m_dValveOutputs[7] = m_dValveOutputs[7] + m_dErrorOutput[2];		// Back right-bicep
				
				// Wrist Angles
				// Roll
				// If positive, (Z pointing out of sensor -- agrees with PUMA), 
				// and you are looking into the robot, the wrist turns counter-clockwise.
				// Inflate right front bicep muscle. 
				// Deflate left back bicep muscle. 
				m_dValveOutputs[4] = m_dValveOutputs[4] + m_dErrorOutput[3];	// Left tricpes muscle
				m_dValveOutputs[5] = m_dValveOutputs[5] - m_dErrorOutput[3];	// Left biceps muscle
				m_dValveOutputs[6] = m_dValveOutputs[6] + m_dErrorOutput[3];	// Right biceps muscle
				m_dValveOutputs[7] = m_dValveOutputs[7] - m_dErrorOutput[3];	// Right tricpes muscle

				// Pitch.
				// Wrist moves up and down. 
				// +ve angle moves hand down. 
				// Hence inflate lower muscles. 
				m_dValveOutputs[8] = m_dValveOutputs[8]   + m_dErrorOutput[4];	// Left back fore arm muscle
				m_dValveOutputs[9] = m_dValveOutputs[9]   - m_dErrorOutput[4];	// Left front fore arm muscle
				m_dValveOutputs[10] = m_dValveOutputs[10] - m_dErrorOutput[4];	// Right front fore arm muscle
				m_dValveOutputs[11] = m_dValveOutputs[11] + m_dErrorOutput[4];	// Right back fore arm muscle

				// Yaw
				// Ignored. See explanation in function description.
			  /*m_dValveOutputs[8]  = m_dValveOutputs[8]  - m_dErrorOutput[5];
				m_dValveOutputs[9]  = m_dValveOutputs[9]  - m_dErrorOutput[5];
				m_dValveOutputs[10] = m_dValveOutputs[10] + m_dErrorOutput[5];
				m_dValveOutputs[11] = m_dValveOutputs[11] + m_dErrorOutput[5];
				*/

				// Write voltages to hardware
				SetArmVoltages(m_dValveOutputs);

				Sleep(20);
				count++;
			}
		}

		if(m_bWhatArm == LEFT_ARM)
		{
			while( m_dErrorOutput[0] > 0.01 && m_dErrorOutput[1] > 0.01 && m_dErrorOutput[2] > 0.01 && m_dErrorOutput[3] > 0.01 && m_dErrorOutput[4] > 0.01 && m_dErrorOutput[5] > 0.01 || count<m_sNumOfSteps)
			{
				ReadJointAngles();	// Computed m_dAngles.
				
				// 2) Compute error and multiply by gain
				for(int i=0; i<NUM_AXES; i++)	
					m_dErrorOutput[i] = m_dPGain[i] * (m_dDesiredAngles[i] - m_dAngles[i]);
				
				// 3) Add Error output to current Valveoutput
				// Home position angles are: {0, 90, -180, 0, 0, 0}


				// Base Angle. 
				// If DesiredAngles > ActualAngles, move in the positive z-axes direction.
				// That means that we ought to increase the voltage in the front muscle, and decrease the voltage in the back muscle.
				m_dValveOutputs[0] = m_dValveOutputs[0] + m_dErrorOutput[0];	// Front muscle
				m_dValveOutputs[1] = m_dValveOutputs[1] - m_dErrorOutput[0];	// Back muscle
					
				// Shoulder Angles.
				// Range 45 degrees to 90 degrees.
				// If Desired Angles < Actual Angles, move arm up (in this case error is negative).
				// Inflate back muscle, deflate front muscle. 
				m_dValveOutputs[2] = m_dValveOutputs[2] + m_dErrorOutput[1];	// Front muscle
				m_dValveOutputs[3] = m_dValveOutputs[3] - m_dErrorOutput[1];	// Back Muscle
				
				// Elbow Angles			
				// Range -180 to -90 (flexed to straight arms)
				// From 0 to -180 inflate biceps. From -180 to -90 deflate biceps	// Looking towards ISAC
				m_dValveOutputs[4] = m_dValveOutputs[4] + m_dErrorOutput[2];	// Back right-tricep
				m_dValveOutputs[5] = m_dValveOutputs[5] - m_dErrorOutput[2];	// Front right-bicep
				m_dValveOutputs[6] = m_dValveOutputs[6] - m_dErrorOutput[2];	// Front left-bicep
				m_dValveOutputs[7] = m_dValveOutputs[7] + m_dErrorOutput[2];	// Back right-tricep

				// Wrist Angles
				// Roll
				// If positive, palm of hand turns towards the floor.
				// Deflate left bicep muscle. 
				// Inflate left back fore arm muscle. 
				m_dValveOutputs[4] = m_dValveOutputs[4] - m_dErrorOutput[3];	// Right triceps muscle
				m_dValveOutputs[5] = m_dValveOutputs[5] + m_dErrorOutput[3];	// Right biceps muscle
				m_dValveOutputs[6] = m_dValveOutputs[6] - m_dErrorOutput[3];	// Left biceps muscle
				m_dValveOutputs[7] = m_dValveOutputs[7] + m_dErrorOutput[3];	// Left triceps muscle

				// Pitch.
				// Wrist moves up and down. 
				// +ve angle moves hand down. 
				// Hence inflate lower muscles. 
				m_dValveOutputs[8] = m_dValveOutputs[8]   + m_dErrorOutput[4];	// Right back forearm
				m_dValveOutputs[9] = m_dValveOutputs[9]   - m_dErrorOutput[4];	// Right front forearm 
				m_dValveOutputs[10] = m_dValveOutputs[10] + m_dErrorOutput[4];	// Left back forearm
				m_dValveOutputs[11] = m_dValveOutputs[11] - m_dErrorOutput[4];	// Left front forearm

				// Yaw
				// Ignored. See explanation in function description.
				/*m_dValveOutputs[8] = m_dValveOutputs[8]   - m_dErrorOutput[5];
				m_dValveOutputs[9] = m_dValveOutputs[9]   - m_dErrorOutput[5];
				m_dValveOutputs[10] = m_dValveOutputs[10] + m_dErrorOutput[5];
				m_dValveOutputs[11] = m_dValveOutputs[11] + m_dErrorOutput[5];
				*/

				//*******************************
				//* 4) Write voltages to hardware
				//********************************/
				SetArmVoltages(m_dValveOutputs);

				Sleep(20);
				count++;
			}

		}
	}

	else	// Call the DoHomingRoutine
		hRes = DoHomingRoutine();

	return S_OK;
}

/*******************************************************************************
* Close()
*
* First call arm to go to home position to avoid accidents, then close vavles.
*
* Closes valves for either arm by decrementing the voltage by 0.1 in each 
* iteration of the loop. 
* 
* The maximum voltage is 3.6 Volts, so at most there will be 36 iterations. 
*******************************************************************************/
STDMETHODIMP CNewValveController::Close()
{	
	// Local Variables
	int		retval;
	int		i=0,j=0,k=0;
	double	bufferVoltage = 0.1;
	
	// Call close only if we have called the Initialization routine
	if(m_bConnected == TRUE)
	{
		// Go to home position - helps make sure you don't hit a table if it is front.
		//**//retval = GoToHomePosition();

		// Reset pressures. Drive arms from current position to zero prssure.
		ResetVoltages();

		// Close the cards
		vitalQuit();
		Sleep(100);

		// Update connection flag
		m_bstrError = SysAllocString(L"Valves have been successfully closed.");
		m_bConnected = FALSE;
	}

	else
	{
		InitializeCards();
		ResetVoltages();
	}


	return S_OK;
}


/*********************************
******** PROPERTIES **************
**********************************/
STDMETHODIMP CNewValveController::get_ValveOutputsIndex(short *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
		*pVal = m_sValveOutputsIndex;
	return S_OK;
}

STDMETHODIMP CNewValveController::put_ValveOutputsIndex(short newVal)
{
	// TODO: Add your implementation code here
	if (newVal >= 0 && newVal <= 11)
		m_sValveOutputsIndex = newVal;
	return S_OK;
}

STDMETHODIMP CNewValveController::get_ValveOutputs(double *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
		*pVal = m_dValveOutputs[m_sValveOutputsIndex];
	return S_OK;
}

/***************************************************************
* put_ValveOutputs()
* This function reads the desired voltage from the user.
* It then computes the error difference between the current value and
* the desired value.
* 
* The differene is then added to the current values in a number of steps.
* The function calls ReadJointAngles() at the end, so the user can see 
* how the joint angles were affected by the change in pressure. 
*
* Works for right and left arms.
* 
* Pressure values can only go from 0 - 3.6
***************************************************************/
STDMETHODIMP CNewValveController::put_ValveOutputs(double newVal)
{
	// Local variable
	int i = 0;
	double tempVoltage, Error = 0.0;

	if(m_bConnected)
	{
		// Update value in tempVoltage given by user
		if(newVal >= 0 && newVal <= 3.6)
			tempVoltage = newVal;

		// Compute Error
		// Desired - Actual/inflation_rate
		Error = (double)(tempVoltage - m_dValveOutputs[m_sValveOutputsIndex])/m_sInflationRate;

		// Perform inflation according to inflation rate
		for(i=0; i<m_sInflationRate; i++)
		{
			// Add error term to current position in incremental steps for the respective arm.
			m_dValveOutputs[m_sValveOutputsIndex] = m_dValveOutputs[m_sValveOutputsIndex] + Error;

			// Pass our voltage values to SetArmVoltages(). This function accounts for the differnce or right or left arm.
			SetArmVoltages(m_dValveOutputs);
			Sleep(100);
		}		

		m_bstrError = SysAllocString(L"Desired voltage has been set.");
		ReadJointAngles();
	}

	else
	{
		InitializeCards();
		put_ValveOutputs(newVal);
	}


	return S_OK;
}

/*****************************************************************************
* ErrorMessage()
* Prints error message in DAD. The error message comes from the currently
* running method. The goal is to ease debugging.
*****************************************************************************/
STDMETHODIMP CNewValveController::get_ErrorMessage(BSTR *pVal)
{
	// TODO: Add your implementation code here
	if (pVal != NULL)
		*pVal = m_bstrError;			// Other functions will copy error msg to m_bstrError

	return S_OK;
}

STDMETHODIMP CNewValveController::put_ErrorMessage(BSTR newVal)
{
	// Keep empty. We don't want the user to change this.
	m_bstrError = SysAllocString(L"This component controlls valves and has PID or NN Controller");

	return S_OK;
}

/******************************************************************************
* WhatArm()
* User selects what arm is in operation.
* Values are as follows: 0 = RIGHT ARM, 1 = LEFT ARM
******************************************************************************/
STDMETHODIMP CNewValveController::get_WhatArm(BSTR *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
	{
		if (m_bWhatArm == RIGHT_ARM)
				*pVal = SysAllocString(L"RIGHT");
	
		if (m_bWhatArm == LEFT_ARM)
			*pVal = SysAllocString(L"LEFT");
	}

	return S_OK;
}

STDMETHODIMP CNewValveController::put_WhatArm(BSTR newVal)
{
	USES_CONVERSION;	// Macro to use string conversions
	// Set tags for internal variable
	if(strcmp(strupr(OLE2T(newVal)),"RIGHT")==0)
	{
		m_bWhatArm = RIGHT_ARM;
		m_bstrError = SysAllocString(L"You have selected the right arm");
	}

	else if(strcmp(strupr(OLE2T(newVal)),"LEFT")==0)
	{
		m_bWhatArm = LEFT_ARM;
		m_bstrError = SysAllocString(L"You have selected the left arm");
	}

	// Otherwise do not copy to local variable and print warning message
	else
		m_bstrError = SysAllocString(L"Please either enter RIGHT or LEFT");
	return S_OK;
}

STDMETHODIMP CNewValveController::get_JointAngles(double *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
		*pVal = m_dAngles[m_sAnglesIndex];
	return S_OK;
}

STDMETHODIMP CNewValveController::put_JointAngles(double newVal)
{
	// TODO: Add your implementation code here
	if(newVal >= -180 && newVal <= 180)
		m_dAngles[m_sAnglesIndex] = newVal;
	return S_OK;
}

STDMETHODIMP CNewValveController::get_JointAnglesIndex(short *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
		*pVal = m_sAnglesIndex;
	return S_OK;
}

STDMETHODIMP CNewValveController::put_JointAnglesIndex(short newVal)
{
	if(newVal >= 0 && newVal <6)
		m_sAnglesIndex = newVal;
	return S_OK;
}


STDMETHODIMP CNewValveController::get_gain_PGainValue(double *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
		*pVal = m_dPGain[m_sPGainIndex];
	return S_OK;
}

STDMETHODIMP CNewValveController::put_gain_PGainValue(double newVal)
{
	// TODO: Add your implementation code here
	m_dPGain[m_sPGainIndex] = newVal;
	return S_OK;
}

STDMETHODIMP CNewValveController::get_gain_PGainValueIndex(short *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
		*pVal = m_sPGainIndex;
	return S_OK;
}

STDMETHODIMP CNewValveController::put_gain_PGainValueIndex(short newVal)
{
	// TODO: Add your implementation code here
	if( (newVal >= 0) && (newVal < 6) )
		m_sPGainIndex = newVal;
	return S_OK;
}

void CNewValveController::InitializeCards()
{

	m_bstrError = SysAllocString(L"Initializing Cards!!");	
	
	// Code used to copy an integer into the BSTR
	int		numCards = 0;
	BSTR	str1 = SysAllocString(L"Detected number of cards: ");
	BSTR	str2 = NULL;
	long	len1, len2;
	char	temp_buffer[10];

	// Initialize the Cards
	if( numCards = vitalInit() )
	{
		// Copy number of initialize cards into BSTR
		// Convert the integer to a char*, and then use _bstr_t to convert to a BSTR
		_itoa(numCards,temp_buffer,10);
		str2 = bstr_t(temp_buffer);
		
		// Calc len of strings
		len1 = SysStringLen(str1);
		len2 = SysStringLen(str2);
		m_bstrError = SysAllocStringLen(NULL, len1 + len2);			// Assign length to result
		// Use memcpy to concatenate the two BSTRs
		memcpy(m_bstrError,      str1, len1 * sizeof(OLECHAR));		// Copy first string
		memcpy(m_bstrError+len1, str2, len2 * sizeof(OLECHAR));		// Copy second string
		
		m_bstrError[len1+len2] = NULL;
	}
	
	else
	{
		numCards=0;
		m_bstrError = SysAllocString(L"Error initializing WinMotenc library" );
	}

	// Set connection flag to true
	m_bConnected = TRUE;

}

/*********************************************************************
* InitializeValves()
*
* This is the Homing Procedure.
* The values for these muscles were calculated by inspection
* in order for the arm to go to the HOME position. Incrementally moves
* from rest position to home position.
*
* The first motion moves the arm backwards to avoid hitting the table
* commonly used in front of ISAC.
*
* Note:
* Examine often if the arms are going back to the exact home position.
* Sometimes different factors like muscle properties or encoder errors
* may affect this.
*********************************************************************/
int CNewValveController::InitializeValves()
{
	// Local variables
	int i=0, j=0, k=0;
	double ErrorOutput[NUM_AXES*2]		= {0};

	// Set the InitialVoltage values to m_dInitialValveOutputs[].
	SetHomePositionVoltages();

	// Read Current voltages. Normally 0, except from when arm did not deflate completely on closing, set value on m_dValveOutputs[]
	ReadVoltages();

	// Compute error between desired and actual angles and divide by inflation rate
	for(i=0; i<NUM_AXES*2; i++)	
		ErrorOutput[i] = (m_dInitialValveOutputs[i] - m_dValveOutputs[i])/m_sInflationRate;

	// Inflate the muscles.
	// Current Voltage + Error, over the complete number of steps
	for(i=0; i<m_sInflationRate; i++) 
	{
		for(j=0; j<NUM_AXES*2; j++)
		{
			m_dValveOutputs[j] = m_dValveOutputs[j] + ErrorOutput[j];
		}
			// Set Arm voltages
			SetArmVoltages(m_dValveOutputs);
			Sleep(100);		
	}

	return 1;
}


/*********************************************************
* ResetEncoder()
* This function plays a crucial role in initializing
* the encoder at the right location in order to have
* the same home position every time. 
*
* This function is called after the arm has been moved
* to the Home position.
*********************************************************/
void CNewValveController::ResetEncoders()
{

	if(m_bWhatArm == RIGHT_ARM)
	{
		// Select last 2 channels in board (1), and all channels in board (2).
		vitalSelectBoard(1);
		for(int m_sChannel=2;m_sChannel<4;m_sChannel++)
			vitalResetCounter(m_sChannel);
		vitalSelectBoard(2);
		for(m_sChannel=0;m_sChannel<4;m_sChannel++)
			vitalResetCounter(m_sChannel);
	}

	if(m_bWhatArm == LEFT_ARM)
	{
		// Select all channels in board (0), and first 2 channels in board (1).
		vitalSelectBoard(0);
		for(int m_sChannel=0;m_sChannel<4;m_sChannel++)
			vitalResetCounter(m_sChannel);
		vitalSelectBoard(1);
		for(m_sChannel=0;m_sChannel<2;m_sChannel++)
			vitalResetCounter(m_sChannel);
	}


}


/*******************************************************************
* ReadEncoders()
*
* Function OUTPUTS encoder values by talking to the
* Motenc cards. Calls vitalEncoderRead().
* 
* Each encoder board holds 4 values. 
*
* Left arm:  Board 0:0-3, Board 1:0-1
* Right arm: Board 1:2-3, Board 2:0-3
*
* Each card contains 4 enconder connections.
* The Left encoders are: all 4 channels in board 0, and
* the first 2 channels in board 1. The Right encoders
* are the last 2 channels in board 1, and all 4 in board 2.
*
* Values are saved in the private array m_dEncoders[6].
*******************************************************************/

void CNewValveController::ReadEncoders()
{	
	
	if(m_bWhatArm == LEFT_ARM)
	{
		vitalSelectBoard(0);
		for(int m_sChannel=0;m_sChannel<4;m_sChannel++)
			vitalEncoderRead(m_sChannel, /*[out]*/&m_dEncoders[m_sChannel]);

		// Switch to Board(1) and first 2 channels
		vitalSelectBoard(1);
		for(m_sChannel=0;m_sChannel<2;m_sChannel++)
			vitalEncoderRead(m_sChannel, /*[out]*/&m_dEncoders[m_sChannel+4]);		// Input to index 4 and 5.

		// The encoders at positions 2 and 5, need to have negative values to reflect that particular angle. 
		m_dEncoders[2]*=-1;
		m_dEncoders[5]*=-1;				

		//m_bstrError = SysAllocString(L"LeftArm Encoder values were read.");
	}

	if(m_bWhatArm == RIGHT_ARM)
	{
		// Select Board(1), and channels 2 and 3. 
		vitalSelectBoard(1);
		
		//!!!First two encoders are flipped!!! 
		// This was determined through testing the hardware values.
		vitalEncoderRead(2, &m_dEncoders[1]);	// Channel 2, actually belongs to Encoder[1].
		vitalEncoderRead(3, &m_dEncoders[0]);

		// Switch to board 2 and read from all 4 channels.
		vitalSelectBoard(2);
		for(int m_sChannel=0; m_sChannel<4; m_sChannel++)
			vitalEncoderRead(m_sChannel, &m_dEncoders[m_sChannel+2]);	// Input into index items: 2-5.

		// The encoders for the shoulder and elbow should be negative of their current result.
		m_dEncoders[1]*=-1;
		m_dEncoders[2]*=-1;

		//m_bstrError = SysAllocString(L"RightArm Encoder values were read.");

	}

	
}


/**************************************************************
* ReadJointAngles()
* This function first calls ReadEncoders() to get updated values
* for the encoder readings. 
*
* This routine then transforms encoder values to degrees, and then 
* adjusts them to fit the DH paramters for a PUMA model.
*
* The joint angles are a result of a combination of the encoder values.
* See the arm manual for more: O:\Components\ArmComponents
* LogicalAngle[0] =		 PhysicalAngle[0];						// Base Joint
* LogicalAngle[1] =		 PhysicalAngle[1];						// Shoulder Joint
* LogicalAngle[2] = 0.5*(PhysicalAngle[2] + PhysicalAngle[3])	// Elbow Joint (the bicep curl is an average of both encoder values)
* LogicalAngle[3] =		 PhysicalAngle[2] - PhysicalAngle[3]	// Roll.  The angle is the difference between one side and the other. 
* LogicalAngle[4] = 0.5*(PhysicalAngle[4] + PhysicalAngle[5])	// Pitch. The angle is the average. 
* LogicalAngle[5] =		 PhysicalAngle[4] - PhysicalAngle[5]	// Yaw.   The angle is the difference between one side and the other.
*
* A physical angles is encoder_reading/encoder_gain.
*
* m_dEncoderGain[0]	= -5092.0;
* m_dEncoderGain[1]	=  5092.0;
* m_dEncoderGain[2]	=  4244.0;
* m_dEncoderGain[3]	= -4244.0;
* m_dEncoderGain[4]	=   636.6;
* m_dEncoderGain[5]	=  -636.6;
*
* Copies values out to CurrentAngles VS.
***************************************************************/
int CNewValveController::ReadJointAngles()
{
	// 1) Read the encoders
	ReadEncoders();

	// 2) Convert encoder gains to PhysicalAngles
	m_dPhysicalAngle[0] =   m_dEncoders[0] / m_dEncoderGain[0];
	m_dPhysicalAngle[1] =  -m_dEncoders[1] / m_dEncoderGain[1];
	m_dPhysicalAngle[2] =   m_dEncoders[2] / m_dEncoderGain[2];
	m_dPhysicalAngle[3] =  -m_dEncoders[3] / m_dEncoderGain[3];
	m_dPhysicalAngle[4] =  -m_dEncoders[4] / m_dEncoderGain[4];
	m_dPhysicalAngle[5] =  -m_dEncoders[5] / m_dEncoderGain[5];

	// 2) Compute Joint angles (right arm)
	// Assigning a left arm puma configuration the home angles should be: {0,90,-180,0,90,}
	if(m_bWhatArm == LEFT_ARM)
	{		
		// DesiredAngle  =       EncoderPosition / Encoder Resolution 
		m_dAngles[0] =		   (-m_dPhysicalAngle[0]							   ) * RADS2DEGREE;
		m_dAngles[1] =		   ( m_dPhysicalAngle[1]						+ PI/2 ) * RADS2DEGREE;
		m_dAngles[2] =	(0.5 * (-m_dPhysicalAngle[3] - m_dPhysicalAngle[2])	- PI   ) * RADS2DEGREE;
		m_dAngles[3] =		   ( m_dPhysicalAngle[3] - m_dPhysicalAngle[2])			 * RADS2DEGREE;
		m_dAngles[4] =  (0.5 * ( m_dPhysicalAngle[4] - m_dPhysicalAngle[5])	+ PI/2 ) * RADS2DEGREE;
		m_dAngles[5] =		   ( m_dPhysicalAngle[4] + m_dPhysicalAngle[5])		     * RADS2DEGREE;
	}
	
	if(m_bWhatArm == RIGHT_ARM)
	{
		m_dAngles[0] =		  (m_dPhysicalAngle[0]									) * RADS2DEGREE;
		m_dAngles[1] =		  (m_dPhysicalAngle[1] 						    + PI/2	) * RADS2DEGREE;
		m_dAngles[2] = (0.5 * (m_dPhysicalAngle[3] + m_dPhysicalAngle[2] )  - PI	) * RADS2DEGREE;	// Elbow joint
		m_dAngles[3] =		  (m_dPhysicalAngle[3] - m_dPhysicalAngle[2] )			  * RADS2DEGREE;	// Roll Angle		
		m_dAngles[4] = (0.5 * (m_dPhysicalAngle[4] + m_dPhysicalAngle[5] )	+ PI/2 )  * RADS2DEGREE;	// Pitch angle. **Could add a -90 term to have it as old ISAC
		m_dAngles[5] =		  (m_dPhysicalAngle[4] - m_dPhysicalAngle[5] )		      * RADS2DEGREE;	// Yaw angle
	}

	// Copy Angle information to the VectorSignal 'CurrentAngles'
	/*** Pass this information to the 'Actual Angles VS'. ***/
	// Get Object and Interface Pointer
	SAFEARRAY		*mysa;
	IVectorSignal	*pIVSCurrentAngles = NULL;
	m_Bindings->get_Pointers(SysAllocString(L"CurrentAngles"), &m_pIUnkCurrentAngles);
	if(m_pIUnkCurrentAngles == NULL)	return !S_OK;

	m_pIUnkCurrentAngles->QueryInterface(IID_IVectorSignal, (void**)&pIVSCurrentAngles);
	if(pIVSCurrentAngles == NULL)	return !S_OK;

	// Set VS with current angle data
	mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
	memcpy(mysa->pvData,m_dAngles,sizeof(double)*NUM_AXES);
	pIVSCurrentAngles->SetCurrentVector(mysa);

	// Clear allocations
	pIVSCurrentAngles->Release();
	SafeArrayDestroy(mysa);

	return S_OK;
}

/****************************************************
* SetArmVoltages(double *bufferVoltages)
*
* Function writes voltage values for right or left arm
* by talking to the Motenc cards. 
* Calls vitalDacWrite().
*
* We have to write 12 valve values. For a total of 24 
* valves for the two arms.
* There are 3 boards {0,1,2}. Each board has 8 channels.
* 
* The Left arm is: Board0, Channels 0-7
*             and: Board1, Channels 0-3
* 
* The Right arm's: Board1, Channels 4-7
*			  and: Board2, Channels 0-8
*
* The Triceps for Left  arm are 0.5 and 1.0
* The Tricpes for Right arm are 2.0 and 2.3
*
* Voltage values cannont be 0 or greater than 3.6.
****************************************************/
int CNewValveController::SetArmVoltages(double bufferVoltages[])
{
	if(m_bWhatArm == LEFT_ARM)
	{
		// Select Board 0.
		vitalSelectBoard(0);

		// Write values and check for pressure limits (no negative values nothing greater than 3.6volts).
		// Select the first 8 channels of board (0) and the first 4 channels of board (1).

		// 0.0-7
		for(m_sChannel=0; m_sChannel<8; m_sChannel++) 
		{
			if (bufferVoltages[m_sChannel] < 0.0 )
			{			
				m_bstrError = SysAllocString(L"Left shoulder & biceps 0.0-7. You are trying to set a negative pressure.");
				bufferVoltages[m_sChannel] = 0.0;
			}
			if (bufferVoltages[m_sChannel] > 3.6 )
			{
				m_bstrError = SysAllocString(L"Left shoulder & biceps 0.0-7. You are trying to insert too much pressure.");
				bufferVoltages[m_sChannel] = 3.6;				
			}

			/**** Note: We will not be using the left arm triceps. So we won't write a voltage to them. ***/
			if( m_sChannel!=4 && m_sChannel !=7 ) 
			vitalDacWrite(m_sChannel, bufferVoltages[m_sChannel] );
		}
		// Switch to board (1).
		vitalSelectBoard(1);
		
		// 1.0-1.3. Forearms.
		for(m_sChannel=0; m_sChannel<4; m_sChannel++) 
		{
			if (bufferVoltages[m_sChannel+8] < 0.0 )
			{
				m_bstrError = SysAllocString(L"Left Arm biceps/forearms 1.1-3. You are trying to set a negative pressure.");
				bufferVoltages[m_sChannel+8] = 0.0;
			}
			if (bufferVoltages[m_sChannel+8] > 3.6 )
			{
				m_bstrError = SysAllocString(L"Left Arm biceps/forearms 1.1-3. You are trying to insert too much pressure.");
				bufferVoltages[m_sChannel+8] = 3.6;
			}
			// Write the voltages
			vitalDacWrite( m_sChannel, bufferVoltages[m_sChannel+8] );
		}

	}

	if(m_bWhatArm == RIGHT_ARM)
	{
		// Select board (1)
		vitalSelectBoard(1);
		for(m_sChannel=4; m_sChannel<8; m_sChannel++) 
		{
			if (bufferVoltages[m_sChannel-4] < 0.0 )
			{
				m_bstrError = SysAllocString(L"Right Arm. 1.4-1.7. You are trying to set a negative pressure.");
				bufferVoltages[m_sChannel-4] = 0.0;
			}
			if (bufferVoltages[m_sChannel-4] > 3.6 )
			{
				m_bstrError = SysAllocString(L"Right Arm. 1.4-1.7. You are trying to insert too much pressure.");
				bufferVoltages[m_sChannel-4] = 3.6;
			}
			vitalDacWrite( m_sChannel, bufferVoltages[m_sChannel-4] );
		}
		vitalSelectBoard(2);
		for(m_sChannel=0;m_sChannel<8;m_sChannel++) // giving reference to first 4 m_sChannel of board 1
		{
			if (bufferVoltages[m_sChannel+4] < 0.0 )
			{
				m_bstrError = SysAllocString(L"Right Arm biceps/forearms. 2.0-2.7. You are trying to set a negative pressure.");
				bufferVoltages[m_sChannel+4] = 0.0;
			}
			if (bufferVoltages[m_sChannel+4] > 3.6 )
			{
				m_bstrError = SysAllocString(L"Right Arm biceps/forearms. 2.0-2.7. You are trying to insert too much pressure.");
				bufferVoltages[m_sChannel+4] = 3.6;
			}

			/**** Note: We will not be using the right arm triceps (2.0 and 2.3). So we won't write a voltage to them. ***/
			if ( m_sChannel!=0 && m_sChannel!=3) 
				vitalDacWrite( m_sChannel, bufferVoltages[m_sChannel+4] );
		}
	}

	// Copy VoltageValues to Vector Signal
	// Get Object and Interface Pointer
/*	SAFEARRAY		*mysa;
	IVectorSignal	*pIVSValveVoltages = NULL;
	m_Bindings->get_Pointers(SysAllocString(L"ValveVoltages"), &m_pIUnkValveVoltages);
	if(m_pIUnkValveVoltages == NULL)	return !S_OK;

	m_pIUnkValveVoltages->QueryInterface(IID_IVectorSignal, (void**)&pIVSValveVoltages);
	if(pIVSValveVoltages == NULL)	return !S_OK;

	// Set VS with current voltage data
	mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES*2);
	memcpy(mysa->pvData,bufferVoltages,sizeof(double)*(NUM_AXES*2) );
	pIVSValveVoltages->SetCurrentVector(mysa);

	// Clear allocations
	pIVSValveVoltages->Release();
	SafeArrayDestroy(mysa);
*/
	return 1;
}

/*****************************************************************************
* GoToHomePosition()
* Computes pressure values to make arms form L-shape (home position)
* It goes from current position m_dValveOutput[] to the values assigned by m_dInitialValveOutputs[],
* in small steps.
*
* Calls SetArmVoltages() to write to the HW.
*****************************************************************************/
int CNewValveController::GoToHomePosition()
{
	// Local variables
	int		i=0, j=0, k=0;
	double	bufferVoltages[NUM_AXES*2]={0};

	// Print message
	m_bstrError = SysAllocString(L"Moving arm to home position.");

	// Read Current voltages
	ReadVoltages();
	
	// For the Right Arm 1.4-7, 2.0-7
	// Compute all the values for bufferVoltages
	if(m_bWhatArm == RIGHT_ARM)
	{
		for(i=0; i<m_sInflationRate; i++)
		{
			for(j=0;j<NUM_AXES*2;j++) // giving reference to first 4 channels of board 1
				bufferVoltages[j] = m_dValveOutputs[j] - (m_dValveOutputs[j] - m_dInitialValveOutputs[j])*(double)i/m_sDeflationRate ; // ie CurrPress - CurrPress/TotNumSteps			

			// Pass our voltage values to SetArmVoltages()
			SetArmVoltages(bufferVoltages);
			Sleep(100);
		}		
		
		m_bstrError = SysAllocString(L"GoHome() - Moved right arm to the home position.");

	}

	// For the left arm. 0.0-7, 1.0-3
	if(m_bWhatArm == LEFT_ARM)
	{
		for(i=0; i<m_sDeflationRate; i++)
		{
			for(j=0;j<NUM_AXES*2;j++) 
				bufferVoltages[j] = m_dValveOutputs[j] - (m_dValveOutputs[j] - m_dInitialValveOutputs[j])*(double)i/m_sDeflationRate; // ie CurrPress - CurrPress/TotNumSteps
			
			// Pass our voltage values to SetArmVoltages()
			SetArmVoltages(bufferVoltages);
			Sleep(100);
		}
	
		m_bstrError = SysAllocString(L"GoHome() - Moved left arm to the home position.");
	}
	
	return 1;
}
/*************************************************
* ReadVoltages()
*
* Uses the call vitalReadAnalogInputs() to:
* 1) Read the output voltage in millivolts.
* 
* Need to convert output voltage to input voltage.
*
* Note on Voltages:
* This valve has two types of reference voltages.
* (A) Input Voltage,  with a range of 0-10V.
* (B) Output Voltage, with a range of 1-5V.
* 
* Both of these ranges correspond to a pressure of 0.7-130PSI
*
* Conversions:
* (A) 1V = 12.93  PSI
* (B) 1V = 32.325 PSI
* 
* To go from output voltage to input voltage we need to:
* 1) Convert Vo from millivolts to volts,
* 2) Find the output voltage change: CurrReading - 1.0 Volts.
* 3) Multiply times the ratio factor between output and input vector:
*	 32.325/12.93 = 2.5
* 
* Hence, Vi = (Vo-1000)*2.5/1000;
*************************************************/
void CNewValveController::ReadVoltages()
{
	// Local variables
	int	   i, channel		=  0;
	double OutputVoltage[4] = {0};

	if(m_bConnected == TRUE)
	{
		if (m_bWhatArm == LEFT_ARM)
		{
			// Filter pressures by averaging over 5 runs.
			for(i=0;i<5;i++)
			{
				// Board 0
				vitalSelectBoard(0);

				// First 4 channels
				vitalReadAnalogInputs( 0, OutputVoltage);
				for(int channel=0; channel<4;channel++)
				{
					OutputVoltage[channel] = OutputVoltage[channel] - 1000;
					m_dValveOutputs[channel] = m_dValveOutputs[channel] + OutputVoltage[channel]*OUTPUTVOLTAGE_2_INPUTVOLTAGE;		// We add the pressures and at the end divide
				}

				// Last 4 channels
				vitalReadAnalogInputs( 1, OutputVoltage);
				for(channel=4;channel<8;channel++)
				{
					OutputVoltage[channel-4] = OutputVoltage[channel-4] - 1000;
					m_dValveOutputs[channel] = m_dValveOutputs[channel] + OutputVoltage[channel-4]*OUTPUTVOLTAGE_2_INPUTVOLTAGE;
				}

				// Board 1
				vitalSelectBoard(1);

				// First 4 channels
				vitalReadAnalogInputs( 0, OutputVoltage);
				for(channel=8;channel<12;channel++)
				{
					OutputVoltage[channel-8] = OutputVoltage[channel-8] - 1000;
					m_dValveOutputs[channel] = m_dValveOutputs[channel] + OutputVoltage[channel-8]*OUTPUTVOLTAGE_2_INPUTVOLTAGE;
				}
			}

			// there is a problem with the 10th muscle
			//m_dValveOutputs[9]-=100;		
		}	
		
		// Right ARM
		if (m_bWhatArm == RIGHT_ARM)
		{
			// Filter pressures by averaging over 5 runs.
			for(i=0;i<5;i++)
			{
				// Board 1
				vitalSelectBoard(1);

				// Last 4 channels
				vitalReadAnalogInputs( 0, OutputVoltage);
				for(channel=0; channel<4; channel++)
				{
					OutputVoltage[channel] = OutputVoltage[channel] - 1000;	// Vo ranges from 1-5V whilst, Vinput ranges from 0-10V.
					m_dValveOutputs[channel] = m_dValveOutputs[channel] + OutputVoltage[channel]*OUTPUTVOLTAGE_2_INPUTVOLTAGE;		// We add the pressures and at the end divide
				}

				// Board 2
				vitalSelectBoard(2);

				// First 4 channels
				vitalReadAnalogInputs( 0, OutputVoltage);					// this last argument was OutputVoltage changed to OutputVoltage
				for(channel=4;channel<8;channel++)
				{
					OutputVoltage[channel-4] = OutputVoltage[channel-4] - 1000;
					m_dValveOutputs[channel] = m_dValveOutputs[channel] + OutputVoltage[channel-4]*OUTPUTVOLTAGE_2_INPUTVOLTAGE;
				}

				// Last 4 channels
				vitalReadAnalogInputs( 1, OutputVoltage);
				for(channel=8;channel<12;channel++)
				{
					OutputVoltage[channel-8] = OutputVoltage[channel-8] - 1000;
					m_dValveOutputs[channel] = m_dValveOutputs[channel] + OutputVoltage[channel-8]*OUTPUTVOLTAGE_2_INPUTVOLTAGE;
				}
			}
				
			// there is a problem with the 10th muscle
			//m_dValveOutputs[9]-=100;
		}

		// AVERAGING OF VALUES
		for(i=0; i<NUM_AXES*2;i++)
		{
			m_dValveOutputs[i] = m_dValveOutputs[i]/5;
			if(m_dValveOutputs[i] < 0.0)
				m_dValveOutputs[i] = 0.0;
		}

	}		// CONNECTED
}

/******************************************** 
* SetGains()
* Set the gains of the controller depending
* on whether it's the right or left arm.
*********************************************/
void CNewValveController::SetGains()
{
	if(m_bWhatArm==LEFT_ARM)
	{
/*		m_dPGain[0]	= 0.0001;
		m_dPGain[1] = 0.0001;
		m_dPGain[2] = 0.0001;		
		m_dPGain[3] = 0.0001;
		m_dPGain[4] = 0.0001;
		m_dPGain[5]	= 0.0000; // We won't be forcing a PUMA like configuratoin. So Angle q4 and q6 are redundant..  m_dPGain[5] = 0.0030;
*/
		m_dPGain[0]	= 0.0009; /**** NORMAL GAINS ***/
		m_dPGain[1] = 0.0013;
		m_dPGain[2] = 0.0015;		
		m_dPGain[3] = 0.0003;
		m_dPGain[4] = 0.0009;
		m_dPGain[5]	= 0.0000; // We won't be forcing a PUMA like configuratoin. So Angle q4 and q6 are redundant..  m_dPGain[5] = 0.0030;


		// Set inflation rates here too. 
		// The Left arm takes longer to inflate and deflate, so cut these numbers down.
		m_sInflationRate = 35;
		m_sDeflationRate = 100;
	}

	if(m_bWhatArm==RIGHT_ARM)
	{
		// For index 3, the values are opposite
		// m_dPGain[3] = -0.0003; the way the muscles are inflated have been adjusted so that this is necessary (see Move(), in Roll section).
		m_dPGain[5]	=  0.0000;	// m_dPGain[5]	=  0.0015;

		// Set inflation rates here too. 
		// The right arm takes less to inflate and deflate, so cut these numbers down.
		m_sInflationRate = 35;
		m_sDeflationRate = 1000;

	}

}

/************************************************************** 
// Get number of steps (iterations) to run the controller
// in attempts to minimize the error.
**************************************************************/
STDMETHODIMP CNewValveController::get_NumOfSteps(short *pVal)
{
	*pVal = m_sNumOfSteps;
	return S_OK;
}

STDMETHODIMP CNewValveController::put_NumOfSteps(short newVal)
{
	if(newVal > 0 && newVal < 1000)
		m_sNumOfSteps = newVal;
	return S_OK;
}

//////////////////////////////////////////////////////////////////////////
// SetHomePositionVoltages()
// 
// Note: that the configuration for the left and right arms is different.
// These values were calculated empirically to form a correct home position.
// It's important to form right angles in the arm, so that when the encoders are powered
// that becomes the right home position at (0,90,-180,0,90,0).
//
// The compliant nature of the robot will not place the arm in the same place for the same voltages.
// This is challenging. You might find you have to update these for specific experiments.
/////////////////////////////////////////////////////////////////////////
void CNewValveController::SetHomePositionVoltages()
{

	if(m_bWhatArm == LEFT_ARM)
	{
		// Values are understood in pairs as they are agonist and antagonist muscles.
		m_dInitialValveOutputs[0] = 2.3;	// Front base muscle
		m_dInitialValveOutputs[1] = 1.7;	// Back base muscle

		m_dInitialValveOutputs[2] = 2.0;	// Front shoulder muscle
		m_dInitialValveOutputs[3] = 2.0;	// Back shoulder muscle

		m_dInitialValveOutputs[4] = 0.0;	// Back right tricep 
		m_dInitialValveOutputs[5] = 2.25;	// Front right bicep	//2.3
		m_dInitialValveOutputs[6] = 2.35;	// Front left bicep		//2.25
		m_dInitialValveOutputs[7] = 0.0;	// Back left tricep

		m_dInitialValveOutputs[8]  = 2.0;	// Back right forearm muscle
		m_dInitialValveOutputs[9]  = 2.1;	// Front right forearm muscle
		m_dInitialValveOutputs[10] = 2.1;	// Back left forearm muscle
		m_dInitialValveOutputs[11] = 2.05;	// Front left forearm muscle
	}

	if (m_bWhatArm == RIGHT_ARM)
	{
		// Values are understood in pairs as they are agonist and antagonist muscles. Looking into the robot.
		m_dInitialValveOutputs[0] = 2.1;	// Back base muscle
		m_dInitialValveOutputs[1] = 1.9;	// Front base muscle

		m_dInitialValveOutputs[2] = 2.2;	// Front shoulder muscle
		m_dInitialValveOutputs[3] = 1.8;	// Back shoulder muscle

		m_dInitialValveOutputs[4] = 0.0;	// Left Tricep
		m_dInitialValveOutputs[5] = 2.35;	// Left Bicep		
		m_dInitialValveOutputs[6] = 2.30;	// Right Bicep	2.25
		m_dInitialValveOutputs[7] = 0.0;	// Right Tricep

		m_dInitialValveOutputs[8]  = 1.7;	// Left back fore arm muscle	// 1.9
		m_dInitialValveOutputs[9]  = 2.2;	// Left front fore arm muscle	// 2.2
		m_dInitialValveOutputs[10] = 1.8;	// Right front fore arm muscle	// 1.8
		m_dInitialValveOutputs[11] = 2.3;	// Right back fore arm muscle	// 2.1
	}
}
/********************************************************************
* ResetVoltages()
* This function zero's out the pressure
* and the voltage in the arm.
* 
* It does so by:
* Reading current voltages and decrementing them in steps until
* they reach zero.
* 
* The number of steps is m_sDeflationRate define in the header file
*
* It calls SetArmVoltages(double *bufferVoltages) to talk to the HW
********************************************************************/
void CNewValveController::ResetVoltages()
{
	int		i,j = 0;
	double	bufferVoltages[NUM_AXES*2]	= {0};
	double	tempVoltages[NUM_AXES*2]	= {0};

	// Check to make sure the cards have been initialized
	if(m_bConnected == TRUE)
	{
		// Write a message
		SysReAllocString(&m_bstrError,SysAllocString(L"Deflating the muscles. Please wait."));
		//m_bstrError = SysAllocString(L"Deflating the muscles. Please wait.");

		// Read the existing pressures. Value stored in m_dValveOutputs().
		ReadVoltages();

		// Select arm
		// Right arm: 1.4-7, 2.0-7
		if(m_bWhatArm == RIGHT_ARM)
		{
			for(i=0; i<m_sDeflationRate; i++)
			{
				// Decrease the buffer voltages.
				for(j=0;j<NUM_AXES*2;j++) 
				{
					tempVoltages[j] = (m_dValveOutputs[j]*(double)i/m_sDeflationRate);
					bufferVoltages[j] = m_dValveOutputs[j] - tempVoltages[j]; // ie CurrPress - CurrPress/TotNumSteps
				}
				
				// Pass voltages to SetArmVoltages()
				SetArmVoltages(bufferVoltages);
				Sleep(10);						// Arm can deflate quite quickly
			}
		}

		// Left Arm. 0.0-7, 1.0-3
		if(m_bWhatArm == LEFT_ARM)
		{
			// This arm deflates faster, so increase the deflation rate.
			for(i=0; i<m_sDeflationRate*2; i++)
			{
				for(j=0;j<NUM_AXES*2;j++) 
				{
					tempVoltages[j] = (m_dValveOutputs[j]*(double)i/m_sDeflationRate);
					bufferVoltages[j] = m_dValveOutputs[j] - tempVoltages[j]; // ie DesiredPressure = CurrPress + Change
				}
				
				// Pass voltages to SetArmVoltages()
				SetArmVoltages(bufferVoltages);
				Sleep(10);
			}
		}

		// Set ValveOutput[] to zero
		for(i=0;i<NUM_AXES;i++)
			m_dValveOutputs[i] = 0.0;

	
	}	// End Connected
}		// End function

STDMETHODIMP CNewValveController::get_rate_InflationRate(short *pVal)
{
	// TODO: Add your implementation code here
	*pVal = m_sInflationRate;
	return S_OK;
}

STDMETHODIMP CNewValveController::put_rate_InflationRate(short newVal)
{
	// TODO: Add your implementation code here
	if(newVal>10)
		m_sInflationRate = newVal;
	else
		m_bstrError = SysAllocString(L"Please choose a value greater than 10.");
	return S_OK;
}

STDMETHODIMP CNewValveController::get_rate_DeflationRate(short *pVal)
{
	// TODO: Add your implementation code here
	*pVal = m_sDeflationRate;
	return S_OK;
}

STDMETHODIMP CNewValveController::put_rate_DeflationRate(short newVal)
{
	// TODO: Add your implementation code here
	if(newVal>10)
		m_sDeflationRate = newVal;
	else
		m_bstrError = SysAllocString(L"Please choose a value greater than 10.");

	return S_OK;
}

/******************************************************
* DesiredHomeValues()
* This function sets the joint angles for the 
* right and left arm for the desired home position.
* This is mostly a preventive measure. So that if
* someone calls "Move()" without having set a series
* of desired joint angles the arm won't go crazy.
******************************************************/
int CNewValveController::DesiredHomeValues()
{
	// Local variables
	IVectorSignal	*pIVSDesAng;
	SAFEARRAY		*mysa;

	if(m_bWhatArm == LEFT_ARM)
	{
		// Follows PUMA robot arm conventions
		m_dDesiredAngles[0] =    0;
		m_dDesiredAngles[1] =   90;
		m_dDesiredAngles[2] = -180;
		m_dDesiredAngles[3] =    0;
		m_dDesiredAngles[4] =   90;
		m_dDesiredAngles[5] =    0;
	}

	if(m_bWhatArm == RIGHT_ARM)
	{
		// Follows PUMA robot arm conventions
		m_dDesiredAngles[0] =    0;
		m_dDesiredAngles[1] =   90;
		m_dDesiredAngles[2] = -180;
		m_dDesiredAngles[3] =    0;
		m_dDesiredAngles[4] =   90;
		m_dDesiredAngles[5] =    0;
	}

	// Write these values to the DesiredAngles VectorSignal.
	// This only happens once in the initialization routine.

	// Get object and interface pointer
	m_Bindings->get_Pointers(SysAllocString(L"DesiredAngles"),&m_pIUnkDesiredAngles);
	if (m_pIUnkDesiredAngles == NULL) return -1;
		m_pIUnkDesiredAngles->QueryInterface(IID_IVectorSignal,(void**)&pIVSDesAng);

	if (pIVSDesAng != NULL)
	{
			mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
			memcpy(mysa->pvData, m_dDesiredAngles, sizeof(double)*NUM_AXES);	// We have to do this, b/c in the memcpy cannot copy correctly 			
			pIVSDesAng->SetCurrentVector(mysa);

			SafeArrayDestroy(mysa);
			pIVSDesAng->Release();

			return 0;
	}
	else	// We don't have all the right connections so release and signal error.
	{
		if (pIVSDesAng != NULL)
			pIVSDesAng->Release();

		return -1;
	}
}

/******************************************************
/* OpenGripper()
/* This function opens and closes an air-pressure based gripper.
/* Assigning a voltage of 3.6volts to the Vital Motenc Card,
/* will apply a pressure of ~3.6*130psi.
/*
/* Notice that we are not using ISAC triceps. Hence, there
/* are two free lines of air pressure.
/*
/* The left/right gripper will be selected based on what are
/* we are using. 
/* 
/* For the left arm, we will use the right tricep, this 
/* is the fifth muscle. Board 0, channel 4.
/*
/* For the right arm, we will use the left tricep, this 
/* is the fifth muscle. Board 2, channel 0.
/******************************************************/
STDMETHODIMP CNewValveController::gripper_OpenGripper()
{
	if(m_bWhatArm == LEFT_ARM)
	{
		// 0.4
		vitalSelectBoard(0);
		vitalDacWrite(4, 3.6);
	}

	if(m_bWhatArm == RIGHT_ARM)
	{
		// 2.0
		vitalSelectBoard(2);
		vitalDacWrite(0, 3.6);
	}
	

	return S_OK;
}

/******************************************************
/* CloseGripper()
/* Apply 0 voltage. 
/******************************************************/
STDMETHODIMP CNewValveController::gripper_CloseGripper()
{
	if(m_bWhatArm == LEFT_ARM)
	{
		vitalSelectBoard(0);
		vitalDacWrite(4, 0);
	}

	if(m_bWhatArm == RIGHT_ARM)
	{
		vitalSelectBoard(2);
		vitalDacWrite(0, 0);
	}
	return S_OK;
}
