// NewValveController.cpp : Implementation of CNewValveController
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This is effectively a PD Controller.
// The name is misleading.
// 
// Note:
// For this program to run adequately in IMA2.5, Winmotenc.dll has to be present in the C:\IMA2\Components folder.
// DAD will complain if there is a .dll file that does not belong to an IMA2.5 component. So, the Motenc.dll was given a 'hidden status'.
// There is a strange .dll dependency between this program and that .dll
//
// A note about this template:
// This template is autogenerated. The template code can be found in \ProgramFiles\MicrosoftVisualStudio\Common\MSDev\Templates\ATL
// Specifically customized for an IMA 2.5 component.
// Created by Juan Rojas. Jan 08.
//
// You can also look at an example compenent created by Christina Campbell at O:\Components\ExampleComp
// If you are just learning look at that component to see more details than those included in this template.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "IMA2_NNet_n_PController.h"
#include "NewValveController.h"
#include <math.h>

#define NUMBER_OF_STEPS 50		// Number of steps to run the P-controller. Might not be needed, since we can call this ALWAYS in IMA.
/////////////////////////////////////////////////////////////////////////////
// CNewValveController
// 
// Include Class comments.
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
// CNewValveController::OnConstruct() 
// OnConstruct() is called when the component is created. In addition to putting in
// whatever initialization code you need, If you are going to connect to another
// component anywhere in your code, you need to set up bindings. 
//
// The following code will create one binding. Change "DescriptiveName" to some
// appropriate string. This string will be visible as the name of the binding from
// DAD. It is *not* the name of the component you will bind to. The name of the
// specific component on the other end of the binding is determined at runtime (in DAD).
//
// If you wish to allow only one component to connect to this binding, make the BindType
// BT_Default. If you wish to allow several components, make the BindType BT_Collection.
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CNewValveController::OnConstruct()
{
// TODO: Bindings. Personalize the binding of your component. 

	IMA2_BindingInfo BindInf;
	long x[1] = {0};

	SAFEARRAYBOUND		SafeArrayBoundIn[1];										// We're making a one-dimensional SafeArray
	SafeArrayBoundIn[0].lLbound		= 0;											// Our SafeArray starts at index 0
	SafeArrayBoundIn[0].cElements	= 1;											// It's empty, doesn't have any elements yet.

	// **START**
	// DesiredAngles
	BindInf.Name		= SysAllocString(L"DesiredAngles");						// Assign name to object
	BindInf.BindType	= BT_Collection;										// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");									// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// Actual Angles
	BindInf.Name		= SysAllocString(L"CurrentAngles");						// Assign name to object
	BindInf.BindType	= BT_Collection;										// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");									// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);											// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// ValveVoltages
	BindInf.Name		= SysAllocString(L"ValveVoltages");						// Assign name to object
	BindInf.BindType	= BT_Collection;										// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");									// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);											// Set up the clients bindings array.	
	// **FINISH**

	// **START**
	// State Machine
/*	BindInf.Name		= SysAllocString(L"StateMachine");						// Assign name to object
	BindInf.BindType	= BT_Collection;										// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");									// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_StateMachineProj.StateMachine"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IStateMachine"));
	m_ConfigureBindings->Add(&BindInf);											// Set up the clients bindings array.	
*/
	// **FINISH**


	// Deallocate storage
	SysFreeString(BindInf.Name);
	SysFreeString(BindInf.Path);
	SafeArrayDestroy(BindInf.PIDs);
	SafeArrayDestroy(BindInf.IIDs);

  return S_OK;
}
STDMETHODIMP CNewValveController::OnDestruct() {	return S_OK; }
//////////////////////////////////////////////////////////////////////////////////////////
// CNewValveController::Save(VARIANT *pData)
// This method is called by DAD when a component is saved. Items that should be saved are the
// ones that are important to the setup of the code, or user options that should hold over
// from one use of an agent to another. (Example: size of data, filenames, etc.) 
//
// For each variable to be saved, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to GetPropertyBag). Change the
// term "DescriptiveName" to something descriptive of the item you are saving, and make
// sure not to reuse names. In the next line of code, change "m_MyPrivateVariable" to the variable
// you are saving and VarType to the VarType of that value. Valid types and VarTypes are:
// (Note: These are limited by VB/OLE compatibility, not by the list of things that Variants can be.)
// short:	VT_I2
// int:		VT_I4
// float:	VT_R4
// double:	VT_R8
// BSTR:	VT_BSTR
// char:	VT_BYTE
// All strings (char*) should be converted to BSTR (see BSTR documentation).
// A CString can be converted to a BSTR using the member function AllocSysString (see CString documentation)
//
// If you want to save an array, you have to assign a SAFEARRAY to the Variant. (Do NOT just
// use a pointer, it will save just one value). replace the line starting "ItemValue =" with the following 
// code (substituting your pointer for "variable", the array length for "numelem", int/float/double, etc. 
// for "Type", and using the VarType of one element of the array--BSTR arrays are not allowed.):
//
//	ItemValue = new variant_t;
//	ItemValue->vt=VT_ARRAY|VarType;
//	ItemValue->parray=SafeArrayCreateVector(VarType,0,numelem);
//  memcpy(ItemValue->parray->pvData,variable,numelem*sizeof(Type));
//
// Note: "delete ItemValue" will take care of destroying the safearray (do *not* call SafeArrayDestroy).
// Because of the nature of a SafeArray, you do not have to explicitly save the length of the array.
// However, due to the nature of property bags, you must call the array version of the Add function:
//
//  hRes = pIPB->AddArrayToPropertyBag(&ItemName, ItemValue);
//
// (See Load comments for how to extract arrays from the propertybag).
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CNewValveController::Save(VARIANT *pData) {
	// Variables
	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	variant_t				*ItemValue;
	_PropertyBagWrapper		*pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		
	if (pIPB == NULL)	
			return !S_OK;
		
		// **START**
		// Right-P parameter control value
		ItemName = SysAllocString(L"P-RightValue");
		// Store the data and the type of data into a variant_t type
		ItemValue = new variant_t;
		ItemValue->vt=VT_ARRAY|VT_R8;
		ItemValue->parray=SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		memcpy(ItemValue->parray->pvData,m_dRightPValue,NUM_AXES*sizeof(double));
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddArrayToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**

		// **START**
		// Left-P parameter control value
		ItemName = SysAllocString(L"P-LeftValue");
		// Store the data and the type of data into a variant_t type
		ItemValue = new variant_t;
		ItemValue->vt=VT_ARRAY|VT_R8;
		ItemValue->parray=SafeArrayCreateVector(VT_R8,0,NUM_AXES);
		memcpy(ItemValue->parray->pvData,m_dLeftPValue,NUM_AXES*sizeof(double));
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddArrayToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**

		// **START**
		// Create string names for items to be saved
		// Number of Elements
		ItemName = SysAllocString(L"WhatArm");
		// Store the data and the type of data into a variant_t type
 		ItemValue = new variant_t((short)m_bWhatArm,VT_I2);
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**


		// Returns a pointer to the PropertyBag as a VARIANT
		hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
		
		// Copy the contents of the property bag to the pData VARIANT
		VariantCopy(pData, &m_VBPropertyBag);

		// Save the size of the data 
		m_lDataSize = pData->parray->rgsabound[0].cElements;		

		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);

		// Release
		pIPB->Release();

	return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////
// CNewValveController::Load(VARIANT Data)
// This function will load in all the data you just saved in the Save function.
// 
// For each variable to be loaded, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to VariantClear). Change the
// term "NameUsedToSave" to the name you gave this item in Save.
// On the line beginning "variable = ", change "variable" to the variable that you saved
// the value from, and change "Type" to the type of that variable (use "long" for "int")
// A CString can be directly set to a BSTR, but in order to get a char* back, you have to 
// use strcpy (I think).
//
// If you made an array, you have to load it back in now.
// Just like in the save function, you must call the array version of the Get function:
//
//  pIPB->GetArrayFromPropertyBag(&ItemName, ItemValue);
//
// If your variable is dynamically allocated, make sure to delete and reallocate it:
//
//  if(variable!=NULL)
//		delete variable;
//  variable=new Type[ItemValue->parray->rgsabound->cElements];	
//
// Then just copy the values from the parray (replace the "variable =" line with this):
//
//  memcpy(variable,ItemValue->parray->pvData,ItemValue->parray->rgsabound->cElements*sizeof(Type));
//
// Note that this means you do not have to separately save the length of the array, although if
// you have a variable that keeps track of the array length you should also set it at this point:
//
//  numelem=ItemValue->parray->rgsabound->cElements;
//
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CNewValveController::Load(VARIANT Data) {
	
	// Variables
	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	_PropertyBagWrapper*	pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	variant_t				*ItemValue;
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		
	if (pIPB == NULL)	
			return !S_OK;

		// Pass Data to PropertyBag
		hRes = pIPB->SetPropertyBag(&Data);
		
		// **START**
		// Right PValue
		// Define strings
		ItemName		= SysAllocString(L"P-RightValue");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetArrayFromPropertyBag(&ItemName, ItemValue);
		memcpy(m_dRightPValue, ItemValue->parray->pvData, ItemValue->parray->rgsabound->cElements*sizeof(double));
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**

		// Left PValue
		ItemName		= SysAllocString(L"P-LeftValue");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetArrayFromPropertyBag(&ItemName, ItemValue);
		memcpy(m_dLeftPValue, ItemValue->parray->pvData,ItemValue->parray->rgsabound->cElements*sizeof(double));
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**		

		// WhatArm
		ItemName		= SysAllocString(L"WhatArm");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetFromPropertyBag(&ItemName,ItemValue);  //2nd argument is return value (look retval for help)
		m_bWhatArm	= (bool)*ItemValue;
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**

		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);
		
		// Release
		pIPB->Release();
		
return S_OK;
}

STDMETHODIMP CNewValveController::DoHomingRoutine()
{
	// Declare local variables
	HRESULT hResult;				// Return type for ATL Interface method calls.

	// Pass WhatArm data to the PIDController local variable.
	// This is important b/c every function in the PIDCont class allocates data depending on this variable.

	// Initialize Cards.
	InitializeCards();

	// Perform the Homing Routine
	hResult = InitializeValves();
	if(hResult != 0) m_bstrError = SysAllocString(L"Error calling Initialize::InitializeValves()");
	Sleep(5000);

	// Reset Encoders
	// This is a crucial step. It is used so that the ENCODERS are reset every time before we use the arm.
	// When power is given to an encoder, it marks the current position as it's ZERO position. 
	// We have to try to find a way to have a consistent starting position. We do this after moving the
	// arms to the home position.
	// Resetting encoders at the beginning however, does not guarantee an exact home position. 
	// But this is what we are working with at this time.
	ResetEncoders();

	// Read encoders at home position
	ReadEncoders();

	// Convert encoder values to LogicalAngles
	hResult = ReadLogicalAngles();					// Angles are sent to the CurrentAngles VS through the ReadLogicalAngles methods.
	if(hResult != 0) m_bstrError = SysAllocString(L"Error calling Initialize::InitializeValves()");

	return S_OK;
}


/************************************************************************************
* NeuralNetController()
*
* This function will convert our Desired Angles into a corresponding voltage.
* Before we actually call the neural network functions, we must note if 
* this is a forward or backward motion in order to call the right method.
*
* At the end the function writes the voltage readings to the card.
***********************************************************************************/
/*STDMETHODIMP CNewValveController::NeuralNetController()
{
	// Declare timing variables
	int				i;
	double			m_dDesiredAngles[NUM_AXES];
	SAFEARRAY		*mysa;
	IVectorSignal	*pIVSDesAng;

	LARGE_INTEGER ticksPerSecond, start_ticks, end_ticks, cputime, tick;


	// 1) Copy current angles into a previousAngles array.
	for(i=0; i<NUM_AXES; i++)
		m_fpreviousAngles[i] = m_dAngles[i];

	// 2) Get DesiredAngles from IMA2 Interface (typically the DesiredAngles will be given by the TrajectoryGenerator which in turn receive its desired position from the HeadAgent/3DOutput)
	//	  Get pointer to object and interface.
	m_Bindings->get_Pointers(SysAllocString(L"DesiredAngles"),&m_pIUnkDesiredAngles);
	if(m_pIUnkDesiredAngles == NULL)	return !S_OK;
		m_pIUnkDesiredAngles->QueryInterface(IID_IVectorSignal,(void**)&pIVSDesAng);

	if (pIVSDesAng == NULL)				return !S_OK;
	
	mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);						// When using a VS we always have to use doubles as the types.
	pIVSDesAng->GetCurrentVector(mysa);									// Get the current DesiredAngles
			memcpy(m_dDesiredAngles, mysa->pvData, sizeof(double)*NUM_AXES);	// We have to do this, b/c in the memcpy cannot copy correctly 
			for(i=0;i<NUM_AXES;i++) m_fDesiredAngles[i] = m_dDesiredAngles[i];	// a mysa of type double to another member that is not a double
	m_bstrError = SysAllocString(L"Copied Desired Angles Successfully.");
	// Deallocate memory
	SafeArrayDestroy(mysa); pIVSDesAng->Release();
	

	// 3) Call Neural Network, where DesiredAngles are converted into corresponding voltages.
	if(m_bWhatArm == RIGHT_ARM)
	{

		/*** Precise Sampling Time Initialization ***/	 
		// Checking to see if Timer calls do work. (Two of them are tested: (a) get computer frequency and (b) current-tick value.
/*		if ( !QueryPerformanceFrequency(&ticksPerSecond) )							// This commands outputs the computer's 'counter-frequency'. I.e. how many ticks in one second.
			if ( !QueryPerformanceCounter(&tick) )									// This command outputs the 
				 ATLTRACE(_T("There is a problem reading timing information from this machine"));
	
		// For the following calls we have to examine whether we are moving forward
		// or backward in order to call the appropriate Neural Network file.
		// The .Process() call returns the approrpriate voltage for the the desired angle. 

		// Angle [0]: Joint 1
		if( m_fpreviousAngles[0] > m_fDesiredAngles[0] )
			LeftNNMusclesAngle0B->Process(&m_fDesiredAngles[0],&m_fIncrementalVoltage[0]);

		else if( m_fpreviousAngles[0] < m_fDesiredAngles[0] )
			LeftNNMusclesAngle0F->Process(&m_fDesiredAngles[0],&m_fIncrementalVoltage[0]);

		// Write valve outputs (for both valve 0 and 1). Home position +/- added change.
		m_dValveOutputs[0] = m_dInitialValveOutputs[0] - m_fIncrementalVoltage[0];
		m_dValveOutputs[1] = m_dInitialValveOutputs[1] + m_fIncrementalVoltage[0];
		

		/*** Angle 1, Joint 2 ***/
/*		if( m_fpreviousAngles[1] < m_fDesiredAngles[1] )
			LeftNNMusclesAngle1F->Process(&m_fDesiredAngles[1],&m_fIncrementalVoltage[1]);

		else if( m_fpreviousAngles[1] > m_fDesiredAngles[1] )
			LeftNNMusclesAngle1B->Process(&m_fDesiredAngles[1],&m_fIncrementalVoltage[1]);

		m_dValveOutputs[2] = m_dInitialValveOutputs[2]+m_fIncrementalVoltage[1];
		m_dValveOutputs[3] = m_dInitialValveOutputs[3]-m_fIncrementalVoltage[1];

		/*** Angle 2, Joint 3&4 ***/
/*		if( m_fpreviousAngles[2] > m_fDesiredAngles[2] )
				LeftNNMusclesAngle2B->Process(&m_fDesiredAngles[2],&m_fIncrementalVoltage[2]);
		else if( m_fpreviousAngles[2] < m_fDesiredAngles[2] )
				LeftNNMusclesAngle2F->Process(&m_fDesiredAngles[2],&m_fIncrementalVoltage[2]);
		
		/*** Angle 3, Joint 3&4 ***/
/*		if( m_fpreviousAngles[3] > m_fDesiredAngles[3] )
				LeftNNMusclesAngle3B->Process(&m_fDesiredAngles[3],&m_fIncrementalVoltage[3]);

		else if( m_fpreviousAngles[3] < m_fDesiredAngles[3] )
				LeftNNMusclesAngle3F->Process(&m_fDesiredAngles[3],&m_fIncrementalVoltage[3]);

		m_dValveOutputs[4] = m_dInitialValveOutputs[4] + m_fIncrementalVoltage[2] - m_fIncrementalVoltage[3];
		m_dValveOutputs[5] = m_dInitialValveOutputs[5] - m_fIncrementalVoltage[2] - m_fIncrementalVoltage[3];			
		m_dValveOutputs[6] = m_dInitialValveOutputs[6] - m_fIncrementalVoltage[2] + m_fIncrementalVoltage[3];
		m_dValveOutputs[7] = m_dInitialValveOutputs[7] + m_fIncrementalVoltage[2] + m_fIncrementalVoltage[3];

		/*** Angle 4, Joint 5&6 ***/
/*		if( m_fpreviousAngles[4] >  m_fDesiredAngles[4] )
			LeftNNMusclesAngle4B->Process(& m_fDesiredAngles[4],&m_fIncrementalVoltage[4]);
		else if( m_fpreviousAngles[4] <  m_fDesiredAngles[4] )
			LeftNNMusclesAngle4F->Process(& m_fDesiredAngles[4],&m_fIncrementalVoltage[4]);

		/*** Angle 5, Joint 5&6 ***/
/*		if( m_fpreviousAngles[5] > m_fDesiredAngles[5] )
			LeftNNMusclesAngle5B->Process(&m_fDesiredAngles[5],&m_fIncrementalVoltage[5]);
		else if( m_fpreviousAngles[5] < m_fDesiredAngles[5] )
			LeftNNMusclesAngle5F->Process(&m_fDesiredAngles[5],&m_fIncrementalVoltage[5]);

		m_dValveOutputs[8] = m_dInitialValveOutputs[8] - m_fIncrementalVoltage[4] - m_fIncrementalVoltage[5];
		m_dValveOutputs[9] = m_dInitialValveOutputs[9] + m_fIncrementalVoltage[4] + m_fIncrementalVoltage[5];
		m_dValveOutputs[10]= m_dInitialValveOutputs[10] - m_fIncrementalVoltage[4] + m_fIncrementalVoltage[5];
		m_dValveOutputs[11]= m_dInitialValveOutputs[11] + m_fIncrementalVoltage[4] - m_fIncrementalVoltage[5];

		/*** Write pressures (voltages) to the Hardware. ***/
/*		SetArmVoltages();

		QueryPerformanceCounter(&end_ticks); 

		while(  ((float)(end_ticks.QuadPart - start_ticks.QuadPart)/ticksPerSecond.QuadPart*1000 ) < (float)m_sSampleTime )
			QueryPerformanceCounter(&end_ticks); cputime.QuadPart = end_ticks.QuadPart- start_ticks.QuadPart;	

		Sleep(200);

		// Read the encoder position and then computer the Logical Angles
		ReadEncoders();
		ReadLogicalAngles();

		// Assigning the Previous Angles
		for(int i=0;i<NUM_AXES;i++)
			m_fpreviousAngles[i] = m_dAngles[i];

	}

	if (m_bWhatArm == LEFT_ARM)
	{
		/*** Precise Sampling Time Initialization ***/	 
		// Checking to see if Timer calls do work. (Two of them are tested: (a) get computer frequency and (b) current-tick value.
/*		if ( !QueryPerformanceFrequency(&ticksPerSecond) )							// This commands outputs the computer's 'counter-frequency'. I.e. how many ticks in one second.
			if ( !QueryPerformanceCounter(&tick) )									// This command outputs the 
				 ATLTRACE(_T("There is a problem reading timing information from this machine"));

		// For the following calls we have to examine whether we are moving forward
		// or backward in order to call the appropriate Neural Network file.
		// The .Process() call returns the approrpriate voltage for the the desired angle. 

		/*** Angle 0, Joint 1 ***/
/*		if( m_fpreviousAngles[0] > m_fDesiredAngles[0] )
			RightNNMusclesAngle0B->Process(&m_fDesiredAngles[0],&m_fIncrementalVoltage[0]);

		else if( m_fpreviousAngles[0] < m_fDesiredAngles[0])
			RightNNMusclesAngle0F->Process(&m_fDesiredAngles[0],&m_fIncrementalVoltage[0]);

		// Write output voltage (valves 0 and 1).
		m_dValveOutputs[0] = m_dInitialValveOutputs[0] - m_fIncrementalVoltage[0];
		m_dValveOutputs[1] = m_dInitialValveOutputs[1] + m_fIncrementalVoltage[0];

		/*** Angle 1, Joint 2 ***/
/*		if( m_fpreviousAngles[1] < m_fDesiredAngles[1] )
			RightNNMusclesAngle1F->Process(&m_fDesiredAngles[1],&m_fIncrementalVoltage[1]);

		else if( m_fpreviousAngles[1] > m_fDesiredAngles[1])
			RightNNMusclesAngle1B->Process(&m_fDesiredAngles[1],&m_fIncrementalVoltage[1]);

		m_dValveOutputs[2] = m_dInitialValveOutputs[2]+m_fIncrementalVoltage[1];
		m_dValveOutputs[3] = m_dInitialValveOutputs[3]-m_fIncrementalVoltage[1];


		/*** Angle 2, Joint 3&4 ***/
/*		if( m_fpreviousAngles[2] > m_fDesiredAngles[2] )
			RightNNMusclesAngle2B->Process(&m_fDesiredAngles[2],&m_fIncrementalVoltage[2]);

		else if( m_fpreviousAngles[2] < m_fDesiredAngles[2] )
			RightNNMusclesAngle2F->Process(&m_fDesiredAngles[2],&m_fIncrementalVoltage[2]);
		
		
		/*** Angle 3, Joint 3&4 ***/
/*		if( m_fpreviousAngles[3] > m_fDesiredAngles[3])
			RightNNMusclesAngle3B->Process(&m_fDesiredAngles[3],&m_fIncrementalVoltage[3]);
		else if( m_fpreviousAngles[3] < m_fDesiredAngles[3])
			RightNNMusclesAngle3F->Process(&m_fDesiredAngles[3],&m_fIncrementalVoltage[3]);

		m_dValveOutputs[4] = m_dInitialValveOutputs[4] + m_fIncrementalVoltage[2] - m_fIncrementalVoltage[3];
		m_dValveOutputs[5] = m_dInitialValveOutputs[5] - m_fIncrementalVoltage[2] - m_fIncrementalVoltage[3];			
		m_dValveOutputs[6] = m_dInitialValveOutputs[6] - m_fIncrementalVoltage[2] + m_fIncrementalVoltage[3];
		m_dValveOutputs[7] = m_dInitialValveOutputs[7] + m_fIncrementalVoltage[2] + m_fIncrementalVoltage[3];

		
		/*** Angle 4, Joint 5&6 ***/
/*		if( m_fpreviousAngles[4] > m_fDesiredAngles[4] )
			RightNNMusclesAngle4B->Process(&m_fDesiredAngles[4],&m_fIncrementalVoltage[4]);
		else if( m_fpreviousAngles[4] < m_fDesiredAngles[4] )
			RightNNMusclesAngle4F->Process(&m_fDesiredAngles[4],&m_fIncrementalVoltage[4]);
		
		
		/*** Angle 5, Joint 5&6 ***/
/*		if( m_fpreviousAngles[5] > m_fDesiredAngles[5] )
			RightNNMusclesAngle5B->Process(&m_fDesiredAngles[5],&m_fIncrementalVoltage[5]);
		else if( m_fpreviousAngles[5] < m_fDesiredAngles[5] )
			RightNNMusclesAngle5F->Process(&m_fDesiredAngles[5],&m_fIncrementalVoltage[5]);

		m_dValveOutputs[8] = m_dInitialValveOutputs[8] - m_fIncrementalVoltage[4] - m_fIncrementalVoltage[5] ;
		m_dValveOutputs[9] = m_dInitialValveOutputs[9] + m_fIncrementalVoltage[4] + m_fIncrementalVoltage[5];
		m_dValveOutputs[10]= m_dInitialValveOutputs[10] - m_fIncrementalVoltage[4] + m_fIncrementalVoltage[5];
		m_dValveOutputs[11]= m_dInitialValveOutputs[11] + m_fIncrementalVoltage[4] - m_fIncrementalVoltage[5];

		/*** Write pressures (voltages) to the Hardware. ***/
		// Copy local voltage values to the variable in the CPIDCont class before writing the pressures.
/*		SetArmVoltages();

		QueryPerformanceCounter(&end_ticks); 

		while(((float)(end_ticks.QuadPart-start_ticks.QuadPart)/ticksPerSecond.QuadPart*1000) < (float) m_sSampleTime)
			QueryPerformanceCounter(&end_ticks); cputime.QuadPart = end_ticks.QuadPart- start_ticks.QuadPart;	
	
		Sleep(200);

		// Read the encoder position and then compute the Logical Angles
		ReadEncoders();
		ReadLogicalAngles();

		// Assigning the Previous Angles
		for(int i=0; i<NUM_AXES; i++)
			m_fpreviousAngles[i] = m_dAngles[i];
	}	// End if

	return S_OK;
}
*/

/*
* Closed-Loop Controller. 
* Uses only P-parameter. 
*/
STDMETHODIMP CNewValveController::PIDController()
{
	// Local variables
	int i;
	int count = 20;
	double m_dDesiredAngles[NUM_AXES];

	SAFEARRAY	  *mysa;
	IVectorSignal *pIVSDesAng;

	// 1) Copy current angles into a previousAngles array.
	for(i=0; i<NUM_AXES; i++)
		m_fpreviousAngles[i] = m_dAngles[i];

	// 2) Get Desired Angles
	// Get object and interface pointer
	m_Bindings->get_Pointers(SysAllocString(L"DesiredAngles"),&m_pIUnkDesiredAngles);
	if (m_pIUnkDesiredAngles == NULL) return !S_OK;
		m_pIUnkDesiredAngles->QueryInterface(IID_IVectorSignal,(void**)&pIVSDesAng);

	if (pIVSDesAng != NULL)
	{
			mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
			pIVSDesAng->GetCurrentVector(mysa);
			memcpy(m_dDesiredAngles, mysa->pvData, sizeof(double)*NUM_AXES);	// We have to do this, b/c in the memcpy cannot copy correctly 
			for(i=0;i<NUM_AXES;i++) m_fDesiredAngles[i] = m_dDesiredAngles[i];	// a mysa of type double to another member that is not a double
			SafeArrayDestroy(mysa);
			pIVSDesAng->Release();
	}
	else	// We don't have all the right connections so release and signal error.
	{
		if (pIVSDesAng != NULL)
			pIVSDesAng->Release();

		return !S_OK;
	}

	

	// Run the PID loop
	if(m_bWhatArm == RIGHT_ARM)
	{
		while(count<NUMBER_OF_STEPS)
		{
			ReadEncoders();
			ReadLogicalAngles();

			// Call the PID function, which returns updated Error outputs.
			PID();
			
			// Add Error output to current Valveoutput
			m_dValveOutputs[0] = m_dValveOutputs[0] - m_dErrorOutput[0];
			m_dValveOutputs[1] = m_dValveOutputs[1] + m_dErrorOutput[0];
				
			m_dValveOutputs[2] = m_dValveOutputs[2] + m_dErrorOutput[1];
			m_dValveOutputs[3] = m_dValveOutputs[3] - m_dErrorOutput[1];

			m_dValveOutputs[4] = m_dValveOutputs[4] + m_dErrorOutput[2];
			m_dValveOutputs[5] = m_dValveOutputs[5] - m_dErrorOutput[2];
			m_dValveOutputs[6] = m_dValveOutputs[6] - m_dErrorOutput[2];
			m_dValveOutputs[7] = m_dValveOutputs[7] + m_dErrorOutput[2];

			m_dValveOutputs[4] = m_dValveOutputs[4] + m_dErrorOutput[3];
			m_dValveOutputs[5] = m_dValveOutputs[5] + m_dErrorOutput[3];
			m_dValveOutputs[6] = m_dValveOutputs[6] - m_dErrorOutput[3];
			m_dValveOutputs[7] = m_dValveOutputs[7] - m_dErrorOutput[3];

			m_dValveOutputs[8] = m_dValveOutputs[8] + m_dErrorOutput[4];
			m_dValveOutputs[9] = m_dValveOutputs[9] - m_dErrorOutput[4];
			m_dValveOutputs[10] = m_dValveOutputs[10] + m_dErrorOutput[4];
			m_dValveOutputs[11] = m_dValveOutputs[11] - m_dErrorOutput[4];

			m_dValveOutputs[8] = m_dValveOutputs[8] - m_dErrorOutput[5];
			m_dValveOutputs[9] = m_dValveOutputs[9] - m_dErrorOutput[5];
			m_dValveOutputs[10] = m_dValveOutputs[10] + m_dErrorOutput[5];
			m_dValveOutputs[11] = m_dValveOutputs[11] + m_dErrorOutput[5];

			// Write voltages to hardware
			// Copy local voltage values to the variable in the CPIDCont class before writing the pressures.
			SetArmVoltages();

			Sleep(20);
			count++;
		}
	}

	if(m_bWhatArm == LEFT_ARM)
	{
		while(count<NUMBER_OF_STEPS)
		{
			ReadEncoders();
			ReadLogicalAngles();
			
			// Call the PID function, which returns updated AngleErrors.
			PID();
			
			// Add Error output to current Valveoutput
			m_dValveOutputs[0] = m_dValveOutputs[0] - m_dErrorOutput[0];
			m_dValveOutputs[1] = m_dValveOutputs[1] + m_dErrorOutput[0];
				
			m_dValveOutputs[2] = m_dValveOutputs[2] + m_dErrorOutput[1];
			m_dValveOutputs[3] = m_dValveOutputs[3] - m_dErrorOutput[1];

			m_dValveOutputs[4] = m_dValveOutputs[4] + m_dErrorOutput[2];
			m_dValveOutputs[5] = m_dValveOutputs[5] - m_dErrorOutput[2];
			m_dValveOutputs[6] = m_dValveOutputs[6] - m_dErrorOutput[2];
			m_dValveOutputs[7] = m_dValveOutputs[7] + m_dErrorOutput[2];

			m_dValveOutputs[4] = m_dValveOutputs[4] + m_dErrorOutput[3];
			m_dValveOutputs[5] = m_dValveOutputs[5] + m_dErrorOutput[3];
			m_dValveOutputs[6] = m_dValveOutputs[6] - m_dErrorOutput[3];
			m_dValveOutputs[7] = m_dValveOutputs[7] - m_dErrorOutput[3];

			m_dValveOutputs[8] = m_dValveOutputs[8] + m_dErrorOutput[4];
			m_dValveOutputs[9] = m_dValveOutputs[9] - m_dErrorOutput[4];
			m_dValveOutputs[10] = m_dValveOutputs[10] + m_dErrorOutput[4];
			m_dValveOutputs[11] = m_dValveOutputs[11] - m_dErrorOutput[4];

			m_dValveOutputs[8] = m_dValveOutputs[8] - m_dErrorOutput[5];
			m_dValveOutputs[9] = m_dValveOutputs[9] - m_dErrorOutput[5];
			m_dValveOutputs[10] = m_dValveOutputs[10] + m_dErrorOutput[5];
			m_dValveOutputs[11] = m_dValveOutputs[11] + m_dErrorOutput[5];

			// Write voltages to hardware
			SetArmVoltages();

			Sleep(20);
			count++;
		}

	}

	return S_OK;
}

/*******************************************************************************
* Close()
*
* Closes valves for either arm by decrementing the voltage by 0.1 in each 
* iteration of the loop. 
* 
* The maximum voltage is 3.6 Volts, so at most there will be 36 iterations. 
*******************************************************************************/
STDMETHODIMP CNewValveController::Close()
{
	// Close the valves
	
	double	bufferVoltage = 0.1;
	int		i=0,j=0,k=0;

	// Check to see if we are connected
	if(m_bConnected == FALSE)
		InitializeCards();

	// Read the pressures
	ReadPressure();

	// Each loop iteration takes 100ms.
	// The muscles can deflate in 3.6 secs.
	// Run the loop 36 times.
	for(i=0;i<36;i++) 
	{		
		// Right Arm
		if(m_bWhatArm == RIGHT_ARM)
		{
			m_bstrError = SysAllocString(L"PIDController: Closing Right Arm Valves!!");

			// Select Board (1)
			vitalSelectBoard(1);

			// For the Right Arm
			for(j=4;j<8;j++) // giving reference to first 4 channels of board 1
			{
				if( m_dValveOutputs[j-4]-bufferVoltage >0 )
					vitalDacWrite( j, m_dValveOutputs[j-4]-bufferVoltage );
			}
			vitalSelectBoard(2);
			for(j=0;j<8;j++) // giving reference to first 8 channels of board 1
			{
				if( m_dValveOutputs[j+4]-bufferVoltage >0 )
					vitalDacWrite( j, m_dValveOutputs[j+4]-bufferVoltage );
			}
			Sleep(200); // Wait 100 ms at each step
			bufferVoltage += 0.1;
		}

		// Left Arm
		if(m_bWhatArm == LEFT_ARM)
		{
			m_bstrError = SysAllocString(L"PIDController: Closing Left Arm Valves!!");

			// Select Board (0)
			vitalSelectBoard(0);
			for(j=0;j<8;j++) 
				if( m_dValveOutputs[j]-bufferVoltage >0 )
					vitalDacWrite( j, m_dValveOutputs[j]-bufferVoltage);
			
			vitalSelectBoard(1);
			for(j=0;j<4;j++) 
				if( m_dValveOutputs[j+8]-bufferVoltage >0 )
					vitalDacWrite( j, m_dValveOutputs[j+8]-bufferVoltage);	
		}

	}

	// Update connection flag
	m_bstrError = SysAllocString(L"PIDController: Valves closed.");
	m_bConnected = FALSE;

	// Close the cards
	Sleep(500);
	vitalQuit();
	Sleep(500);

	return S_OK;
}


/*********************************
******** PROPERTIES **************
**********************************/
STDMETHODIMP CNewValveController::get_ValveOutputsIndex(short *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
		*pVal = m_sValveOutputsIndex;
	return S_OK;
}

STDMETHODIMP CNewValveController::put_ValveOutputsIndex(short newVal)
{
	// TODO: Add your implementation code here
	if (newVal >= 0 && newVal <= 11)
		m_sValveOutputsIndex = newVal;
	return S_OK;
}

STDMETHODIMP CNewValveController::get_ValveOutputs(double *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
		*pVal = m_dValveOutputs[m_sValveOutputsIndex];
	return S_OK;
}

// Pressure values can only go from 0 - 3.6
STDMETHODIMP CNewValveController::put_ValveOutputs(double newVal)
{
	// TODO: Add your implementation code here
	if(newVal >= 0 && newVal <= 3.6)
		m_dValveOutputs[m_sValveOutputsIndex] = newVal;
	return S_OK;
}

/*****************************************************************************
* ErrorMessage()
* Prints error message in DAD. The error message comes from the currently
* running method. The goal is to ease debugging.
*****************************************************************************/
STDMETHODIMP CNewValveController::get_ErrorMessage(BSTR *pVal)
{
	// TODO: Add your implementation code here
	if (pVal != NULL)
		*pVal = m_bstrError;			// Other functions will copy error msg to m_bstrError

	return S_OK;
}

STDMETHODIMP CNewValveController::put_ErrorMessage(BSTR newVal)
{
	// Keep empty. We don't want the user to change this.
	m_bstrError = SysAllocString(L"This component controlls valves and has PID or NN Controller");

	return S_OK;
}

/******************************************************************************
* WhatArm()
* User selects what arm is in operation.
* Values are as follows: 0 = RIGHT ARM, 1 = LEFT ARM
******************************************************************************/
STDMETHODIMP CNewValveController::get_WhatArm(BOOL *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
		*pVal = m_bWhatArm;
	return S_OK;
}

STDMETHODIMP CNewValveController::put_WhatArm(BOOL newVal)
{
	// TODO: Add your implementation code here
	if (newVal == LEFT_ARM || newVal == RIGHT_ARM)
		m_bWhatArm = newVal;
	return S_OK;
}

STDMETHODIMP CNewValveController::get_LogicalAngles(double *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
		*pVal = m_dAngles[m_sAnglesIndex];
	return S_OK;
}

STDMETHODIMP CNewValveController::put_LogicalAngles(double newVal)
{
	// TODO: Add your implementation code here
	if(newVal >= -180 && newVal <= 180)
		m_dAngles[m_sAnglesIndex] = newVal;
	return S_OK;
}

STDMETHODIMP CNewValveController::get_LogicalAnglesIndex(short *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
		*pVal = m_sAnglesIndex;
	return S_OK;
}

STDMETHODIMP CNewValveController::put_LogicalAnglesIndex(short newVal)
{
	if(newVal >= 0 && newVal <6)
		m_sAnglesIndex = newVal;
	return S_OK;
}


STDMETHODIMP CNewValveController::get_P_LeftValue(double *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
		*pVal = m_dLeftPValue[m_sLeftPValueIndex];
	return S_OK;
}

STDMETHODIMP CNewValveController::put_P_LeftValue(double newVal)
{
	// TODO: Add your implementation code here
	m_dLeftPValue[m_sLeftPValueIndex] = newVal;
	return S_OK;
}

STDMETHODIMP CNewValveController::get_P_RightValue(double *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
		*pVal = m_dRightPValue[m_sRightPValueIndex];
	return S_OK;
}

STDMETHODIMP CNewValveController::put_P_RightValue(double newVal)
{
	// TODO: Add your implementation code here
	m_dRightPValue[m_sRightPValueIndex] = newVal;
	return S_OK;
}

STDMETHODIMP CNewValveController::get_P_LeftValueIndex(short *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
		*pVal = m_sLeftPValueIndex;
	return S_OK;
}

STDMETHODIMP CNewValveController::put_P_LeftValueIndex(short newVal)
{
	// TODO: Add your implementation code here
	if( (newVal >= 0) && (newVal < 6) )
			m_sLeftPValueIndex = newVal;
	return S_OK;
}

STDMETHODIMP CNewValveController::get_P_RightValueIndex(short *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
		*pVal = m_sRightPValueIndex;
	return S_OK;
}

STDMETHODIMP CNewValveController::put_P_RightValueIndex(short newVal)
{
	// TODO: Add your implementation code here
	if( (newVal >= 0) && (newVal < 6) )
		m_sRightPValueIndex = newVal;
	return S_OK;
}





/*STDMETHODIMP CNewValveController::AllocateNeuralNet()
{
	// 1) Create Neural Net objects according to arm, direction, and joint angle, and allocate the appropriate file for each object.
	if (m_bWhatArm == RIGHT_ARM)
	{	
		// Create Objects for Nerual Network Class (for left and right arms, for forward and backward directions, and for each joint angle).
		RightNNMusclesAngle0F = new CNNMuscles(RIGHT_ARM,0,FORWARD); RightNNMusclesAngle0B = new CNNMuscles(RIGHT_ARM,0,BACKWARD);
		RightNNMusclesAngle1F = new CNNMuscles(RIGHT_ARM,1,FORWARD); RightNNMusclesAngle1B = new CNNMuscles(RIGHT_ARM,1,BACKWARD);
		RightNNMusclesAngle2F = new CNNMuscles(RIGHT_ARM,2,FORWARD); RightNNMusclesAngle2B = new CNNMuscles(RIGHT_ARM,2,BACKWARD);
		RightNNMusclesAngle3F = new CNNMuscles(RIGHT_ARM,3,FORWARD); RightNNMusclesAngle3B = new CNNMuscles(RIGHT_ARM,3,BACKWARD);
		RightNNMusclesAngle4F = new CNNMuscles(RIGHT_ARM,4,FORWARD); RightNNMusclesAngle4B = new CNNMuscles(RIGHT_ARM,4,BACKWARD);
		RightNNMusclesAngle5F = new CNNMuscles(RIGHT_ARM,5,FORWARD); RightNNMusclesAngle5B = new CNNMuscles(RIGHT_ARM,5,BACKWARD);

		// Allocate Nerual net Files
		RightNNMusclesAngle0F->Allocator(); RightNNMusclesAngle0B->Allocator();
		RightNNMusclesAngle1F->Allocator(); RightNNMusclesAngle1B->Allocator();
		RightNNMusclesAngle2F->Allocator(); RightNNMusclesAngle2B->Allocator();
		RightNNMusclesAngle3F->Allocator(); RightNNMusclesAngle3B->Allocator();
		RightNNMusclesAngle4F->Allocator(); RightNNMusclesAngle4B->Allocator();
		RightNNMusclesAngle5F->Allocator(); RightNNMusclesAngle5B->Allocator();
	}	
	
	if (m_bWhatArm == LEFT_ARM)
	{
		// Create Objects for Nerual Network Class (for left and right arms, for forward and backward directions, and for each joint angle).
		LeftNNMusclesAngle0F = new CNNMuscles(LEFT_ARM,0,FORWARD); LeftNNMusclesAngle0B = new CNNMuscles(LEFT_ARM,0,BACKWARD);
		LeftNNMusclesAngle1F = new CNNMuscles(LEFT_ARM,1,FORWARD); LeftNNMusclesAngle1B = new CNNMuscles(LEFT_ARM,1,BACKWARD);
		LeftNNMusclesAngle2F = new CNNMuscles(LEFT_ARM,2,FORWARD); LeftNNMusclesAngle2B = new CNNMuscles(LEFT_ARM,2,BACKWARD);
		LeftNNMusclesAngle3F = new CNNMuscles(LEFT_ARM,3,FORWARD); LeftNNMusclesAngle3B = new CNNMuscles(LEFT_ARM,3,BACKWARD);
		LeftNNMusclesAngle4F = new CNNMuscles(LEFT_ARM,4,FORWARD); LeftNNMusclesAngle4B = new CNNMuscles(LEFT_ARM,4,BACKWARD);
		LeftNNMusclesAngle5F = new CNNMuscles(LEFT_ARM,5,FORWARD); LeftNNMusclesAngle5B = new CNNMuscles(LEFT_ARM,5,BACKWARD);
		
		// Allocate Nerual net Files
		LeftNNMusclesAngle0F->Allocator(); LeftNNMusclesAngle0B->Allocator();
		LeftNNMusclesAngle1F->Allocator(); LeftNNMusclesAngle1B->Allocator();
		LeftNNMusclesAngle2F->Allocator(); LeftNNMusclesAngle2B->Allocator();
		LeftNNMusclesAngle3F->Allocator(); LeftNNMusclesAngle3B->Allocator();
		LeftNNMusclesAngle4F->Allocator(); LeftNNMusclesAngle4B->Allocator();
		LeftNNMusclesAngle5F->Allocator(); LeftNNMusclesAngle5B->Allocator();
	}
	
	return S_OK;
}
*/


void CNewValveController::InitializeCards()
{

	m_bstrError = SysAllocString(L"Initializing Cards!!");	
	
	// Code used to copy an integer into the BSTR
	int		numCards = 0;
	BSTR	str1 = SysAllocString(L"Detected number of cards: ");
	BSTR	str2 = NULL;
	long	len1, len2;
	char	temp_buffer[10];

	// Initialize the Cards
	if( numCards = vitalInit() )
	{
		// Copy number of initialize cards into BSTR
		// Convert the integer to a char*, and then use _bstr_t to convert to a BSTR
		_itoa(numCards,temp_buffer,10);
		str2 = bstr_t(temp_buffer);
		
		// Calc len of strings
		len1 = SysStringLen(str1);
		len2 = SysStringLen(str2);
		m_bstrError = SysAllocStringLen(NULL, len1 + len2);			// Assign length to result
		// Use memcpy to concatenate the two BSTRs
		memcpy(m_bstrError,      str1, len1 * sizeof(OLECHAR));		// Copy first string
		memcpy(m_bstrError+len1, str2, len2 * sizeof(OLECHAR));		// Copy second string
		
		m_bstrError[len1+len2] = NULL;
	}
	
	else
	{
		numCards=0;
		m_bstrError = SysAllocString(L"Error initializing WinMotenc library" );
	}

	// Set connection flag to true
	m_bConnected = TRUE;

}

/*********************************************************************
* InitializeValves()
*
* This is the Hoiming Procedure.
* The values for these muscles were calculated by inspection
* in order for the arm to go to the HOME position. Incrementally moves
* from rest position to home position.
*
* The first motion moves the arm backwards to avoid hitting the table
* commonly used in front of ISAC.
*
* Note:
* Examine often if the arms are going back to the exact home position.
* Sometimes different factors like muscle properties or encoder errors
* may affect this.
*********************************************************************/
STDMETHODIMP CNewValveController::InitializeValves()
{
	// Local variables
	double bufferVoltage = 0.1;		// Voltage is used instead of pressures.
	int i=0, j=0, k=0;

	if (m_bWhatArm == RIGHT_ARM)
	{
		m_bstrError = SysAllocString(L"Initializing Right Arm.");
		
		// Writing Bias Values to Array.
		// Values are understood in pairs as they are agonist and antagonist muscles.
		m_dValveOutputs[0]	= 2.1;
		m_dValveOutputs[1]	= 1.9;

		m_dValveOutputs[2]	= 2.2;
		m_dValveOutputs[3]	= 1.8;

		m_dValveOutputs[4]  = 0.0;
		m_dValveOutputs[5]	= 2.2;

		m_dValveOutputs[6]	= 2.1;
		m_dValveOutputs[7]	= 0.0;

		m_dValveOutputs[8]  = 2.0;
		m_dValveOutputs[9]  = 2.0;

		m_dValveOutputs[10] = 2.0;
		m_dValveOutputs[11] = 2.0;

		// Next step is to inflate the muscles.
		// We will first inflate the first 8 valves in board (1) and then the next 4 valves in board (2).
		// Each loop takes approximately 100 ms. Muscles inflate in 2.5 sec. So we will loop 25 times.
		for(i=0; i<25; i++) 
		{
			// First, move arms backwards.
			// For right arm we must start with board (1) and the 4th channel.
			vitalSelectBoard(1);
			
			if(bufferVoltage <= m_dValveOutputs[0] + 0.05)
					vitalDacWrite(4, bufferVoltage/2);			// Write voltage to hardware		

			if(bufferVoltage <= m_dValveOutputs[2] + 0.05)
					vitalDacWrite(6, bufferVoltage/2);			// this divided by two was inserted by juan.
			
			bufferVoltage +=0.1;								// Increase voltage slightly for each iteration.
			Sleep(200);											// Wait 100 ms at each step		
		}

		// Reset bufferVoltage value.
		Sleep(200);
		bufferVoltage = 0.1;

		// Increment the voltage for the rest of the valves
		for(i=0; i<25; i++) 
		{	
			// Select board (1) and inflate first 8 valves (except [1] and [2])
			vitalSelectBoard(1);

			for(j=0; j<4; j++) 
				if(j != 0 || j != 2)	// Avoid inflating muslces twice
					if(bufferVoltage <= m_dValveOutputs[j] + 0.05){
						vitalDacWrite(j+4, bufferVoltage);}

			// Switch to board (2) and inflate the first 4 valves
			vitalSelectBoard(2);

			// The index selection is done in this way, to be able to copy the values later in one step.
			for(j=4;j<12;j++) 
				if(bufferVoltage <= m_dValveOutputs[j] + 0.05)
					vitalDacWrite(j-4, bufferVoltage);				
										
			bufferVoltage += 0.1;	// Increase buffer voltages smoothly
			Sleep(200);				// Wait 100 ms at each step		

			// Copy to the InitialValveOutputs variable
			for(int s=0;s<12;s++)
				m_dInitialValveOutputs[s] = m_dValveOutputs[s];

			vitalSelectBoard(0);
		}

	}

	if(m_bWhatArm == LEFT_ARM)
	{
		m_bstrError = SysAllocString(L"Initializing Left Arm.");

		// Writing Bias Values to Array.
		// Values are understood in pairs as they are agonist and antagonist muscles.
		m_dValveOutputs[0]	= 2.3;
		m_dValveOutputs[1]	= 1.7;

		m_dValveOutputs[2]	= 2.0;
		m_dValveOutputs[3]	= 2.0;

		m_dValveOutputs[4]  = 0.0;
		m_dValveOutputs[5]	= 2.2;

		m_dValveOutputs[6]	= 2.4;
		m_dValveOutputs[7]	= 0.0;

		m_dValveOutputs[8]  = 2.3;
		m_dValveOutputs[9]  = 1.7;

		m_dValveOutputs[10] = 1.7;
		m_dValveOutputs[11] = 2.3;

		// Next step is to inflate the muscles.
		// We will first inflate the first 8 valves in board (1) and then the next 4 valves in board (2).
		// Each loop takes approximately 100 ms. Muscles inflate in 2.5 sec. So we will loop 25 times.
		for(i=0; i<25; i++) 
		{
			// First, move arms backwards.
			vitalSelectBoard(0);
			
			if(bufferVoltage <= m_dValveOutputs[1] + 0.05)
					vitalDacWrite(1, bufferVoltage);			// Write voltage to hardware		

			if(bufferVoltage <= m_dValveOutputs[2] + 0.05)
					vitalDacWrite(2, bufferVoltage);
			bufferVoltage +=0.1;								// Increase voltage slightly for each iteration.
			Sleep(200);											// Wait 100 ms at each step		
		}

		// Reset bufferVoltage value.
		Sleep(200);
		bufferVoltage = 0.1;

		// Increment the voltage for the rest of the valves
		for(i=0; i<25; i++) 
		{	
			// Select board (0) and inflate first 8 valves (except [1] and [2])
			vitalSelectBoard(0);

			for(j=0; j<8; j++) 
				if(j != 1 || j != 2)	// Avoid inflating muslces twice
					if(bufferVoltage <= m_dValveOutputs[j] + 0.05){
						vitalDacWrite(j, bufferVoltage);}

			// Switch to board (1) and inflate the first 4 valves
			vitalSelectBoard(1);

			// The index selection is done in this way, to be able to copy the values later in one step.
			for(j=8;j<12;j++) 
				if(bufferVoltage <= m_dValveOutputs[j] + 0.05)
					vitalDacWrite(j-8, bufferVoltage);				
										
			bufferVoltage += 0.1;	// Increase buffer voltages smoothly
			Sleep(200);				// Wait 100 ms at each step		

			// Copy to the InitialValveOutputs variable
			for(int s=0;s<12;s++)
				m_dInitialValveOutputs[s] = m_dValveOutputs[s];

			vitalSelectBoard(0);
		}
	}

	// Copy ValveOutput voltages to VS

	/*** Pass this information to the 'ValveVoltages VS'. ***/
	// Get Object and Interface Pointer
	SAFEARRAY		*mysa;
	IVectorSignal	*pIVSValveVoltages = NULL;
	m_Bindings->get_Pointers(SysAllocString(L"ValveVoltages"), &m_pIUnkValveVoltages);
	if(m_pIUnkValveVoltages == NULL)	return !S_OK;

	m_pIUnkValveVoltages->QueryInterface(IID_IVectorSignal, (void**)&pIVSValveVoltages);
	if(pIVSValveVoltages == NULL)	return !S_OK;

	// Set VS with current angle data
	mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES*2);
	memcpy(mysa->pvData,m_dInitialValveOutputs,sizeof(double)*(NUM_AXES*2));
	pIVSValveVoltages->SetCurrentVector(mysa);

	// Clear allocations
	pIVSValveVoltages->Release();
	SafeArrayDestroy(mysa);

	return S_OK;
}


/*********************************************************
* ResetEncoder()
* This function plays a crucial role in initializing
* the encoder at the right location in order to have
* the same home position every time. 
*
* This function is called after the arm has been moved
* to the Home position.
*********************************************************/
void CNewValveController::ResetEncoders()
{

	if(m_bWhatArm == RIGHT_ARM)
	{
		// Select last 2 channels in board (1), and all channels in board (2).
		vitalSelectBoard(1);
		for(int channel=2;channel<4;channel++)
			vitalResetCounter(channel);
		vitalSelectBoard(2);
		for(channel=0;channel<4;channel++)
			vitalResetCounter(channel);
	}

	if(m_bWhatArm == LEFT_ARM)
	{
		// Select all channels in board (0), and first 2 channels in board (1).
		vitalSelectBoard(0);
		for(int channel=0;channel<4;channel++)
			vitalResetCounter(channel);
		vitalSelectBoard(1);
		for(channel=0;channel<2;channel++)
			vitalResetCounter(channel);
	}


}


/*******************************************************************
* ReadEncoders()
*
* Function OUTPUTS encoder values by talking to the
* Motenc cards. Calls vitalEncoderRead().
*
* Each card contains 4 enconder connections.
* The Left encoders are: all 4 channels in board 0, and
* the first 2 channels in board 1. The Right encoders
* are the last 2 channels in board 1, and all 4 in board 2.
*******************************************************************/

void CNewValveController::ReadEncoders()
{
	if(m_bWhatArm == RIGHT_ARM)
	{
		// Select Board(1), and channels 2 and 3. 
		vitalSelectBoard(1);
		
		//!!!First two encoders are flipped!!! 
		// This was determined through testing the hardware values.
		vitalEncoderRead(2, &m_dEncoders[1]);	// Channel 2, actually belongs to Encoder[1].
		vitalEncoderRead(3, &m_dEncoders[0]);

		// Switch to board 2 and read from all 4 channels.
		vitalSelectBoard(2);
		for(int channel=0; channel<4; channel++)
			vitalEncoderRead(channel, &m_dEncoders[channel+2]);	// Input into index items: 2-5.

		// The encoders at positions 2 and 5, need to have negative values to reflect that particular angle. 
		m_dEncoders[1]*=-1;
		m_dEncoders[2]*=-1;

		m_bstrError = SysAllocString(L"RightArm Encoder values were read.");

	}

	if(m_bWhatArm == LEFT_ARM)
	{
		vitalSelectBoard(0);
		for(int channel=0;channel<4;channel++)
			vitalEncoderRead(channel, &m_dEncoders[channel]);

		// Switch to Board(1) and first 2 channels
		vitalSelectBoard(1);
		for(channel=0;channel<2;channel++)
			vitalEncoderRead(channel, &m_dEncoders[channel+4]);		// Input to index 4 and 5.

		// The encoders at positions 2 and 5, need to have negative values to reflect that particular angle. 
		m_dEncoders[2]*=-1;
		m_dEncoders[5]*=-1;				

		m_bstrError = SysAllocString(L"LeftArm Encoder values were read.");
	}
	
}


/**************************************************************
* ReadLogicalAngles()
* This routine transforms encoder values to radians, and then 
* adjusts them to fit the DH paramters for a PUMA model.
* Radians were selected to match the format of the inverse 
* kinematics results. 
*
* Copies values out to CurrentAngles VS.
***************************************************************/
STDMETHODIMP CNewValveController::ReadLogicalAngles()
{

	if(m_bWhatArm == RIGHT_ARM)
	{
		m_dAngles[0] =		  ( (double)  m_dEncoders[0] / m_dEncoderGain[0]        ) /* * RADS2DEGREE */;
		m_dAngles[1] =		  ( (double) -m_dEncoders[1] / m_dEncoderGain[1] + PI/2 ) /* * RADS2DEGREE */;
		m_dAngles[2] = (0.5 * ( (double) -m_dEncoders[3] / m_dEncoderGain[3] + (double) m_dEncoders[2] / m_dEncoderGain[2] ) -PI ) /* * RADS2DEGREE */ ;
		m_dAngles[3] =		  ( (double) -m_dEncoders[3] / m_dEncoderGain[3] - (double) m_dEncoders[2] / m_dEncoderGain[2] )       /* * RADS2DEGREE */;
		
		// We made a mistake in the hardware for the right arm. Angle[4] has to be Angle[5] and vice-versa.
		m_dAngles[5] =		  ( (double) -m_dEncoders[4] / m_dEncoderGain[4] - (double) m_dEncoders[5] / m_dEncoderGain[4] )       /* * RADS2DEGREE */; // could add a -90 term to have it as old ISAC
		m_dAngles[4] = (0.5 * ( (double)  m_dEncoders[4] / m_dEncoderGain[5] + (double) m_dEncoders[5] / m_dEncoderGain[4] )       /* * RADS2DEGREE */);

	}

	if(m_bWhatArm == LEFT_ARM)
	{		
		// DesiredAngle  =       EncoderPosition / Encoder Resolution 
		m_dAngles[0] =		   ( (double)  m_dEncoders[0] / m_dEncoderGain[0]        ) /* * RADS2DEGREE */;
		m_dAngles[1] =		   ( (double) -m_dEncoders[1] / m_dEncoderGain[1] + PI/2 ) /* * RADS2DEGREE */;
		m_dAngles[2] =		  (( (double)  m_dEncoders[3] / m_dEncoderGain[3] - (double) m_dEncoders[2] / m_dEncoderGain[2] ) -PI ) /* * RADS2DEGREE */;
		m_dAngles[3] =  (0.5 * ( (double) -m_dEncoders[3] / m_dEncoderGain[3] - (double) m_dEncoders[2] / m_dEncoderGain[2] )       /* * RADS2DEGREE */ );
		m_dAngles[4] =  (0.5 * ( (double) -m_dEncoders[4] / m_dEncoderGain[4] - (double) m_dEncoders[5] / m_dEncoderGain[4] )       /* * RADS2DEGREE */ );
		m_dAngles[5] =		   ( (double)  m_dEncoders[4] / m_dEncoderGain[5] + (double) m_dEncoders[5] / m_dEncoderGain[4] )       /* * RADS2DEGREE */;

	}

	// Copy Angle information to the VectorSignal 'CurrentAngles'

	/*** Pass this information to the 'Actual Angles VS'. ***/
	// Get Object and Interface Pointer
	SAFEARRAY		*mysa;
	IVectorSignal	*pIVSCurrentAngles = NULL;
	m_Bindings->get_Pointers(SysAllocString(L"CurrentAngles"), &m_pIUnkCurrentAngles);
	if(m_pIUnkCurrentAngles == NULL)	return !S_OK;

	m_pIUnkCurrentAngles->QueryInterface(IID_IVectorSignal, (void**)&pIVSCurrentAngles);
	if(pIVSCurrentAngles == NULL)	return !S_OK;

	// Set VS with current angle data
	mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);
	memcpy(mysa->pvData,m_dAngles,sizeof(double)*NUM_AXES);
	pIVSCurrentAngles->SetCurrentVector(mysa);

	// Clear allocations
	pIVSCurrentAngles->Release();
	SafeArrayDestroy(mysa);

	return S_OK;

}

/***********************************************
* PID()
* This controller actually only uses the P factor.
*
* Need to include a D parameter!
***********************************************/
void CNewValveController::PID()
{

	if(m_bWhatArm == RIGHT_ARM)
		for(int i=0; i<NUM_AXES; i++)	
			m_dErrorOutput[i] = m_dRightPValue[i] * (m_fDesiredAngles[i] - m_dAngles[i]);

	if(m_bWhatArm == LEFT_ARM)
		for(int i=0; i<NUM_AXES; i++)	
			m_dErrorOutput[i] = m_dLeftPValue[i] * (m_fDesiredAngles[i] - m_dAngles[i]);

}


/****************************************************
* SetArmVoltages()
*
* Function writes pressure values by talking to the
* Motenc cards. Calls vitalDacWrite().
*
* We have to write 12 valve values. 
* Each board has 8 channels.
*
* Copies results to VS
****************************************************/
STDMETHODIMP CNewValveController::SetArmVoltages()
{
	// Local Variables
	int i=0, channel=0;

	if(m_bWhatArm == RIGHT_ARM)
	{
		// Select board (1)
		vitalSelectBoard(1);
		for(channel=4; channel<8; channel++) 
		{
			if (m_dValveOutputs[channel-4] < 0.0 ){
				m_bstrError = SysAllocString(L"You are trying to set a negative pressure.");
				m_dValveOutputs[channel-4] = 0.0;
			}
			if (m_dValveOutputs[channel-4] > 3.6 )
			{
				m_bstrError = SysAllocString(L"You are trying to insert too much pressure.");
				m_dValveOutputs[channel-4] = 3.6;
			}
			vitalDacWrite( channel, m_dValveOutputs[channel-4] );
		}
		vitalSelectBoard(2);
		for(channel=0;channel<8;channel++) // giving reference to first 4 channel of board 1
		{
			if (m_dValveOutputs[channel+4] < 0.0 ){
				m_bstrError = SysAllocString(L"You are trying to set a negative pressure.");
				m_dValveOutputs[channel+4] = 0.0;
			}
			if (m_dValveOutputs[channel+4] > 3.6 )
			{
				m_bstrError = SysAllocString(L"You are trying to insert too much pressure.");
				m_dValveOutputs[channel+4] = 3.6;
			}

			/**** Note: We will not be using the right arm triceps. So we won't write a voltage to them. ***/
			if ( channel!=0 && channel!=3) 
				vitalDacWrite( channel, m_dValveOutputs[channel+4] );
		}
	}

	if(m_bWhatArm == LEFT_ARM)
	{

		// Select Board 0.
		vitalSelectBoard(0);

		// Write values and check for pressure limits (no negative values nothing greater than 3.6volts).
		// Select the first 8 channels of board (0) and the first 4 channels of board (1).
		for(channel=0; channel<8; channel++) // giving reference to each channel of board 0
		{
			if (m_dValveOutputs[channel] < 0.0 )
			{			
				m_bstrError = SysAllocString(L"You are trying to set a negative pressure.");
				m_dValveOutputs[channel] = 0.0;
			}
			if (m_dValveOutputs[channel] > 3.6 )
			{
				m_bstrError = SysAllocString(L"You are trying to insert too much pressure.");
				m_dValveOutputs[channel] = 3.6;				
			}
			vitalDacWrite(channel, m_dValveOutputs[channel] );
		}
		// Switch to board (1).
		vitalSelectBoard(1);
		for(channel=0; channel<4; channel++) 
		{
			if (m_dValveOutputs[channel+8] < 0.0 )
			{
				m_bstrError = SysAllocString(L"You are trying to set a negative pressure.");
				m_dValveOutputs[channel+8] = 0.0;
			}
			if (m_dValveOutputs[channel+8] > 3.6 )
			{
				m_bstrError = SysAllocString(L"You are trying to insert too much pressure.");
				m_dValveOutputs[channel+8] = 3.6;
			}
			vitalDacWrite( channel, m_dValveOutputs[channel+8] );
		}

	}

	// Copy VoltageValues to Vector Signal
	// Get Object and Interface Pointer
	SAFEARRAY		*mysa;
	IVectorSignal	*pIVSValveVoltages = NULL;
	m_Bindings->get_Pointers(SysAllocString(L"ValveVoltages"), &m_pIUnkValveVoltages);
	if(m_pIUnkValveVoltages == NULL)	return !S_OK;

	m_pIUnkValveVoltages->QueryInterface(IID_IVectorSignal, (void**)&pIVSValveVoltages);
	if(pIVSValveVoltages == NULL)	return !S_OK;

	// Set VS with current voltage data
	mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES*2);
	memcpy(mysa->pvData,m_dValveOutputs,sizeof(double)*(NUM_AXES*2) );
	pIVSValveVoltages->SetCurrentVector(mysa);

	// Clear allocations
	pIVSValveVoltages->Release();
	SafeArrayDestroy(mysa);

	return S_OK;
}

STDMETHODIMP CNewValveController::GoToHomePosition()
{
	// TODO: Add your implementation code here
	int i=0, j=0, k=0,stepnumber = 20;
	double bufferVoltage[NUM_AXES*2];
	*bufferVoltage = 0;
	
	if(m_bWhatArm == RIGHT_ARM)
	{

		for(i=1; i<NUM_AXES*2; i++)
			bufferVoltage[i] = (m_dInitialValveOutputs[i] - m_dValveOutputs[i])/stepnumber;

		for (j=0; j<stepnumber; j++)
		{
			vitalSelectBoard(1);

			for (i=4;i<8;i++)
				vitalDacWrite(i, m_dValveOutputs[i-4] + bufferVoltage[i-4]*j);
			Sleep(10);			// Wait 10 ms at each step	

			vitalSelectBoard(2);
			for (i=1;i<8;i++) 
				vitalDacWrite(i, m_dValveOutputs[i+4] + bufferVoltage[i+4]*j);

			Sleep(50);
		}
		
		m_dValveOutputs[0]	= 2.1;	
		m_dValveOutputs[1]	= 1.9;
		m_dValveOutputs[2]	= 2.2;
		m_dValveOutputs[3]	= 1.8;
		m_dValveOutputs[4]  = 2.0; 
		m_dValveOutputs[5]  = 2.2;
		m_dValveOutputs[6]  = 2.1;
		m_dValveOutputs[7]  = 0.0;
		m_dValveOutputs[8]  = 2.0;
		m_dValveOutputs[9]  = 2.0;
		m_dValveOutputs[10] = 2.0;
		m_dValveOutputs[11] = 2.0;

		Sleep(300); 
		m_bstrError = SysAllocString(L"GoHome() - Moved right arm to the home position.");
		//ResetRightEncoders();
	}

	if(m_bWhatArm == LEFT_ARM)
	{

		for(i=1;i<NUM_AXES*2; i++)
			bufferVoltage[i] = (m_dInitialValveOutputs[i] - m_dValveOutputs[i])/stepnumber;

		for (j=0; j<stepnumber; j++)
		{
			vitalSelectBoard(1);
			for (i=4;i<8;i++)
				vitalDacWrite(i, m_dValveOutputs[i-4]+bufferVoltage[i-4]*j);

			Sleep(10); // Wait 10 ms at each step	

			vitalSelectBoard(2);
			for (i=1;i<8;i++) //neglect the gripper
				vitalDacWrite(i, m_dValveOutputs[i+4]+bufferVoltage[i+4]*j);

			Sleep(50);
		}
		
		m_dValveOutputs[0]  = 1.9;
		m_dValveOutputs[1]  = 2.1;
		m_dValveOutputs[2]  = 2.0;
		m_dValveOutputs[3]  = 2.0;
		m_dValveOutputs[4]  = 0.0;
		m_dValveOutputs[5]  = 2.2;
		m_dValveOutputs[6]  = 2.4;
		m_dValveOutputs[7]  = 0.0;
		m_dValveOutputs[8]  = 2.3;
		m_dValveOutputs[9]  = 1.7;
		m_dValveOutputs[10] = 1.7;
		m_dValveOutputs[11] = 2.3;

		Sleep(300);
		m_bstrError = SysAllocString(L"GoHome() - Moved left arm to the home position.");
	}

	
	return S_OK;
}

void CNewValveController::ReadPressure()
{
	// Local variables
	int	   channel			 = 0;
	double leftPressures[4]  = {0};
	double rightPressures[4] = {0};

	if (m_bWhatArm == RIGHT_ARM)
	{
		// Filter pressures by averaging over 5 runs.
		for(int i=0;i<5;i++)
		{

			// First Run
			if( i == 0 )
			{

				// Board 1
				vitalSelectBoard(1);

				// Last 4 channels
				vitalReadAnalogInputs( 1, rightPressures);
				for(channel=1; channel<4; channel++)
					m_dValveOutputs[channel]= rightPressures[channel];		// We add the pressures and at the end divide

				// Board 2
				vitalSelectBoard(1);

				// First 4 channels
				vitalReadAnalogInputs( 0, leftPressures);
				for(channel=4;channel<8;channel++)
					m_dValveOutputs[channel]= rightPressures[channel-4];

				// Last 4 channels
				vitalReadAnalogInputs( 1, rightPressures);
				for(channel=8;channel<12;channel++)
					m_dValveOutputs[channel]= rightPressures[channel-8];


				Sleep(1);

			}
			
			// Next 4 runs
			else
			{

				// Last 4 channels
				vitalReadAnalogInputs( 1, rightPressures);
				for(channel=1; channel<4; channel++)
					m_dValveOutputs[channel]= rightPressures[channel];		// We add the pressures and at the end divide

				// Board 2
				vitalSelectBoard(1);

				// First 4 channels
				vitalReadAnalogInputs( 0, rightPressures);
				for(channel=4;channel<8;channel++)
					m_dValveOutputs[channel]= rightPressures[channel-4];

				// Last 4 channels
				vitalReadAnalogInputs( 1, rightPressures);
				for(channel=8;channel<12;channel++)
					m_dValveOutputs[channel]= rightPressures[channel-8];

				Sleep(1);
			}
		}

		// Perform the averaging
		for(i=0;i<NUM_AXES*2;i++)
			m_dValveOutputs[i]/=5;

		// there is a problem with the 10th muscle
		//m_dValveOutputs[9]-=100;

		vitalSelectBoard(0);
	}

	if (m_bWhatArm == LEFT_ARM)
	{
		// Filter pressures by averaging over 5 runs.
		for(int i=0;i<5;i++)
		{

			// First Run
			if( i == 0 ){

				// Board 0
				vitalSelectBoard(0);

				// First 4 channels
				vitalReadAnalogInputs( 0, leftPressures);
				for(int channel=0; channel<4;channel++)
					m_dValveOutputs[channel]= leftPressures[channel];

				// Last 4 channels
				vitalReadAnalogInputs( 1, leftPressures);
				for(channel=4;channel<8;channel++)
					m_dValveOutputs[channel]= leftPressures[channel-4];

				// Board 1
				vitalSelectBoard(1);

				// First 4 channels
				vitalReadAnalogInputs( 0, leftPressures);
				for(channel=8;channel<12;channel++)
					m_dValveOutputs[channel]= leftPressures[channel-8];

				Sleep(1);

			}
			
			// Next 4 runs
			else{

				// Boad 0
				vitalSelectBoard(0);

				// First 4 channels
				vitalReadAnalogInputs( 0, leftPressures);
				for(int channel=0; channel<4;channel++)
					m_dValveOutputs[channel]+= leftPressures[channel];

				// Last 4 channels
				vitalReadAnalogInputs( 1, leftPressures);
				for(channel=4;channel<8;channel++)
					m_dValveOutputs[channel]+= leftPressures[channel-4];

				// Board 1
				vitalSelectBoard(1);

				// First 4 channels
				vitalReadAnalogInputs( 0, leftPressures);
				for(channel=8;channel<12;channel++)
					m_dValveOutputs[channel]+= leftPressures[channel-8];

				Sleep(1);
			}
		}

		// Perform the averaging
		for(i=0;i<NUM_AXES*2;i++)
			m_dValveOutputs[i]/=5;

		// there is a problem with the 10th muscle
		//m_dValveOutputs[9]-=100;

		vitalSelectBoard(0);
	}


}
