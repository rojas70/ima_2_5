// MotionCommands.cpp : Implementation of CMotionCommands
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A note about this template:
// This template is autogenerated. The template code can be found in \ProgramFiles\MicrosoftVisualStudio\Common\MSDev\Templates\ATL
// Specifically customized for an IMA 2.5 component.
// Created by Juan Rojas. Jan 08.
//
// You can also look at an example compenent created by Christina Campbell at O:\Components\ExampleComp
// If you are just learning look at that component to see more details than those included in this template.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "IMA2_MotomanLib.h"
#include "MotionCommands.h"

/////////////////////////////////////////////////////////////////////////////
// CMotionCommands
// 
// Include Class comments.
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
// CMotionCommands::OnConstruct() 
// OnConstruct() is called when the component is created. In addition to putting in
// whatever initialization code you need, If you are going to connect to another
// component anywhere in your code, you need to set up bindings. 
//
// The following code will create one binding. Change "DescriptiveName" to some
// appropriate string. This string will be visible as the name of the binding from
// DAD. It is *not* the name of the component you will bind to. The name of the
// specific component on the other end of the binding is determined at runtime (in DAD).
//
// If you wish to allow only one component to connect to this binding, make the BindType
// BT_Default. If you wish to allow several components, make the BindType BT_Collection.
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CMotionCommands::OnConstruct()
{
// TODO: Bindings. Personalize the binding of your component. 
	int numiids;
	IMA2_BindingInfo	BindInf;
	numiids=1;
	// **START**
	// 1. Binding #1
	BindInf.Name		= SysAllocString(L"DesiredPosition");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);		// Create and empty string array
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	
	// **FINISH**


	// Deallocate storage
	SysFreeString(BindInf.Name);
	SysFreeString(BindInf.Path);
	SafeArrayDestroy(BindInf.PIDs);
	SafeArrayDestroy(BindInf.IIDs);
  return S_OK;
}
STDMETHODIMP CMotionCommands::OnDestruct() {	return S_OK; }
//////////////////////////////////////////////////////////////////////////////////////////
// CMotionCommands::Save(VARIANT *pData)
// This method is called by DAD when a component is saved. Items that should be saved are the
// ones that are important to the setup of the code, or user options that should hold over
// from one use of an agent to another. (Example: size of data, filenames, etc.) 
//
// For each variable to be saved, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to GetPropertyBag). Change the
// term "DescriptiveName" to something descriptive of the item you are saving, and make
// sure not to reuse names. In the next line of code, change "m_MyPrivateVariable" to the variable
// you are saving and VarType to the VarType of that value. Valid types and VarTypes are:
// (Note: These are limited by VB/OLE compatibility, not by the list of things that Variants can be.)
// int:		VT_I4
// float:	VT_R4
// double:	VT_R8
// BSTR:	VT_BSTR
// char:	VT_BYTE
// All strings (char*) should be converted to BSTR (see BSTR documentation).
// A CString can be converted to a BSTR using the member function AllocSysString (see CString documentation)
//
// If you want to save an array, you have to assign a SAFEARRAY to the Variant. (Do NOT just
// use a pointer, it will save just one value). replace the line starting "ItemValue =" with the following 
// code (substituting your pointer for "variable", the array length for "numelem", int/float/double, etc. 
// for "Type", and using the VarType of one element of the array--BSTR arrays are not allowed.):
//
//	ItemValue = new variant_t;
//	ItemValue->vt=VT_ARRAY|VarType;
//	ItemValue->parray=SafeArrayCreateVector(VarType,0,numelem);
//  memcpy(ItemValue->parray->pvData,variable,numelem*sizeof(Type));
//
// Note: "delete ItemValue" will take care of destroying the safearray (do *not* call SafeArrayDestroy).
// Because of the nature of a SafeArray, you do not have to explicitly save the length of the array.
// However, due to the nature of property bags, you must call the array version of the Add function:
//
//  hRes = pIPB->AddArrayToPropertyBag(&ItemName, ItemValue);
//
// (See Load comments for how to extract arrays from the propertybag).
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CMotionCommands::Save(VARIANT *pData) {
	// Variables
	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	variant_t				*ItemValue;
	_PropertyBagWrapper		*pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		if (pIPB == NULL)	
			return !S_OK;
/*		
		// **START**
		// Create string names for items to be saved
		// Number of Elements
		ItemName = SysAllocString(L"DescriptiveName");
		// Store the data and the type of data into a variant_t type
 		ItemValue = new variant_t(m_YourPrivateVariableName,VT_I4);
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**
		// Returns a pointer to the PropertyBag as a VARIANT
		hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
		
		// Copy the contents of the property bag to the pData VARIANT
		VariantCopy(pData, &m_VBPropertyBag);
		// Save the size of the data 
		m_lDataSize = pData->parray->rgsabound[0].cElements;		
		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);
		
		// Release
		pIPB->Release();*/

	return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////
// CMotionCommands::Load(VARIANT Data)
// This function will load in all the data you just saved in the Save function.
// 
// For each variable to be loaded, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to VariantClear). Change the
// term "NameUsedToSave" to the name you gave this item in Save.
// On the line beginning "variable = ", change "variable" to the variable that you saved
// the value from, and change "Type" to the type of that variable (use "long" for "int")
// A CString can be directly set to a BSTR, but in order to get a char* back, you have to 
// use strcpy (I think).
//
// If you made an array, you have to load it back in now.
// Just like in the save function, you must call the array version of the Get function:
//
//  pIPB->GetArrayFromPropertyBag(&ItemName, ItemValue);
//
// If your variable is dynamically allocated, make sure to delete and reallocate it:
//
//  if(variable!=NULL)
//		delete variable;
//  variable=new Type[ItemValue->parray->rgsabound->cElements];	
//
// Then just copy the values from the parray (replace the "variable =" line with this):
//
//  memcpy(variable,ItemValue->parray->pvData,ItemValue->parray->rgsabound->cElements*sizeof(Type));
//
// Note that this means you do not have to separately save the length of the array, although if
// you have a variable that keeps track of the array length you should also set it at this point:
//
//  numelem=ItemValue->parray->rgsabound->cElements;
//
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CMotionCommands::Load(VARIANT Data) {
	
	// Variables
	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	_PropertyBagWrapper*	pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	variant_t				*ItemValue;
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		if (pIPB == NULL)	
			return !S_OK;
		// Get the pointer to the real VB property bag (the VB object (defined in msvbvm60.dll (aka VBRUN)) that our wrapper class created)
		// hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
		/*
		// Pass Data to PropertyBag
		hRes = pIPB->SetPropertyBag(&Data);
		// **START**
		// Variable m_lNumElements
		// Define strings
		ItemName		= SysAllocString(L"NameUsedToSave");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetFromPropertyBag(&ItemName,ItemValue);  //2nd argument is return value (look retval for help)
		m_YourPrivateVariableName	= (long)*ItemValue;
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**
		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);
		
		// Release
		pIPB->Release();
		*/
return S_OK;
}

//////////////////
// Properties
//////////////////

/*****************************************************************************
* ErrorMessage()
* Prints error message in DAD. The error message comes from the currently
* running method. The goal is to ease debugging.
*****************************************************************************/

STDMETHODIMP CMotionCommands::get_ErrorMessage(BSTR *pVal)
{
	// TODO: Add your implementation code here
	if (pVal != NULL)
		*pVal = m_bstrError;			// Other functions will copy error msg to m_bstrError
	return S_OK;
}

STDMETHODIMP CMotionCommands::get_MotionType(BSTR *pVal)
{
	// TODO: Add your implementation code here

	*pVal = m_bMotionType;
	return S_OK;
}

STDMETHODIMP CMotionCommands::put_MotionType(BSTR newVal)
{
	// TODO: Add your implementation code here
	USES_CONVERSION;

	// make lower case letters before comparing
	if(strcmp(_strupr(OLE2T(newVal)),"MOVL")==0)
	{
		m_bMotionType = SysAllocString(L"MOVL");
		return S_OK;
	}

	else if(strcmp(_strupr(OLE2T(newVal)),"MOVJ")==0)
	{
		m_bMotionType = SysAllocString(L"MOVJ");
		return S_OK;
	}

	else if(strcmp(_strupr(OLE2T(newVal)),"IMOV")==0)
	{
		m_bMotionType = SysAllocString(L"IMOV");
		return S_OK;
	}

	else
		return E_FAIL;

}

/*****************************************************************************
* Move_Incremental()
* This function Moves robot with linear motion form the current position for the
* increment value in a specified frame system.
* See. p 135/217 of the MotocomSDK manual to see definitions. 
*
* Positions will be stored in a pointer p. The positions can be retrieved from the vision
* system via a binding. For testing purposes, the positions will be manually created.
* 
* Methods called in the following order:
* BscServoOn:		Sets servo power supply ON..
* BscServoOff:		Sets servo power supply OFF.
* BscImov:			Moves the robot in an incremental fashion.
* 
*
*---------------------------------------------------------------------------------
* short BscServoOn(short nCid);
* In: nCid:	Communication handler ID number (obtained from the class CCommSetUp.
*
* Out (Return): None
* Return value: 0 = normal completion; !0 = error
*---------------------------------------------------------------------------------
* short BscServoOff(short nCid);
* In: nCid:	Communication handler ID number (obtained from the class CCommSetUp.
*
* Out (Return): None
* Return value: 0 = normal completion; !0 = error
*---------------------------------------------------------------------------------
* short BscImov(short nCid, char *vtype, double spd, char *framename, short toolno,
*				double *p)
* In:	nCid:		Communication handler ID number
*		*vtype:		Move speed selection; V:Control point; VR:Position angular
*		spd:		Move speed (0.1 to ......mm/s,0.1 to .....∞/s)
*		*framename: Coordinate name; BASE:Base coordinate; ROBOT:Robot coordinate;
*		UF1:		User coordinate1...
*		TOOL:		Tool coordinate (Only for NX100/XRC/MRC)
*		toolno:		Tool number
*		*p:			Target position storage pointer
*					P[0] X-axis coordinate system (unit: mm)
*					P[1] Y-axis coordinate system (unit: mm)
*					P[2] Z-axis coordinate system (unit: mm)
*					P[3] Wrist angle TX (unit: ÅK)
*					P[4] Wrist angle TY (unit: ÅK)
*					P[5] Wrist angle TZ (unit: ÅK)
*					P[6] 7th axis pulse number (mm for traveling axis)
*					P[7] 8th axis pulse number (mm for traveling axis)
*					P[8] 9th axis pulse number (mm for traveling axis)
*					P[9] 10th axis pulse number
*					P[10] 11th axis pulse number
*					P[11] 12th axis pulse number
*
* Out (Return): None
* Return value: 0 = normal completion; !0 = error
*****************************************************************************/
STDMETHODIMP CMotionCommands::move_Incremental()
{
	// Initialize local variables
	SAFEARRAY*		 mysa;
	IVectorSignal*	 pIVSDes		= NULL;	
	IVectorSignal*	 pIVSCommParams = NULL;	

	// Get object and interface pointers
	m_Bindings->get_Pointers(SysAllocString(L"DesiredPosition"),&m_pIUnkDesiredPosition);	
	m_Bindings->get_Pointers(SysAllocString(L"CommParams"),&m_pIUnkCommunicationParameters);	


	if(m_pIUnkDesiredPosition == NULL && m_pIUnkCommunicationParameters == NULL)
	{
		m_bstrError = SysAllocString(L"Connection to Components did not work");
		return !S_OK;
	}

	m_pIUnkDesiredPosition->QueryInterface(IID_IVectorSignal,(void **)&pIVSDes);
	m_pIUnkCommunicationParameters->QueryInterface(IID_IVectorSignal,(void **)&pIVSCommParams);
		
	if (pIVSDes != NULL && pIVSCommParams != NULL)
	{
		// Get Communication Parameters
		mysa = SafeArrayCreateVector(VT_R8,0,2);					// Need a total of 2 inputs
		pIVSCommParams->GetCurrentVector(mysa);
		memcpy(m_pdCommParams,mysa->pvData,sizeof(double)*2);	
		// Destroy SafeArray
		SafeArrayDestroy(mysa);
		pIVSCommParams->Release();

		// Get Desired Position
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES*2);			// Need a total of 12 inputs
		pIVSDes->GetCurrentVector(mysa);
		memcpy(m_pdDesPos,mysa->pvData,sizeof(double)*(NUM_AXES*2));	
		// Destroy SafeArray
		SafeArrayDestroy(mysa);
		pIVSDes->Release();

		// Carry out operation only if Communication was successful. 
		// Paramter 1 indicates CommHandle.
		// Parameter 2 indications connection flag.
		if(m_pdCommParams[1] == 1)
		{

			// Check to see if SERVO is ON.
			// If not, turn on servo and proceed with the call.
			if (!m_bServoOn)
			{
				// Turn on servo (takes a few seconds). Takes CommHandle as a parameter
				m_sSuccess = BscServoOn((short)m_pdCommParams[0]);	

				// Check result
				if(m_sSuccess != 0) // 0 = normal completion; !0 = error
				{	
					m_bstrError = SysAllocString(L"Could not turn servo on.");
					ATLTRACE(_T("Could not turn servo on."));
				}

			}

			else	// Move the arm
			{
					// Call *** BscImov ***
					m_sSuccess = BscImov(m_sComHandle,"V",0.23,"ROBOT",0,m_pdDesPos);

					if(m_sSuccess != 0)	// 0 = normal completion; !0 = error
					{	
						m_bstrError = SysAllocString(L"Incremental Move did not work.");
						ATLTRACE(_T("Incremental Move did not work."));
					}
			}

		} // End Connection Flag check



	} // End Interface pointer

	else
	{
		if (pIVSDes != NULL && pIVSCommParams != NULL)
		{
			pIVSDes->Release();
			pIVSCommParams->Release();

			ATLTRACE(_T("CommSetUp::IncrementalMove connections failed!"));

			return !S_OK;	
		}
	} // End Component pointer
	

	return S_OK;
}

/*****************************************************************************
* Move_UsersChoice()
* This function Moves robot according to the specified motion given by the user. 
* It moves the manipulator form the current position to a target position in a 
* specified frame system.
* See. p 138/217 of the MotocomSDK manual to see definitions. 
*
* Motion Type: Passed by the user in DAD as a string. Can be:
*			   Joint:					"MOVJ"
*			   Linear:					"MOVL"
*			   Incremental (linear):	"IMOV"
*
* Positions will be stored in a pointer *p. The positions can be retrieved from 
* the vision system via a binding. 
* 
* Methods called:
* BscServoOn:		Sets servo power supply ON.
* BscServoOff:		Sets servo power supply OFF.
*
* BscMovj:			Moves robot with joint motion to a target position in a specified frame.
* BscImov:			Moves the robot in an incremental fashion.
* BscMovl:			Moves robot with linear motion to a target position in a specified frame.
*
*---------------------------------------------------------------------------------
* short BscMov(short nCid, char *movtype, char *vtype, double spd, char *framename, 
*			   short rconf, short toolno, double *p)
* In:	nCid:		Communication handler ID number
*		*movtype	Motion type: MOVJ, MOVL, IMOV
*		*vtype:		Move speed selection; V:Control point; VR:Position angular
*		spd:		Move speed (0.1 to ......mm/s,0.1 to .....∞/s)
*		*framename: Coordinate name; BASE:Base coordinate; ROBOT:Robot coordinate;
*		rconf		Form. The form data are represented by byid data in decimals.
*					_ _ _ _ _ _ _ _. D0: 0-Flip,  1-No flip.
*									 D1: 0-Up  ,  1-Down.
*									 D2: 0-Front, 1-Rear.
*									 D3: 0-R<180, 1-R>180.
*									 D4: 0-T<180, 1-T>180.
*									 D5: 0-S<180, 1-S>180.
*									 D6: Not used
*									 D7: Not used
*		toolno:		Tool number
*		*p:			Target position storage pointer
*					P[0] X-axis coordinate system (unit: mm)
*					P[1] Y-axis coordinate system (unit: mm)
*					P[2] Z-axis coordinate system (unit: mm)
*					P[3] Wrist angle TX (unit: ÅK)
*					P[4] Wrist angle TY (unit: ÅK)
*					P[5] Wrist angle TZ (unit: ÅK)
*					P[6] 7th axis pulse number (mm for traveling axis)
*					P[7] 8th axis pulse number (mm for traveling axis)
*					P[8] 9th axis pulse number (mm for traveling axis)
*					P[9] 10th axis pulse number
*					P[10] 11th axis pulse number
*					P[11] 12th axis pulse number
*
* Out (Return): None
* Return value: 0 = normal completion; !0 = error
*****************************************************************************/
STDMETHODIMP CMotionCommands::move_UsersChoice()
{
	// TODO: Add your implementation code here

	return S_OK;
}



