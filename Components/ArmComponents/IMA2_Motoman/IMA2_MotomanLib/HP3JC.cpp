// HP3JC.cpp : Implementation of CHP3JC
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A note about this template:
// This template is autogenerated. The template code can be found in \ProgramFiles\MicrosoftVisualStudio\Common\MSDev\Templates\ATL
// Specifically customized for an IMA 2.5 component.
// Created by Juan Rojas. Jan 08.
//
// You can also look at an example compenent created by Christina Campbell at O:\Components\ExampleComp
// If you are just learning look at that component to see more details than those included in this template.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "IMA2_MotomanLib.h"
#include "HP3JC.h"
/////////////////////////////////////////////////////////////////////////////
// CHP3JC
// 
// This class groups all functions from the Motocom SDK that were originally 
// created in a more modular way. The difference is just a design issue. 
// We could have small modular components or one component that encompasses
// all functionality. It seemed that in this case one component would be easier
// to implement when considering the rest of our systems in the CIS lab. 
// Nonetheless, the other classes exist and work though with less functionality. 
// The interested user can easily expand the functionality of those modular functions
// simply by looking at the contents of this class. 
// Juan Rojas. March 08.
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
// CHP3JC::OnConstruct() 
// OnConstruct() is called when the component is created. If you are going to connect 
// another component anywhere in your code, you need to set up bindings. 
//
// The following code will create one binding. Change "DescriptiveName" to some
// appropriate string. This string will be visible as the name of the binding from
// DAD. It is *not* the name of the component you will bind to. The name of the
// specific component on the other end of the binding is determined at runtime (in DAD).
//
// If you wish to allow only one component to connect to this binding, make the BindType
// BT_Default. If you wish to allow several components, make the BindType BT_Collection.
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CHP3JC::OnConstruct()
{
// TODO: Bindings. Personalize the binding of your component. 
	IMA2_BindingInfo	BindInf;
	
	long x[1] = { 0 };
	SAFEARRAYBOUND		SafeArrayBoundIn[1];										// We're making a one-dimensional SafeArray
	SafeArrayBoundIn[0].lLbound		= 0;											// Our SafeArray starts at index 0
	SafeArrayBoundIn[0].cElements	= 1;											// It's empty, doesn't have any elements yet.


	// **START**
	// 1. DesiredXYZPosition
	BindInf.Name		= SysAllocString(L"DesiredXYZPosition");			// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	

	// 2. DesiredJointAngles
	BindInf.Name		= SysAllocString(L"DesiredJointAngles");					// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);

	// 3. ActualJointAngles
	BindInf.Name		= SysAllocString(L"ActualJointAngles");					// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);
	
	// 4. ActualXYZPosition
	BindInf.Name		= SysAllocString(L"ActualXYZPosition");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_BasicComponentsLib.VectorSignal"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&BindInf);

	// 5. TextQueue
	BindInf.Name		= SysAllocString(L"TextQueue");					// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"IMA2_TextQueueLib.TextQueue"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"ITextQueue"));
	m_ConfigureBindings->Add(&BindInf);

	// 6. StateMachine
	BindInf.Name		= SysAllocString(L"StateMachine");					// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreate(VT_BSTR, 1, SafeArrayBoundIn);		// Create and empty string array
	SafeArrayPutElement(BindInf.PIDs,x,(void *)SysAllocString(L"StateMachineProj.StateMachine"));
	SafeArrayPutElement(BindInf.IIDs,x,(void *)SysAllocString(L"IStateMachine"));
	m_ConfigureBindings->Add(&BindInf);

	//////////////////////////////
	// Deallocate storage
	SysFreeString(BindInf.Name);
	SysFreeString(BindInf.Path);
	SafeArrayDestroy(BindInf.PIDs);
	SafeArrayDestroy(BindInf.IIDs);
  return S_OK;
}
STDMETHODIMP CHP3JC::OnDestruct() {	return S_OK; }
//////////////////////////////////////////////////////////////////////////////////////////
// CHP3JC::Save(VARIANT *pData)
// This method is called by DAD when a component is saved. Items that should be saved are the
// ones that are important to the setup of the code, or user options that should hold over
// from one use of an agent to another. (Example: size of data, filenames, etc.) 
//
// For each variable to be saved, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to GetPropertyBag). Change the
// term "DescriptiveName" to something descriptive of the item you are saving, and make
// sure not to reuse names. In the next line of code, change "m_MyPrivateVariable" to the variable
// you are saving and VarType to the VarType of that value. Valid types and VarTypes are:
// (Note: These are limited by VB/OLE compatibility, not by the list of things that Variants can be.)
// short:	VT_I2
// int:		VT_I4
// float:	VT_R4
// double:	VT_R8
// BSTR:	VT_BSTR
// char:	VT_BYTE
// All strings (char*) should be converted to BSTR (see BSTR documentation).
// A CString can be converted to a BSTR using the member function AllocSysString (see CString documentation)
//
// If you want to save an array, you have to assign a SAFEARRAY to the Variant. (Do NOT just
// use a pointer, it will save just one value). replace the line starting "ItemValue =" with the following 
// code (substituting your pointer for "variable", the array length for "numelem", int/float/double, etc. 
// for "Type", and using the VarType of one element of the array--BSTR arrays are not allowed.):
//
//	ItemValue = new variant_t;
//	ItemValue->vt=VT_ARRAY|VarType;
//	ItemValue->parray=SafeArrayCreateVector(VarType,0,numelem);
//  memcpy(ItemValue->parray->pvData,variable,numelem*sizeof(Type));
//
// Note: "delete ItemValue" will take care of destroying the safearray (do *not* call SafeArrayDestroy).
// Because of the nature of a SafeArray, you do not have to explicitly save the length of the array.
// However, due to the nature of property bags, you must call the array version of the Add function:
//
//  hRes = pIPB->AddArrayToPropertyBag(&ItemName, ItemValue);
//
// (See Load comments for how to extract arrays from the propertybag).
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CHP3JC::Save(VARIANT *pData) {
	// Variables
	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	variant_t				*ItemValue;
	_PropertyBagWrapper		*pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		if (pIPB == NULL)	
			return !S_OK;
		
		// **START**
		// Create string names for items to be saved
		// Number of Elements
		ItemName = SysAllocString(L"Speed");
		// Store the data and the type of data into a variant_t type
 		ItemValue = new variant_t(m_dSpeed,VT_R8);
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**

		
		// **START**
		// Create string names for items to be saved
		// Number of Elements
		ItemName = SysAllocString(L"Form");
		// Store the data and the type of data into a variant_t type
 		ItemValue = new variant_t(m_sRconf,VT_I2);
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**

		// **START**
		// Create string names for items to be saved
		// Number of Elements
		ItemName = SysAllocString(L"MotionType");
		// Store the data and the type of data into a variant_t type
 		ItemValue = new variant_t(m_sMotionType,VT_I2);
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**
		
		// **START**
		// mReadPositionType
		ItemName = SysAllocString(L"ReadPositionType");
		// Store the data and the type of data into a variant_t type
 		ItemValue = new variant_t(m_sReadPositionType,VT_I2);
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**

		// Returns a pointer to the PropertyBag as a VARIANT
		hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
		
		// Copy the contents of the property bag to the pData VARIANT
		VariantCopy(pData, &m_VBPropertyBag);
		// Save the size of the data 
		m_lDataSize = pData->parray->rgsabound[0].cElements;		
		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);
		
		// Release
		pIPB->Release();
	return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////
// CHP3JC::Load(VARIANT Data)
// This function will load in all the data you just saved in the Save function.
// 
// For each variable to be loaded, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to VariantClear). Change the
// term "NameUsedToSave" to the name you gave this item in Save.
// On the line beginning "variable = ", change "variable" to the variable that you saved
// the value from, and change "Type" to the type of that variable (use "long" for "int")
// A CString can be directly set to a BSTR, but in order to get a char* back, you have to 
// use strcpy (I think).
//
// If you made an array, you have to load it back in now.
// Just like in the save function, you must call the array version of the Get function:
//
//  pIPB->GetArrayFromPropertyBag(&ItemName, ItemValue);
//
// If your variable is dynamically allocated, make sure to delete and reallocate it:
//
//  if(variable!=NULL)
//		delete variable;
//  variable=new Type[ItemValue->parray->rgsabound->cElements];	
//
// Then just copy the values from the parray (replace the "variable =" line with this):
//
//  memcpy(variable,ItemValue->parray->pvData,ItemValue->parray->rgsabound->cElements*sizeof(Type));
//
// Note that this means you do not have to separately save the length of the array, although if
// you have a variable that keeps track of the array length you should also set it at this point:
//
//  numelem=ItemValue->parray->rgsabound->cElements;
//
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CHP3JC::Load(VARIANT Data) {
	
	// Variables
	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	_PropertyBagWrapper*	pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	variant_t				*ItemValue;
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		if (pIPB == NULL)	
			return !S_OK;
		// Get the pointer to the real VB property bag (the VB object (defined in msvbvm60.dll (aka VBRUN)) that our wrapper class created)
		// hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
		
		// Pass Data to PropertyBag
		hRes = pIPB->SetPropertyBag(&Data);


		// **START**
		// Speed
		// Define strings
		ItemName		= SysAllocString(L"Speed");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetFromPropertyBag(&ItemName,ItemValue);  //2nd argument is return value (look retval for help)
		m_dSpeed	= (double)*ItemValue;
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**

		// **START**
		// Form
		// Define strings
		ItemName		= SysAllocString(L"Form");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetFromPropertyBag(&ItemName,ItemValue);  //2nd argument is return value (look retval for help)
		m_sRconf	= (short)*ItemValue;
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**

		// **START**
		// MotionType
		// Define strings
		ItemName		= SysAllocString(L"MotionType");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetFromPropertyBag(&ItemName,ItemValue);  //2nd argument is return value (look retval for help)
		m_sMotionType= (short)*ItemValue;
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**



		// **START**
		// ReadPositionType
		// Define strings
		ItemName		= SysAllocString(L"ReadPositionType");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetFromPropertyBag(&ItemName,ItemValue);  //2nd argument is return value (look retval for help)
		m_sReadPositionType= (short)*ItemValue;
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**
		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);
		
		// Release
		pIPB->Release();
		
return S_OK;
}

/*****************************************************************************
* Initialize() - Performs Connection with robot
* This function will call four Motoman BSC functions to start communication.
* See. p 191/217 of the MotocomSDK manual to see definitions. 
* 
* Methods called in the following order:
* BscOpen:			Gets a communication handler.
* BscSetCom:		Sets communications parameters of the serial port.
* BscSetCondBSC		Sets a communication control timer or retry counter.
* BscConnect:		Connects communications lines.
*
*---------------------------------------------------------------------------------
* short BscOpen(char *path,short mode);
* In: *path:	Communication current directory storage pointer
*     mode:		Communication type:
*
* Out (Return): None
* Return value: -1 = Acquisition Failure; Others = Communication handler ID number
*---------------------------------------------------------------------------------
* short BscSetCom(short nCid, short port,DWORD baud, short parity, short clen, short stp);
* In:	nCid:	Communication handler ID number
*		port:	Communication port number 1:COM1,2:COM2,3:COM3,4:COM4,...,255:COM255
*		baud:	Baud rate 150, 300, 600, 1200, 2400, 4800, 9600, 19200
*		parity:	Parity 0: None, 1: Odd, 2: Even
*		Clen:	Data length 7: 7 bits, 8: 8 bits
*		Stp:	Stop bit 0: 1 bit, 1: 1.5 bits, 2: 2 bits
* 
* Out (Return): None
* Return value: 0 = Error; 1 = Normal Completion
*---------------------------------------------------------------------------------
* short BscSetCondBSC(short nCid,short timerA,short timerB,short rtyR,short rtyW)
* In:	nCid:	Communication handler ID number
*		timerA:	Timer A (control timer, unit: msec)
*		timerB:	Timer B (text timer, unit: msec)
*		rtyR:	Sequence retry counter
*		rtyW:	Text retry counter
*
* Out (Return): None
* Return value: -1 = Error; 0 = Normal completion
*---------------------------------------------------------------------------------
* short BscConnect(short nCid););
* In:	nCid:	Communication handler ID number
*
* Out (Return): None
* Return value: 0 = Error; 1 = Normal Completion
*****************************************************************************/
STDMETHODIMP CHP3JC::connect_Initialize()
{
	// Create a string with the path where the local .dll is located.
	strcpy(m_cTempBuffer,"O:\\Components\\ArmComponents\\IMA2_Motoman\\IMA2_MotomanLib"); 
	
	// If we have not connected before, proceed:
	if (m_bConnected == 0)
	{
	

		try {
			// **Call BscOpen**
			m_sComHandle = BscOpen(m_cTempBuffer, m_sComType);

			
			if (m_sComHandle != -1)			// BscOpen: success is other than -1, error is -1
			{
				// For Serial Communications, call BscSetCom
				if(m_sComType == 1)
					m_sSuccess=BscSetCom(m_sComHandle,m_sPort,m_dwBaud,m_sParity,m_sDataLen,m_sStopBit);
				
				// For Ethernet Communications, call BscSetEther
				else
					// Third parameter 0=Host Control, 4th parameter is a windows handle, 0 works here.
					m_sSuccess=BscSetEther(m_sComHandle,scIPAddress,0,m_hWnd);
			}
			else
			{
				m_bstrError=SysAllocString(L"BscOpen failed");
				ATLTRACE(_T("BscOpen failed"));
				
				return !S_OK;
			}

			
			if(m_sSuccess != 0)				// BscSetCom: success is 1, error is 0
			{	
				// **Call BscSetCond**
				m_sSuccess = BscSetCondBSC(m_sComHandle,10000,30000,3,3); // Could be (10000,30000) or (3000,20000)
				
				
				if (m_sSuccess != -1)		// BscSetCondBSC: success is 0, error is -1
				{	
					// ***Call BscConnect***
					// Connect communication lines
					m_sSuccess = BscConnect(m_sComHandle);

					// If Connection fails:
					if(m_sSuccess == 0)
					{
						m_bstrError=SysAllocString(L"BscConnect failed");
						ATLTRACE(_T("\nBscConnect failed\n"));
						
						return !S_OK;
					}

					// If communication succeeds
					else
					{
						m_bConnected = true;
						m_bstrError=SysAllocString(L"Serial Connect Succeeded.");

						// Clear any errors that exist at the beginning.
						hResult = error_ClearAlarm();
					}
				}
			}

			// Set serial communication or ethernet communication to failure
			else	// BscOpen
			{
				m_bstrError=SysAllocString(L"BscOpen failed");
				ATLTRACE(_T("BscOpen failed"));
			}

		}	// End try

		catch(...)	// This will catch ANY exception
		{
			m_bstrError=SysAllocString(L"Initialize threw an exception");
			ATLTRACE(_T("Initialize threw an exception"));
		}

	}	// End m_bConnected


	return S_OK;
}

/*****************************************************************************
* Move_Incremental(SAFEARRAY* data)
* This function Moves robot with linear motion form the current position for the
* increment value in a specified frame system.
* See. p 135/217 of the MotocomSDK manual to see definitions. 
*
* Positions will be stored in a pointer p. The positions can be retrieved from the vision
* system via a binding. 
*
* A number of security and logic checks are present throughout the function. 
* Check #1: Is component connected? If not, connect.
* Check #2: Is Servo on? If not turn on.
* Check #3: Test for excpetions in Motocom calls
* Check #4: Was the Motoman call sent successfully? Print results
* Check #5: Did the command result in an alarm or error? Print alarm.
* 
* Methods called in the following order:
* BscServoOn:		Sets servo power supply ON..
* BscImov:			Moves the robot in an incremental fashion.
* BscIsAlarm:		Check to see if an alarm was trigered.
* error_GetAlarm:	Print the alarm result
*
*---------------------------------------------------------------------------------
* short BscServoOn(short nCid);
* In: nCid:	Communication handler ID number (obtained from the class CCommSetUp.
*
* Out (Return): None
* Return value: 0 = normal completion; !0 = error
*---------------------------------------------------------------------------------
* short BscServoOff(short nCid);
* In: nCid:	Communication handler ID number (obtained from the class CCommSetUp.
*
* Out (Return): None
* Return value: 0 = normal completion; !0 = error
*---------------------------------------------------------------------------------
* short BscImov(short nCid, char *vtype, double spd, char *framename, short toolno,
*				double *p)
* In:	nCid:		Communication handler ID number
*		*vtype:		Move speed selection; V:Control point; VR:Position angular
*		spd:		Move speed (0.1 to ......mm/s,0.1 to .....°/s)
*		*framename: Coordinate name; BASE:Base coordinate; ROBOT:Robot coordinate;
*		UF1:		User coordinate1...
*		TOOL:		Tool coordinate (Only for NX100/XRC/MRC)
*		toolno:		Tool number
*		*p:			Target position storage pointer
*					P[0] X-axis coordinate system (unit: mm)
*					P[1] Y-axis coordinate system (unit: mm)
*					P[2] Z-axis coordinate system (unit: mm)
*					P[3] Wrist angle TX (unit: K)
*					P[4] Wrist angle TY (unit: K)
*					P[5] Wrist angle TZ (unit: K)
*					P[6] 7th axis pulse number (mm for traveling axis)
*					P[7] 8th axis pulse number (mm for traveling axis)
*					P[8] 9th axis pulse number (mm for traveling axis)
*					P[9] 10th axis pulse number
*					P[10] 11th axis pulse number
*					P[11] 12th axis pulse number
*
* Out (Return): None
* Return value: 0 = normal completion; !0 = error
*
********* Updated on Jan. 2009 ********
* 
* This function has a new functionality such that it can be called from other
* components. Used particularly by the Cartesian Controller of the ControlBasis.
* That controller will pass the desired incremental data in cartesian coordinates
* through the safe array.
*
* The new functionality will check to see if the SAFEARRAY is null. If so, 
* it will carry out its original funcitonality, otherwise, it will extract the data
* from the safe array and call IMOV.
*****************************************************************************/

STDMETHODIMP CHP3JC::move_Incremental(/*SAFEARRAY* data*/)
{
	// Initialize local variables
	SAFEARRAY*		 mysa;
	IVectorSignal*	 pIVSDesPos		= NULL;	
	IStateMachine*	 pIVSStateMachine = NULL;

//	if(data == NULL)
//	{
		// Get object and interface pointers from Desired location
		m_Bindings->get_Pointers(SysAllocString(L"DesiredXYZPosition"),&m_pIUnkDesiredPosition);	


		if(m_pIUnkDesiredPosition == NULL)
		{
			m_bstrError = SysAllocString(L"Connection to Component did not work");
			
			return !S_OK;
		}

		m_pIUnkDesiredPosition->QueryInterface(IID_IVectorSignal,(void **)&pIVSDesPos);
			
		if (pIVSDesPos != NULL)
		{
			// Get Desired Position
			mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES*2);			// Need a total of 12 inputs
			pIVSDesPos->GetCurrentVector(mysa);
			memcpy(m_pdDesPos,mysa->pvData,sizeof(double)*(NUM_AXES*2));	
			// Destroy SafeArray
			SafeArrayDestroy(mysa);
			pIVSDesPos->Release();

			// Carry out operation only if Communication was successful. 
			if(m_bConnected)
			{
				// Check to see if SERVO is ON.
				if (!m_bServoOn)
				{
					// Turn on servo (takes a few seconds). Takes CommHandle as a parameter
					m_sSuccess = BscServoOn(m_sComHandle);	

					// Check result
					if(m_sSuccess != 0)		// 0 = normal completion; !0 = error
					{
						m_bstrError = SysAllocString(L"Could not turn servo on.");
						
					}
					else
						m_bServoOn = true;	// Turn flag on

				}

			
				// ***Move the arm, call - BscImov ***
				try 
				{
					m_sSuccess = BscImov(m_sComHandle,"V",m_dSpeed,BASE,0,m_pdDesPos);	
					
					// Check Success of operation
					if(m_sSuccess != 0)						// 0 = normal completion; !0 = error
						PrintError((int)m_sSuccess);
					else
					{
						m_bstrError = SysAllocString(L"move_Incremental executed successfuly.");
						
					}

					// ***Read positions, to keep system updated - BscIsLoc****
					// hResult = read_CurrentPosition();
				}
				catch(...) 
				{ 
					m_bstrError = SysAllocString(L"MoveIncremental threw an exception.");	
					
				}

				
				// Check for Alarms. 
				// Alarm may be generated independently of the success of the operation,
				// If so call GetError to print error code
				if( BscIsAlarm(m_sComHandle) )
						hResult = error_GetError();

			} // End Connection Flag check

			
			// If not connected, call Initialize() and this function back again
			else
			{
				hResult = connect_Initialize();
				hResult = move_Incremental(/*mysa*/);
				pIVSDesPos->Release();
			}


		} // End Interface pointer

		else
		{
			if (pIVSDesPos != NULL)
			{
				pIVSDesPos->Release();
				ATLTRACE(_T("CommSetUp::IncrementalMove connections failed!"));
				return !S_OK;	
			}
		} // End Component pointer

		// Flag state machine
		m_Bindings->get_Pointers(SysAllocString(L"StateMachine"),&m_pIUnkStateMachine);	
		if(m_pIUnkStateMachine == NULL)	return !S_OK;
		m_pIUnkStateMachine->QueryInterface(IID_IStateMachine,(void **)&pIVSStateMachine);
		if (pIVSStateMachine == NULL)	return !S_OK;
		pIVSStateMachine->Signal(SysAllocString(L"Go to next state"));
		pIVSStateMachine->Release();
//	}

	/************************* Updated Feb. 2009***************************************/
	// This functionality is for calls made from other components that have data in mysa.
/*	else
	{
		// Copy passed data to local argument
		memcpy(m_pdDesPos,data->pvData,sizeof(double)*(NUM_AXES));	

		// Carry out operation only if Communication was successful. 
		if(m_bConnected)
		{
			// Check to see if SERVO is ON.
			if (!m_bServoOn)
			{
				// Turn on servo (takes a few seconds). Takes CommHandle as a parameter
				m_sSuccess = BscServoOn(m_sComHandle);	

				// Check result
				if(m_sSuccess != 0)		// 0 = normal completion; !0 = error
				{
					m_bstrError = SysAllocString(L"Could not turn servo on.");
					
				}
				else
					m_bServoOn = true;	// Turn flag on

			}

		
			// ***Move the arm, call - BscImov ***
			try 
			{
				m_sSuccess = BscImov(m_sComHandle,"V",m_dSpeed,BASE,0,m_pdDesPos);	
				
				// Check Success of operation
				if(m_sSuccess != 0)						// 0 = normal completion; !0 = error
					PrintError((int)m_sSuccess);
				else
				{
					m_bstrError = SysAllocString(L"move_Incremental executed successfuly.");
					
				}

				// ***Read positions, to keep system updated - BscIsLoc****
				// hResult = read_CurrentPosition();
			}
			catch(...) 
			{ 
				m_bstrError = SysAllocString(L"MoveIncremental threw an exception.");	
				
			}

			
			// Check for Alarms. 
			// Alarm may be generated independently of the success of the operation,
			// If so call GetError to print error code
			if( BscIsAlarm(m_sComHandle) )
					hResult = error_GetError();

		} // End Connection Flag check

		
		// If not connected, call Initialize() and this function back again
		else
		{
			hResult = connect_Initialize();
			hResult = move_Incremental(mysa);
			pIVSDesPos->Release();
		}
	}
*/		
	return S_OK;
}


/*****************************************************************************
* Move_UsersChoice()
* This function Moves robot according to the specified motion given by the user. 
* It moves the manipulator form the current position to a target position in a 
* specified frame system.
* See. p 138/217 of the MotocomSDK manual to see definitions. 
*
* Motion Type: Passed by the user in DAD as a string. Can be:
*			   Joint:					"MOVJ"
*			   Linear:					"MOVL"
*			   Incremental (linear):	"IMOV"
*
* Positions will be stored in a pointer *p. The positions can be retrieved from 
* the vision system via a binding. 
* 
* A number of security and logic checks are present throughout the function. 
* Check #1: Is component connected? If not, connect.
* Check #2: Is Servo on? If not turn on.
* Check #3: Test for excpetions in Motocom calls
* Check #4: Was the Motoman call sent successfully? Print results
* Check #5: Did the command result in an alarm or error? Print alarm.
* 
* Methods called:
* BscServoOn:		Sets servo power supply ON.
* BscServoOff:		Sets servo power supply OFF.
*
* BscMovj:			Moves robot with joint motion to a target position in a specified frame.
* BscImov:			Moves the robot in an incremental fashion.
* BscMovl:			Moves robot with linear motion to a target position in a specified frame.
*
* BscIsAlarm:		Check to see if an alarm was trigered.
* error_GetAlarm:	Print the alarm result

*---------------------------------------------------------------------------------
* short BscMov(short nCid, char *movtype, char *vtype, double spd, char *framename, 
*			   short rconf, short toolno, double *p)
* In:	nCid:		Communication handler ID number
*		*movtype	Motion type: MOVJ, MOVL, IMOV
*		*vtype:		Move speed selection; V:Control point; VR:Position angular
*		spd:		Move speed (0.1 to ......mm/s,0.1 to .....°/s)
*		*framename: Coordinate name; BASE:Base coordinate; ROBOT:Robot coordinate;
*		rconf		Form. The form data are represented by byid data in decimals.
*					_ _ _ _ _ _ _ _. D0: 0-Flip,  1-No flip.
*									 D1: 0-Up  ,  1-Down.
*									 D2: 0-Front, 1-Rear.
*									 D3: 0-R<180, 1-R>180.
*									 D4: 0-T<180, 1-T>180.
*									 D5: 0-S<180, 1-S>180.
*									 D6: Not used
*									 D7: Not used
*		toolno:		Tool number. Barrett Hand is default at index 0. 
*		*p:			Target position storage pointer
*					P[0] X-axis coordinate system (unit: mm)
*					P[1] Y-axis coordinate system (unit: mm)
*					P[2] Z-axis coordinate system (unit: mm)
*					P[3] Wrist angle TX (unit: K)
*					P[4] Wrist angle TY (unit: K)
*					P[5] Wrist angle TZ (unit: K)
*					P[6] 7th axis pulse number (mm for traveling axis)
*					P[7] 8th axis pulse number (mm for traveling axis)
*					P[8] 9th axis pulse number (mm for traveling axis)
*					P[9] 10th axis pulse number
*					P[10] 11th axis pulse number
*					P[11] 12th axis pulse number
*
* Out (Return): None
* Return value: 0 = normal completion; !0 = error
*****************************************************************************/

STDMETHODIMP CHP3JC::move_UsersChoice()
{
	// Initialize local variables
	SAFEARRAY*		 mysa;
	IVectorSignal*	 pIVSDesPos		= NULL;	
	IStateMachine*	 pIVSStateMachine = NULL;

	// Get object and interface pointer to Desired Positions
	m_Bindings->get_Pointers(SysAllocString(L"DesiredXYZPosition"),&m_pIUnkDesiredPosition);	

	if(m_pIUnkDesiredPosition == NULL)
	{
		m_bstrError = SysAllocString(L"Connection to component did not work");
		
		return !S_OK;
	}

	m_pIUnkDesiredPosition->QueryInterface(IID_IVectorSignal,(void **)&pIVSDesPos);
		
	if (pIVSDesPos != NULL)
	{

		// Get Desired Position
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES*2);			// Need a total of 12 inputs
		pIVSDesPos->GetCurrentVector(mysa);
		memcpy(m_pdDesPos,mysa->pvData,sizeof(double)*(NUM_AXES*2));	
		// Destroy SafeArray
		SafeArrayDestroy(mysa);
		pIVSDesPos->Release();

		// Carry out operation ONLY if Communication-Setup was successful. 
		if(m_bConnected)
		{
			// Check to see if the servo motors are ON.
			if (!m_bServoOn)
			{
				// Turn on servo. Takes the Communication Handle (from Initialization() ) as a paramter.
				m_sSuccess = BscServoOn(m_sComHandle);																	

				// Check result
				if(m_sSuccess != 0)		// 0 = normal completion; !0 = error
				{
					m_bstrError = SysAllocString(L"Could not turn servo on.");
					
				}
				else
					m_bServoOn = true;	// Turn flag on
			}

			// ***Move the arm, call BscMov***
			try 
			{
				m_sSuccess = BscMov(m_sComHandle, m_cMotionType,"V",m_dSpeed,BASE,m_sRconf,m_sToolType,m_pdDesPos);

				// Check Success of operation
				if(m_sSuccess != 0)						// 0 = normal completion; !0 = error
				{
					PrintError((int)m_sSuccess);
				}
				else
				{
					m_bstrError = SysAllocString(L"move_UsersChoice executed successfuly.");
					
				}
			}

			catch(...) 
			{ 
				m_bstrError = SysAllocString(L"move_UsersChoice() threw an exception.");	
				
			}

			
			// Check for Alarms. Alarm may be generated independently of the success of the operation,
			if( BscIsAlarm(m_sComHandle) )
					hResult = error_GetAlarm();
			
		} // End Connection Flag check

		// If not connected, call Initialize() and this function back again
		else
		{
			hResult = connect_Initialize();
			hResult = move_UsersChoice();
			pIVSDesPos->Release();					// Make sure to release the handle if we did not use it
		}

	} // End Interface pointer

	else
	{
		if (pIVSDesPos != NULL)
		{
			pIVSDesPos->Release();
			m_bstrError = SysAllocString(L"move_UsersChoice connections failed!");
			
			ATLTRACE(_T("HP3JC::move_UsersChoice connections failed!"));

			return !S_OK;	
		}
	} // End Component pointer

	// Flag state machine
	m_Bindings->get_Pointers(SysAllocString(L"StateMachine"),&m_pIUnkStateMachine);	
	if(m_pIUnkStateMachine == NULL)	return !S_OK;
	m_pIUnkStateMachine->QueryInterface(IID_IStateMachine,(void **)&pIVSStateMachine);
	if (pIVSStateMachine == NULL)	return !S_OK;
	pIVSStateMachine->Signal(SysAllocString(L"Go to next state"));
	pIVSStateMachine->Release();	
	return S_OK;
}

/*****************************************************************************
* move_Linear()
* Moves robot with linear motion to a target position in a specified frame system
* See. p 142/217 of the MotocomSDK manual to see definitions. 
*
* Positions will be stored in a pointer m_pdDesPos. The positions can be retrieved from the vision
* system via a binding. 
* 
* A number of security and logic checks are present throughout the function. 
* Check #1: Is component connected? If not, connect.
* Check #2: Is Servo on? If not turn on.
* Check #3: Test for excpetions in Motocom calls
* Check #4: Was the Motoman call sent successfully? Print results
* Check #5: Did the command result in an alarm or error? Print alarm.
* 
* Methods called in the following order:
* BscServoOn:		Sets servo power supply ON..
* BscMovL:			Moves the robot in an incremental fashion.
* BscIsAlarm:		Check to see if an alarm was trigered.
* error_GetAlarm:	Print the alarm result
*
*---------------------------------------------------------------------------------
* short BscServoOn(short nCid);
* In: nCid:	Communication handler ID number (obtained from the class CCommSetUp.
*
* Out (Return): None
* Return value: 0 = normal completion; !0 = error
*---------------------------------------------------------------------------------
* short BscMovL(short nCid, char *vtype, double spd, char *framename, short rconf, 
*				short toolno, double *p)
* In:	nCid:		Communication handler ID number
*		*vtype:		Move speed selection; V:Control point; VR:Position angular
*		spd:		Move speed (0.1 to ......mm/s,0.1 to .....°/s)
*		*framename: Coordinate name; BASE:Base coordinate; ROBOT:Robot coordinate;
*					UF1: User coordinate1...
*		toolno:		Tool number. Barrett Hand is the default tool no. indexed at 0.
*		*p:			Target position storage pointer
*					P[0] X-axis coordinate system (unit: mm)
*					P[1] Y-axis coordinate system (unit: mm)
*					P[2] Z-axis coordinate system (unit: mm)
*					P[3] Wrist angle TX (unit: K)
*					P[4] Wrist angle TY (unit: K)
*					P[5] Wrist angle TZ (unit: K)
*					P[6] 7th axis pulse number (mm for traveling axis)
*					P[7] 8th axis pulse number (mm for traveling axis)
*					P[8] 9th axis pulse number (mm for traveling axis)
*					P[9] 10th axis pulse number
*					P[10] 11th axis pulse number
*					P[11] 12th axis pulse number
*
* Out (Return): None
* Return value: 0 = normal completion; !0 = error
*****************************************************************************/

STDMETHODIMP CHP3JC::move_LinearMotion()
{
	// Initialize local variables
	SAFEARRAY*		 mysa;
	IVectorSignal*	 pIVSDesPos		= NULL;	
	IStateMachine*	 pIVSStateMachine = NULL;

	// Get object and interface pointers
	m_Bindings->get_Pointers(SysAllocString(L"DesiredXYZPosition"),&m_pIUnkDesiredPosition);	


	if(m_pIUnkDesiredPosition == NULL)
	{
		m_bstrError = SysAllocString(L"Connection to Component did not work");
		
		return !S_OK;
	}

	m_pIUnkDesiredPosition->QueryInterface(IID_IVectorSignal,(void **)&pIVSDesPos);
		
	if (pIVSDesPos != NULL)
	{
		// Get Desired Position
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES*2);			// Need a total of 12 inputs
		pIVSDesPos->GetCurrentVector(mysa);
		memcpy(m_pdDesPos,mysa->pvData,sizeof(double)*(NUM_AXES*2));	
		// Destroy SafeArray
		SafeArrayDestroy(mysa);
		pIVSDesPos->Release();

		// Carry out operation only if Communication was successful. 
		if(m_bConnected)
		{
			// Check to see if SERVO is ON.
			if (!m_bServoOn)
			{
				// Turn on servo (takes a few seconds). Takes CommHandle as a parameter
				m_sSuccess = BscServoOn(m_sComHandle);	
				
				// Check result
				if(m_sSuccess != 0)		// 0 = normal completion; !0 = error
				{
					m_bstrError = SysAllocString(L"Could not turn servo on.");
					
				}
				else
					m_bServoOn = true;	// Turn flag on
			}

			// *** Move the arm, call BscMovl ***
			try 
			{
				m_sSuccess = BscMovl(m_sComHandle,"V",m_dSpeed,"BASE",m_sRconf,m_sToolType,m_pdDesPos);

				// Check Success of operation
				if(m_sSuccess != 0)	// 0 = normal completion; !0 = error
					PrintError((int)m_sSuccess);
				else
				{
					m_bstrError = SysAllocString(L"move_LinearMotion executed successfuly.");
					
				}

				// ***Read positions, to keep system updated - BscIsLoc****
				// hResult = read_CurrentPosition();			
			}
			catch(...) 
			{ 
				m_bstrError = SysAllocString(L"move_LinearMotion() threw an exception.");
				
			}
			

			// Check for Alarms. Alarm may be generated independently of the success of the operation,
			// If so call GetError to print error code
			if( BscIsAlarm(m_sComHandle) )
					hResult = error_GetError();

		} // End Connection Flag check	
		
		// If not connected, call Initialize() and this function back again
		else
		{
			hResult = connect_Initialize();
			hResult = move_LinearMotion();
			pIVSDesPos->Release();					// Make sure to release the handle if we did not use it
		}

	} // End Interface pointer

	else
	{
		if (pIVSDesPos != NULL)
		{
			pIVSDesPos->Release();
			ATLTRACE(_T("CommSetUp::move_LinearMotion connections failed!"));
			return !S_OK;	
		}
	} // End Component pointer

	// Flag state machine
	m_Bindings->get_Pointers(SysAllocString(L"StateMachine"),&m_pIUnkStateMachine);	
	if(m_pIUnkStateMachine == NULL)	return !S_OK;
	m_pIUnkStateMachine->QueryInterface(IID_IStateMachine,(void **)&pIVSStateMachine);
	if (pIVSStateMachine == NULL)	return !S_OK;
	pIVSStateMachine->Signal(SysAllocString(L"Go to next state"));
	pIVSStateMachine->Release();
	
	return S_OK;
}

/*****************************************************************************
* move_JointMotion()
* Moves robot with 'joint motion' to a target position in a specified frame system.
* Still takes cartesian coordinates. The motion of the joints is more circular than linear.
* See. p 140/217 of the MotocomSDK manual to see definitions. 
*
* Positions will be stored in a pointer m_pdDesPos. The positions can be retrieved from the vision
* system via a binding. 
* A number of security and logic checks are present throughout the function. 
* Check #1: Is component connected? If not, connect.
* Check #2: Is Servo on? If not turn on.
* Check #3: Test for excpetions in Motocom calls
* Check #4: Was the Motoman call sent successfully? Print results
* Check #5: Did the command result in an alarm or error? Print alarm.
*  
* Methods called in the following order:
* BscServoOn:		Sets servo power supply ON..
* BscMovL:			Moves the robot in an incremental fashion.
* BscIsAlarm:		Check to see if an alarm was trigered.
* error_GetAlarm:	Print the alarm result
*
*---------------------------------------------------------------------------------
* short BscServoOn(short nCid);
* In: nCid:	Communication handler ID number (obtained from the class CCommSetUp.
*
* Out (Return): None
* Return value: 0 = normal completion; !0 = error
*---------------------------------------------------------------------------------
* short BscMovJ(short nCid, double spd, char *framename, short rconf, 
*				short toolno, double *p)
* In:	nCid:		Communication handler ID number
*		spd:		Move speed (0.1 to ......mm/s,0.1 to .....°/s)
*		*framename: Coordinate name; BASE:Base coordinate; ROBOT:Robot coordinate;
*					UF1:User coordinate1...
*		rconf		Form. The form data are represented by byid data in decimals.
*					_ _ _ _ _ _ _ _. D0: 0-Flip,  1-No flip.
*									 D1: 0-Up  ,  1-Down.
*									 D2: 0-Front, 1-Rear.
*									 D3: 0-R<180, 1-R>180.
*									 D4: 0-T<180, 1-T>180.
*									 D5: 0-S<180, 1-S>180.
*									 D6: Not used
*									 D7: Not used
*		toolno:		Tool number is determined by m_sToolType that can be EMPTY, BARRET, ASSEMBLY.
*		*p:			Target position storage pointer
*					P[0] X-axis coordinate system (unit: mm)
*					P[1] Y-axis coordinate system (unit: mm)
*					P[2] Z-axis coordinate system (unit: mm)
*					P[3] Wrist angle TX (unit: K)
*					P[4] Wrist angle TY (unit: K)
*					P[5] Wrist angle TZ (unit: K)
*					P[6] 7th axis pulse number (mm for traveling axis)
*					P[7] 8th axis pulse number (mm for traveling axis)
*					P[8] 9th axis pulse number (mm for traveling axis)
*					P[9] 10th axis pulse number
*					P[10] 11th axis pulse number
*					P[11] 12th axis pulse number
*
* Out (Return): None
* Return value: 0 = normal completion; !0 = error
*****************************************************************************/
STDMETHODIMP CHP3JC::move_JointMotion()
{
	// TODO: Add your implementation code here
	// Initialize local variables
	SAFEARRAY*		 mysa;
	IVectorSignal*	 pIVSDesPos		= NULL;	
	IStateMachine*   pIVSStateMachine = NULL;

	// Get object and interface pointers
	m_Bindings->get_Pointers(SysAllocString(L"DesiredXYZPosition"),&m_pIUnkDesiredPosition);	


	if(m_pIUnkDesiredPosition == NULL)
	{
		m_bstrError = SysAllocString(L"Connection to Component did not work");
		
		return !S_OK;
	}

	m_pIUnkDesiredPosition->QueryInterface(IID_IVectorSignal,(void **)&pIVSDesPos);
		
	if (pIVSDesPos != NULL)
	{
		// Get Desired Position
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES*2);			// Need a total of 12 inputs
		pIVSDesPos->GetCurrentVector(mysa);
		memcpy(m_pdDesPos,mysa->pvData,sizeof(double)*(NUM_AXES*2));	
		// Destroy SafeArray
		SafeArrayDestroy(mysa);
		pIVSDesPos->Release();

		// Carry out operation only if Communication was successful. 
		if(m_bConnected)
		{
			// Check to see if SERVO is ON.
			if (!m_bServoOn)
			{
				// Turn on servo (takes a few seconds). Takes CommHandle as a parameter
				m_sSuccess = BscServoOn(m_sComHandle);	
				
				// Check result
				if(m_sSuccess != 0)		// 0 = normal completion; !0 = error
				{
					m_bstrError = SysAllocString(L"Could not turn servo on.");
					
				}
				else
					m_bServoOn = true;	// Turn flag on
			}

			// ***Move the arm, call  BscMovj ***
			try {
				m_sSuccess = BscMovj(m_sComHandle,m_dSpeed,BASE,m_sRconf,m_sToolType,m_pdDesPos);

				// Check Success of operation
				if(m_sSuccess != 0)	// 0 = normal completion; !0 = error
					PrintError((int)m_sSuccess);
				else
				{
					m_bstrError = SysAllocString(L"move_JointMotion executed successfuly.");
					
				}
				
				// ***Read positions, to keep system updated - BscIsLoc****
				// hResult = read_CurrentPosition();			
			}
			catch(...) 
			{ 
				m_bstrError = SysAllocString(L"move_JointMotion() threw an exception.");	
				
			}
			

			// Check for Alarms. Alarm may be generated independently of the success of the operation,
			// If so call GetError to print error code
			if( BscIsAlarm(m_sComHandle) )
					hResult = error_GetError();

		} // End Connection Flag check

		// If not connected, call Initialize() and this function back again
		else
		{
			hResult = connect_Initialize();
			hResult = move_JointMotion();
			pIVSDesPos->Release();					// Make sure to release the handle if we did not use it
		}


	} // End Interface pointer

	else
	{
		if (pIVSDesPos != NULL)
		{
			pIVSDesPos->Release();
			ATLTRACE(_T("CommSetUp::JointMotion connections failed!"));
			return !S_OK;	
		}
	} // End Component pointer

	// Flag state machine
	m_Bindings->get_Pointers(SysAllocString(L"StateMachine"),&m_pIUnkStateMachine);	
	if(m_pIUnkStateMachine == NULL)	return !S_OK;
	m_pIUnkStateMachine->QueryInterface(IID_IStateMachine,(void **)&pIVSStateMachine);
	if (pIVSStateMachine == NULL)	return !S_OK;
	pIVSStateMachine->Signal(SysAllocString(L"Go to next state"));
	pIVSStateMachine->Release();
	
	return S_OK;
}

/*****************************************************************************
* move_JointAngles()
* Moves robot Moves robot to a specified pulse position.
* See. p 146/217 of the MotocomSDK manual to see definitions. 
*
* (Not yet)This function will convert joint angles into the unit used by the motoman - pulses.
* There are __ pulses in 360 degrees. Hence 1 pulse = degrees.
* The range for each joint is as following:	S: 
*											L:
*											U:
*											R:
*											B:
*											T:
* A number of security and logic checks are present throughout the function. 
* Check #1: Is component connected? If not, connect.
* Check #2: Is Servo on? If not turn on.
* Check #3: Test for excpetions in Motocom calls
* Check #4: Was the Motoman call sent successfully? Print results
* Check #5: Did the command result in an alarm or error? Print alarm.
*
* Also, this function takes motion types like move_UsersChoice() but does not
* take IMOV. We will check for that. 
*
* Positions will be stored in a pointer m_pdDesAngles. 
* The positions can be retrieved from the inverse kinematics.
* 
* Methods called in the following order:
* BscServoOn:		Sets servo power supply ON..
* BscPMov:			Moves the robot in an incremental fashion.
* BscIsAlarm:		Check to see if an alarm was trigered.
* error_GetAlarm:	Print the alarm result
*
*---------------------------------------------------------------------------------
* short BscServoOn(short nCid);
* In: nCid:	Communication handler ID number (obtained from the class CCommSetUp.
*
* Out (Return): None
* Return value: 0 = normal completion; !0 = error
*---------------------------------------------------------------------------------
* short BscPMov(short nCid, char *movtype, char *vtype, double spd, short toolno, 
*				double *p)
* In:	nCid:		Communication handler ID number
*		*movtype	Motion type: MOVJ, MOVL, IMOV
*		*vtype:		Move speed selection; V:Control point; VR:Position angular
*		spd:		Move speed (0.1 to ......mm/s,0.1 to .....°/s)
*		toolno:		Tool number
*		*p:			Target position storage pointer
*					P[0] S-axis pulse number
*					P[1] L-axis pulse number
*					P[2] U-axis pulse number
*					P[3] R-axis pulse number
*					P[4] B-axis pulse number
*					P[5] T-axis pulse number
*					P[6] 7th axis pulse number 
*					P[7] 8th axis pulse number 
*					P[8] 9th axis pulse number 
*					P[9] 10th axis pulse number
*					P[10] 11th axis pulse number
*					P[11] 12th axis pulse number
*
* Out (Return): None
* Return value: 0 = normal completion; !0 = error
*****************************************************************************/
STDMETHODIMP CHP3JC::move_JointAngles()
{
	// TODO: Add your implementation code here
	// Initialize local variables
	SAFEARRAY*		 mysa;
	IVectorSignal*	 pIVSDesAngles		= NULL;	
	IStateMachine*	 pIVSStateMachine	= NULL;

	// Get object and interface pointer to Desired Angles
	m_Bindings->get_Pointers(SysAllocString(L"DesiredJointAngles"),&m_pIUnkDesiredAngles);	

	if(m_pIUnkDesiredAngles == NULL)
	{
		m_bstrError = SysAllocString(L"Connection to component did not work");
		
		return !S_OK;
	}

	m_pIUnkDesiredAngles->QueryInterface(IID_IVectorSignal,(void **)&pIVSDesAngles);
		
	if (pIVSDesAngles != NULL)
	{

		// Get Desired ANGLES
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES*2);			// Need a total of 12 inputs
		pIVSDesAngles->GetCurrentVector(mysa);
		memcpy(m_pdDesPos,mysa->pvData,sizeof(double)*(NUM_AXES*2));	
		// Destroy SafeArray
		SafeArrayDestroy(mysa);
		pIVSDesAngles->Release();

		// Convert Angles to Pulses
		ATLTRACE(_T("Updated Angles: %.5f, %.5f, %.5f, %.5f, %.5f, %.5f. \n"), m_pdDesPos[0], m_pdDesPos[1], m_pdDesPos[2], m_pdDesPos[3], m_pdDesPos[4], m_pdDesPos[5]);		
		Angles2Pulses(m_pdDesPos);

		// Carry out operation ONLY if Communication-Setup was successful. 
		if(m_bConnected)
		{
			// Check to see if the servo motors are ON.
			if (!m_bServoOn)
			{
				// Turn on servo. Takes the Communication Handle (from Initialization() ) as a paramter.
				m_sSuccess = BscServoOn(m_sComHandle);	
				
				// Check result
				if(m_sSuccess != 0)		// 0 = normal completion; !0 = error
				{
					m_bstrError = SysAllocString(L"Could not turn servo on.");
					
				}
				else
					m_bServoOn = true;	// Turn flag on
			}


			// Check to make sure "IMOV" was not selected.
			if (m_sMotionType != 0 && m_sMotionType != 1)
			{
				m_sMotionType = 1;
				m_cMotionType = "MOVL";
			}

			// *** Move arm, call BscPMov***
			// The motion type parameter indicates whether to move linearly or around the joints.
			try {
			m_sSuccess = BscPMov(m_sComHandle, m_cMotionType,"V",m_dSpeed,0,m_pdDesPos);

			// Check Success of operation
			if(m_sSuccess != 0)	// 0 = normal completion; !0 = error
				PrintError((int)m_sSuccess);
			else
			{
				m_bstrError = SysAllocString(L"move_JointAngles executed successfuly.");
				
			}

			// ***Read positions, to keep system updated - BscIsLoc****
			// hResult = read_CurrentPosition();			
			}
			catch(...) 
			{ 
				m_bstrError = SysAllocString(L"move_JointAngles() threw an exception.");
				
			}
			
			// Check for Alarms. Alarm may be generated independently of the success of the operation,
			// If so call GetError to print error code
			if( BscIsAlarm(m_sComHandle) )
					hResult = error_GetError();

		} // End Connection Flag check

		// If not connected, call Initialize() and this function back again
		else
		{
			hResult = connect_Initialize();
			hResult = move_JointAngles();
			pIVSDesAngles->Release();			// Make sure to release the handle if we did not use it
		}

	} // End Interface pointer

	else
	{
		if (pIVSDesAngles != NULL)
		{
			pIVSDesAngles->Release();
			ATLTRACE(_T("HP3JC::move_JointAngles connections failed!"));
			m_bstrError = SysAllocString(L"HP3JC::move_JointAngles connections failed!");
			
			return !S_OK;	
		}
	} // End Component pointer
	
	// Flag state machine
/*	m_Bindings->get_Pointers(SysAllocString(L"StateMachine"),&m_pIUnkStateMachine);	
	if(m_pIUnkStateMachine == NULL)	return !S_OK;
	m_pIUnkStateMachine->QueryInterface(IID_IStateMachine,(void **)&pIVSStateMachine);
	if (pIVSStateMachine == NULL)	return !S_OK;
	pIVSStateMachine->Signal(SysAllocString(L"Go to next state"));
	pIVSStateMachine->Release();
*/
	return S_OK;
}
/*****************************************************************************
* Disconnect()
* Calls BscDisconnect and BscClose if there is an existing connection
* Also check to see if servo is on, if so, it turns it off
******************************************************************************/
STDMETHODIMP CHP3JC::connect_Disconnect()
{		
	
	// If connected, proceed:
	if (m_bConnected)
	{

		// If Servo on, turn it off, else continue
		// Call our own function that does all the checks
		hResult = servo_ServoOff();
		
		// Call BscDisconect
		m_sSuccess = BscDisConnect(m_sComHandle);

		// If result was successful
		if(m_sSuccess == 1)
		{
			// **Call BscClose**
			m_sSuccess=BscClose(m_sComHandle);
			m_bConnected = 0;
			m_bstrError=SysAllocString(L"SerialDisconnect was a success");
			
			ATLTRACE(_T("SerialDisconnect was a success"));
		}
			
		else
		{
			m_bstrError=SysAllocString(L"SerialDisconnect failed");
			
			ATLTRACE(_T("SerialDisconnect failed"));
			return !S_OK;
		}
	}

	else
	{
		m_bstrError=SysAllocString(L"System is not connected");
		
	}

	return S_OK;
}

/*****************************************************************************
* read_CurrentPosition()
* Reads the current robot position in outputs the position in both 
* Joint angles and in cartesian coordinates. Uses BscIsLoc. 
* See. p 116/217 of the MotocomSDK manual to see definitions. 
*
* Positions will be stored in a pointer m_pdDesPos. The positions can be retrieved from the vision
* system via a binding. 
*
* A number of security and logic checks are present throughout the function. 
* Check #1: Is component connected? If not, connect.
* Check #2: Is Servo on? If not turn on.
* Check #3: Test for excpetions in Motocom calls
* Check #4: Was the Motoman call sent successfully? Print results
* Check #5: Did the command result in an alarm or error? Print alarm.
*---------------------------------------------------------------------------------
* short BscIsLoc(short nCid,short ispulse,word *rconf,double *p);
* (potential other call)short BscIsRobotPos(short nCid,char *framename,int isex,word *rconf,word *toolno,double *p)
* In:	nCid:		Communication handler ID number
*		ispulse		0: Cartesian coordinate system; 1: joint coordinate system
*		*rconf:		End-tool configuration (pointer that stores incoming info).
*		*p:			Target position storage pointer
*					P[0] X-axis or S-axis
*					P[1] Y-axis or L-axis
*					P[2] Z-axis or U-axis
*					P[3] Wrist angle TX (unit: degrees) or or R-axis
*					P[4] Wrist angle TY (unit: degrees) or or B-axis
*					P[5] Wrist angle TZ (unit: degrees) or or T-axis
*					P[6] 7th axis pulse number (mm for traveling axis)...
*					P[7] 8th axis pulse number (mm for traveling axis)...
*					P[8] 9th axis pulse number (mm for traveling axis)...
*					P[9] 10th axis pulse number...
*					P[10] 11th axis pulse number...
*					P[11] 12th axis pulse number...
*
* Out (Return): None
* Return value: 0 = normal completion; !0 = error
*
* Update: In May 08, this function was redefined to output both cartesian and
*		  and joint angle data. This was done so that the interaction with the
*		  control basis was easier.
*		  This change undermines the use of asking the user what kind of read-type
*		  they would like... if we have two VS outputs, one will get both...
*		  If there is one, the user will retrieve whichever one he connected to.
*
*		  StateMachine: When the statemachine calls a funciton it does not wait
*		  until it finishes it keeps going... there are times when we call a 
*		  a motoman function and it has not finished all the while other calls
*		  where activated by the state machine disrupting behavior. A flag for
*         the SM is thus inserted at the end. 
*****************************************************************************/
STDMETHODIMP CHP3JC::read_CurrentPosition()
{
	// TODO: Add your implementation code here
	// We need a local Rconf parameter in this method b/c we call 2 Bsc functions.
	// An exception is produced if you do not allocate/deallocate this variable in this method.
	WORD *m_sRconfPosition1;
	m_sRconfPosition1			= new WORD;						

	SAFEARRAY*		 mysa;
	IVectorSignal*	 pIVSActualJointAnglePos = NULL;	
	IVectorSignal*	 pIVSActualXYZPos		 = NULL;
	IStateMachine*	 pIVSStateMachine		 = NULL;

	// Before retrieving positions make sure we have a connection

	if(m_bConnected)
	{
		// Check to see if SERVO is ON.
		if (!m_bServoOn)
		{
			// Turn on servo (takes a few seconds). Takes CommHandle as a parameter
			m_sSuccess = BscServoOn(m_sComHandle);	

				// Check result
				if(m_sSuccess != 0)		// 0 = normal completion; !0 = error
				{
					m_bstrError = SysAllocString(L"Could not turn servo on.");
					
				}
				else
					m_bServoOn = true;	// Turn flag on
		}

		// Call *** BscIsRobotPos *** two times. One to retrieve position in angles and one to retrieve position in cartesian coordinates.
		try{
			m_sSuccess = BscIsLoc(m_sComHandle, ANGLES,    m_sRconfPosition1, m_pdActualJointPositions );
			m_sSuccess = BscIsLoc(m_sComHandle, CARTESIAN, m_sRconfPosition1,m_pdActualXYZPositions   );
			//m_sSuccess = BscIsRobotPos(m_sComHandle,m_cReadPositionType, 1, m_sRconfPosition, m_sToolNo, m_pdActualJointPositions);
		}
		catch(WORD* RCONF)	// need to change this paramter
		{
			*RCONF = 1;
			m_bstrError=SysAllocString(L"read_CurrentPosition threw an exception");
			
			ATLTRACE(_T("BscOpen threw an exception"));
		}

		// Convert pulses to angles. 							
		Pulses2Angles(m_pdActualJointPositions);					// This function saves the result in m_pdActualJointPositions
		ATLTRACE(_T("Current Angles: %.5f, %.5f, %.5f, %.5f, %.5f, %.5f. \n"), m_pdActualJointPositions[0], m_pdActualJointPositions[1], m_pdActualJointPositions[2], m_pdActualJointPositions[3], m_pdActualJointPositions[4], m_pdActualJointPositions[5]);


		// Check Success of operation
		if(m_sSuccess != 0)	// 0 = normal completion; !0 = error
			PrintError((int)m_sSuccess);
		else
		{
			m_bstrError = SysAllocString(L"read_CurrentPosition executed successfuly.");
			
		}
		
		// Check for Alarms. Alarm may be generated independently of the success of the operation,
		// If so call GetError to print error code
		if( BscIsAlarm(m_sComHandle) )
		{
				hResult = error_GetError();
				hResult = error_ClearAlarm();
		}
		
		// Output data to the Actual Joint Angle pos VS and Actual XYZ Pos VS.
		// This is done in two separate steps so that if one of these connections is missing the other still works.
		// There are situations in which one connection is desired and others where two connections are desired. 

		// JOINT ANGLES
		// Get Joint Angle object and interface pointers
		m_Bindings->get_Pointers(SysAllocString(L"ActualJointAngles"),&m_pIUnkActualJointAnglePos);	
		if(m_pIUnkActualJointAnglePos == NULL)	m_bstrError = SysAllocString(L"Joint Angles VS is not connected.");
		m_pIUnkActualJointAnglePos->QueryInterface(IID_IVectorSignal,(void **)&pIVSActualJointAnglePos);
		if (pIVSActualJointAnglePos == NULL)	return !S_OK;
		
		// Set the Actual Joint Angle Position to the vector signal
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES*2);			// Need a total of 12 inputs
		memcpy(mysa->pvData,m_pdActualJointPositions,sizeof(double)*(NUM_AXES*2));			
		pIVSActualJointAnglePos->SetCurrentVector(mysa);
		// Destroy SafeArray
		SafeArrayDestroy(mysa);
		pIVSActualJointAnglePos->Release();

		// XYZ POSITION
		// Get Joint Angle object and interface pointers
		m_Bindings->get_Pointers(SysAllocString(L"ActualXYZPosition"),&m_pIUnkActualXYZPos);	
		if(m_pIUnkActualXYZPos == NULL)	m_bstrError = SysAllocString(L"XYZ Pos VS is not connected.");
		m_pIUnkActualXYZPos->QueryInterface(IID_IVectorSignal,(void **)&pIVSActualXYZPos);
		if (pIVSActualXYZPos == NULL)	return !S_OK;		
		
		// Set the Actual XYZ Position to the vector signal
		mysa = SafeArrayCreateVector(VT_R8,0,NUM_AXES);			// Need a total of 6 inputs
		memcpy(mysa->pvData,m_pdActualXYZPositions,sizeof(double)*NUM_AXES);			
		pIVSActualXYZPos->SetCurrentVector(mysa);
		// Destroy SafeArray
		SafeArrayDestroy(mysa);
		pIVSActualXYZPos->Release();

	} // If connected

	else
	{
		hResult = connect_Initialize();
		hResult = read_CurrentPosition();
	}

	// Flag state machine
/*	m_Bindings->get_Pointers(SysAllocString(L"StateMachine"),&m_pIUnkStateMachine);	
	if(m_pIUnkStateMachine == NULL)	return !S_OK;
	m_pIUnkStateMachine->QueryInterface(IID_IStateMachine,(void **)&pIVSStateMachine);
	if (pIVSStateMachine == NULL)	return !S_OK;

	pIVSStateMachine->Signal(SysAllocString(L"Go to next state"));
	pIVSStateMachine->Release();
*/
	delete m_sRconfPosition1;
	
	return S_OK;
}


/*****************************************************************************
* ServoOn
* Turn on Servo. Check that it has not been turned on previously
*****************************************************************************/

STDMETHODIMP CHP3JC::servo_ServoOn()
{
	// Check to see that we have connected
	if (m_bConnected)
	{
		// If the servo motors are off continue
		if( BscIsServo(m_sComHandle) == 0)	
			// Turn Servo On, otherwise exit function
			m_sSuccess = BscServoOn(m_sComHandle);
		
		// Check for error
		if(m_sSuccess != 0)
		{
			m_bstrError = SysAllocString(L"Error when turning Servo On. Kill IMA and reset motoman.");
			
		}
		else
		{
			m_bstrError = SysAllocString(L"Successfully turned Servo On.");
			
			m_bServoOn = true;
		}
	}

	else
	{
		hResult = connect_Initialize();
		hResult = servo_ServoOn();
	}

	return S_OK;
}
/*****************************************************************************
* ServoOff
* Turn off Servo. Check that servo motor is not ON.
*****************************************************************************/

STDMETHODIMP CHP3JC::servo_ServoOff()
{
	// Check to see that we have connected
	if (m_bConnected)
	{
		if(m_bServoOn == 1)	
		{
			// Turn Servo Off, otherwise exit function
			m_sSuccess = BscServoOff(m_sComHandle);
			// Change the flag to OFF
			m_bServoOn = 0;
		}
		
		// Check for errors 
		if(m_sSuccess != 0)
		{
			m_bstrError = SysAllocString(L"Error when turning Servo Off.");
		}
		else
		{
			m_bstrError = SysAllocString(L"Successfully turned Servo Off.");
			
		}
	}

	// This section may seem unreasonable but sometimes when the program 
	// crashes the servo motors stay on. Instead of having the user have
	// to connect next time around before turning off servo's (to avoid 
	// another error) we do it here.

	else
	{
		// Connect to controller
		hResult = connect_Initialize();
		// Turn off servo
		BscServoOff(m_sComHandle);
		// Check for errors 
		if(m_sSuccess != 0)
		{
			m_bstrError = SysAllocString(L"Error when turning Servo Off.");
			
		}
		else
		{
			m_bstrError = SysAllocString(L"Successfully turned Servo Off.");
			
		}

	}

	return S_OK;
}

/*****************************************************************************
* GetError()
* Calls the following functions:	
* BscGetError(short nCid). It's a prerequisite call
* BscGetFirstAlarm(short nCid,WORD *data); where m_sErrorData is storage pointer (contains a msg).
* PrintError(short *message), private fnctn that prints out error to BSTR
*****************************************************************************/
STDMETHODIMP CHP3JC::error_GetError()
{
	if(m_bConnected)
	{
		// First need to call the following function
		m_sSuccess = BscIsError(m_sComHandle);
		
		// If there is an error
		if(m_sSuccess == 1)
		{
			// Retrieve the error code
			m_iReturnError = BscGetError(m_sComHandle);

			// If the function returned an error let's print it
			if(m_iReturnError != 0)
			{
				PrintError(m_iReturnError);
				Write2File("Error",(double*)m_iReturnError,"ErrorLog");
			}
		}
	}

	return S_OK;
}
/*****************************************************************************
* ClearError()
* Calls BscCancel(short nCid);
*
* Return Value:  0		No error
*				 other  Error code
*****************************************************************************/
STDMETHODIMP CHP3JC::error_ClearError()
{
	// Check to make sure we are connected
	if (m_bConnected)
	{
		// Check to make sure an error exists
		if(m_iReturnError != 0)
			// Clear the error
			m_iReturnError = BscCancel(m_sComHandle);

		if(m_iReturnError == 0)
		{
			m_bstrError = SysAllocString(L"The error was cleared successfully.");
			
		}
		else
		{
			m_bstrError = SysAllocString(L"The error did not clear successfully.");
			
		}
	}
	
	return S_OK;
}

/*****************************************************************************
* GetAlarm()
* Calls BscGetFirstAlarm(short nCid, short *data);
*
* Must call first BscGetError2(short nCid)
* Return Value:  0		No error
*				 other  Error code
*****************************************************************************/
STDMETHODIMP CHP3JC::error_GetAlarm()
{
	if(m_bConnected)
	{
		// Check for errors
		m_iReturnError = BscGetError2(m_sComHandle);
		
		// Aparently a successful execution of the call above returns a 0 (intuitively you expect an error code).
		if(m_iReturnError == 0)
		{
			m_iReturnError = BscGetFirstAlarm(m_sComHandle, m_sErrorData);	// this is giving trouble
			// Print result. 
			PrintError(m_iReturnError);
		}
	}
	else
	{
		hResult = connect_Initialize();
		hResult = error_GetAlarm();
	}
	return S_OK;
}

/*****************************************************************************
* ClearAlarm()
* Calls BscReset(short nCid);
*
* Check to see if there is alarm if connected to controller. 
* Otherwise connect and then check. This maybe useful when the 
* controller is just turned on and there is a 'collision detect' alarm.
* Return Value:  0		Normal completion
*				 other  Error codes
*****************************************************************************/
STDMETHODIMP CHP3JC::error_ClearAlarm()
{
	// Check for alarm
	if(m_bConnected)
	{
		if(BscIsAlarm(m_sComHandle))
		{
			// It seems sometimes one may need to call a few times.
			m_sSuccess = BscReset(m_sComHandle);
			m_sSuccess = BscReset(m_sComHandle);
			m_sSuccess = BscReset(m_sComHandle);

			if(m_sSuccess == 0)
				m_bstrError = SysAllocString(L"Alarm was cleared successfully");
			else
				m_bstrError = SysAllocString(L"Alarm was not cleared.");
				
		}
	}
	else
	{
		hResult = connect_Initialize();
		hResult = error_ClearAlarm();
	}

	return S_OK;
}

// Private Functions

/*****************************************************************************
* PrintError(short ErrorCode)
* 
* This function takes an error code of type short and appends the result
* to a BSTR string. The result is printed in DAD
*****************************************************************************/
void CHP3JC::PrintError(int ErrorCode)
{
	// We will have to convert the result of type short to a wide char using
	// _itow(int, *wchar, number base)
	BSTR str1 = SysAllocString(L"The following alarm/error code was produced: ");
	BSTR str2 = NULL;
	long len1, len2;
	char temp_buffer[10];

	// Convert the integer to a char*, and then use _bstr_t to convert to a BSTR
	_itoa(ErrorCode,temp_buffer,10);
	str2 = bstr_t(temp_buffer);
	
	// Calc len of strings
	len1 = SysStringLen(str1);
	len2 = SysStringLen(str2);
	m_bstrError = SysAllocStringLen(NULL, len1 + len2);			// Assign length to result
	// Use memcpy to concatenate the two BSTRs
	memcpy(m_bstrError,      str1, len1 * sizeof(OLECHAR));		// Copy first string
	memcpy(m_bstrError+len1, str2, len2 * sizeof(OLECHAR));		// Copy second string
	
	m_bstrError[len1+len2] = NULL;

	// Free strings
	
	SysFreeString(str1);
	SysFreeString(str2);
}
/****************************************
* Pulses2Angles()
* Converts pulses to angles
*
* The conversion takes place for the first 
* six elements of the position array since
* these are all that we use.
*
* An important thing to note here is that when
* the BscIsPos() call is made, it returns the 
* manipulators pulse count. At the home position
* the pulse count is all 0's. But this does not 
* reflect the actual joint frame angles as derived
* from the DH parameter configuration.
*
* In actuality the home angles derived from the DH 
* parameters are: {0 -90 0 0 -90 180}. // Although I don't know why Ty shows up as 90 in the teach pendant.
* These angles needed to be added to the transformed
* Pulses2Angles transformation.
*
* This function is called by read_CurrentPosition()
* and has as an input argument the private member
* variable m_pdDesPos[12].
****************************************/
void CHP3JC::Pulses2Angles(double *Pulses)
{

	// Home Angles
	m_dHomeAngles[0] =     0.0;
	m_dHomeAngles[1] =  - 90.0;							// For the motoman position, the L joint (2nd joint) is rotated clock-wise (-ve) by 90 degrees compared to the home position of the PUMA robot.
	m_dHomeAngles[2] =     0.0;
	m_dHomeAngles[3] =   180.0;
	m_dHomeAngles[4] =  - 90.0;							// Not certain about this value, but it is returned by teach pendant when you retrieve the position of the robot in "BASE" coordinates.
	m_dHomeAngles[5] =     0.0;

	m_pdActualJointPositions[0] = (Pulses[0] * (1/ANGLE2PULSE1)) + m_dHomeAngles[0];	
	m_pdActualJointPositions[1] = (Pulses[1] * (1/ANGLE2PULSE2)) + m_dHomeAngles[1];
	m_pdActualJointPositions[2] = (Pulses[2] * (1/ANGLE2PULSE3)) + m_dHomeAngles[2];
	m_pdActualJointPositions[3] = (Pulses[3] * (1/ANGLE2PULSE4)) + m_dHomeAngles[3];
	m_pdActualJointPositions[4] = (Pulses[4] * (1/ANGLE2PULSE5)) + m_dHomeAngles[4];
	m_pdActualJointPositions[5] = (Pulses[5] * (1/ANGLE2PULSE6)) + m_dHomeAngles[5];

	return;
}

/****************************************
* Angles2Pulses()
* Converts joint angles to joint pulses
*
* Before we convert angles directly to pulses
* we must subtract the HomeAngles transform
* that took place in Pulses2Angles().
* See the description of that function for more info.
****************************************/
void CHP3JC::Angles2Pulses(double *Angles)
{

	// Home Angles
	m_dHomeAngles[0] =     0.0;
	m_dHomeAngles[1] =  - 90.0;							// For the motoman position, the L joint (2nd joint) is rotated clock-wise (-ve) by 90 degrees compared to the home position of the PUMA robot.
	m_dHomeAngles[2] =     0.0;
	m_dHomeAngles[3] =   180.0;
	m_dHomeAngles[4] =  - 90.0;							// If confused, look at at puma spherical wrist configuration.
	m_dHomeAngles[5] =     0.0;

	m_pdDesPos[0] = (Angles[0] - m_dHomeAngles[0]) * ANGLE2PULSE1;
	m_pdDesPos[1] = (Angles[1] - m_dHomeAngles[1]) * ANGLE2PULSE2;
	m_pdDesPos[2] = (Angles[2] - m_dHomeAngles[2]) * ANGLE2PULSE3;
	m_pdDesPos[3] = (Angles[3] - m_dHomeAngles[3]) * ANGLE2PULSE4;
	m_pdDesPos[4] = (Angles[4] - m_dHomeAngles[4]) * ANGLE2PULSE5;
	m_pdDesPos[5] = (Angles[5] - m_dHomeAngles[5]) * ANGLE2PULSE6;

	return;
}

/**********************************************************************
* job_CopyTextQueue()
* Gets a job name from a TextQueue and store it locally. 
* This textQueue is saved with a predetermined name.
* This was necessary to automate the process of calling
* jobs from IMA's State Machine.
**********************************************************************/
STDMETHODIMP CHP3JC::job_CopyTextQueue()
{
	ITextQueue	*pITQJobName;

	// Get object and interface pointers
	m_Bindings->get_Pointers(SysAllocString(L"TextQueue"),&m_pIUnkTextQueue);	
	if(m_pIUnkTextQueue == NULL)
	{
		m_bstrError = SysAllocString(L"Connection to Component did not work in job_CopyTextQueue()");
		
		return !S_OK;
	}

	m_pIUnkTextQueue->QueryInterface(IID_ITextQueue,(void **)&pITQJobName);
	if (pITQJobName != NULL)
	{
		// Set the Actual position to the vector signal
		BSTR TextQueueName = NULL;
		pITQJobName->GetCurrentText(&TextQueueName);
		m_bstrJobName = bstr_t(TextQueueName);

		// Pass to local function
		put_JobName(m_bstrJobName);

		// Destroy SafeArray
		pITQJobName->Release();

	} // End Interface pointer

	else
	{
		if (pITQJobName != NULL)
		{
			pITQJobName->Release();
			ATLTRACE(_T("HP3JC::job_CopyTextQueue() connections failed!"));
			return !S_OK;	
		}
	} // End Component pointer

	return S_OK;
}

/**********************************************************************************************
* job_SelectJob()
* Selects a job by obtaining the name from the string. The name of the job must include the extnsion ".jbi".
*
* A number of security and logic checks are present throughout the function. 
* Check #1: Is component connected? If not, connect.
* Check #2: Is Servo on? If not turn on.
* Check #3: Test for excpetions in Motocom calls
* Check #4: Was the Motoman call sent successfully? Print results
* Check #5: Did the command result in an alarm or error? Print alarm.
*
*---------------------------------------------------------------------------------
* short BscSelectJob(short nCid,char *name);
* In:		nCid:	Communication handle
*			*name:	Job name storage pointer
**********************************************************************************************/
STDMETHODIMP CHP3JC::job_SelectJob()
{
	// Carry out operation ONLY if Communication-Setup was successful. 
	if(m_bConnected)
	{
		// Check to see if the servo motors are ON.
		if (!m_bServoOn)
		{
			// Turn on servo. Takes the Communication Handle (from Initialization() ) as a paramter.
			m_sSuccess = BscServoOn(m_sComHandle);	
			
			// Check result
			if(m_sSuccess != 0)		// 0 = normal completion; !0 = error
			{
				m_bstrError = SysAllocString(L"Could not turn servo on.");
				
				return S_OK;
			}
			else
				m_bServoOn = true;	// Turn flag on
		}

		// *** Selectjob***
		try {
			m_sSuccess = BscSelectJob(m_sComHandle, m_cJobName);

			// Check Success of operation
			if(m_sSuccess != 0)	// 0 = normal completion; !0 = error
				PrintError((int)m_sSuccess);
			else
			{
				m_bSelectJob = true;
				m_bstrError = SysAllocString(L"job_SelectJob() executed successfuly.");
				
			}
		}
		catch(...) 
		{ 
			m_bstrError = SysAllocString(L"job_SelectJob() threw an exception.");	
			
		}
		
		// Check for Alarms. Alarm may be generated independently of the success of the operation,
		// If so call GetError to print error code
		if( BscIsAlarm(m_sComHandle) )
				hResult = error_GetError();

	} // End Connection Flag check

	// If not connected, call Initialize() and this function back again
	else
	{
		hResult = connect_Initialize();
		hResult = job_SelectJob();
	}

	return S_OK;
}

/***********************************************
* job_StartJob()
* Starts a job. Only works if BscSelectJob has been called.
* 
* We will check to se if BscSelectJob was called, if not we will call it.
*
* A number of security and logic checks are present throughout the function. 
* Check #1: Is component connected? If not, connect.
* Check #2: Is Servo on? If not turn on.
* Check #3: Test for excpetions in Motocom calls
* Check #4: Was the Motoman call sent successfully? Print results
* Check #5: Did the command result in an alarm or error? Print alarm.
*
*---------------------------------------------------------------------------------
* short BscSelectJob(short nCid,char *name);
* In:		nCid:	Communication handle
*			*name:	Job name storage pointer
***********************************************/
STDMETHODIMP CHP3JC::job_StartJob()
{
	// Local Variable
	IStateMachine *pIVSStateMachine	= NULL;

	// Carry out operation ONLY if Communication-Setup was successful. 
	if(m_bConnected)
	{
		// Check to see if the servo motors are ON.
		if (!m_bServoOn)
		{
			// Turn on servo. Takes the Communication Handle (from Initialization() ) as a paramter.
			m_sSuccess = BscServoOn(m_sComHandle);	
			
			// Check result
			if(m_sSuccess != 0)		// 0 = normal completion; !0 = error
			{
				m_bstrError = SysAllocString(L"Could not turn servo on.");
				
			}

			else
				m_bServoOn = true;	// Turn flag on
		}

		// Make sure a job has been selected
		if(m_bSelectJob == true)
		{

			// *** StartJob***
			try {
				m_sSuccess = BscStartJob(m_sComHandle);

				// Check Success of operation
				if(m_sSuccess != 0)	// 0 = normal completion; !0 = error
					PrintError((int)m_sSuccess);
				else
				{
					m_bstrError = SysAllocString(L"job_StartJob() executed successfully..");
					
				}
			}
			catch(...) 
			{ 
				m_bstrError = SysAllocString(L"job_StartJob() threw an exception.");	
				
			}
		}

		else														// Call SelectJob()
			hResult = job_SelectJob();
		
		// Check for Alarms. Alarm may be generated independently of the success of the operation,
		// If so call GetError to print error code
		if( BscIsAlarm(m_sComHandle) )
				hResult = error_GetError();

	} // End Connection Flag check

	// If not connected, call Initialize() and this function back again
	else
	{
		hResult = connect_Initialize();
		hResult = job_SelectJob();
	}

	// Flag state machine
	m_Bindings->get_Pointers(SysAllocString(L"StateMachine"),&m_pIUnkStateMachine);	
	if(m_pIUnkStateMachine == NULL)	return !S_OK;
	m_pIUnkStateMachine->QueryInterface(IID_IStateMachine,(void **)&pIVSStateMachine);
	if (pIVSStateMachine == NULL)	return !S_OK;
	pIVSStateMachine->Signal(SysAllocString(L"Go to next state"));
	pIVSStateMachine->Release();

	return S_OK;
}



/********************************************
* Properties ********************************
/********************************************/

/*****************************************************************************
* ErrorMessage()
* Prints error message in DAD. The error message comes from the currently
* running method. The goal is to ease debugging.
*****************************************************************************/
STDMETHODIMP CHP3JC::get_ErrorMessage(BSTR *pVal)
{
	// TODO: Add your implementation code here
	if (pVal != NULL)
		*pVal = m_bstrError;			// Other functions will copy error msg to m_bstrError

	return S_OK;
}

STDMETHODIMP CHP3JC::put_ErrorMessage(BSTR newVal)
{
	// TODO: Add your implementation code here
	m_bstrError = SysAllocString(L"This component contains all necessary functions to run the HP3JC in IMA");
	
	return S_OK;
}
/************************************************************
* get_ToolType()
* get_ToolType
* Determines whether we have mounted:
* 0: Nothing on the HP3JC
* 1: Barret hand
* 2: The Assembly tool (barret hand + extension stick)
************************************************************/
STDMETHODIMP CHP3JC::get_ToolType(BSTR *pVal)
{
	if(pVal != NULL)
	{
		if (m_sToolType == 0)
			*pVal = SysAllocString(L"EMPTY");
		if (m_sToolType == 1)
			*pVal = SysAllocString(L"BARRET");
		if (m_sToolType == 3)
			*pVal = SysAllocString(L"ASEEMBLY");
	}
	return S_OK;
}

STDMETHODIMP CHP3JC::put_ToolType(BSTR newVal)
{
	USES_CONVERSION;

	// make lower case letters before comparing
	if(strcmp(_strupr(OLE2T(newVal)),"EMPTY")==0)
	{
		m_sToolType = EMPTY;
		m_bstrError = SysAllocString(L"No tool was selected for the end-effector.");
		
		return S_OK;
	}

	if(strcmp(_strupr(OLE2T(newVal)),"BARRET")==0)
	{
		m_sToolType = BARRET;
		m_bstrError = SysAllocString(L"The Barret Hand tool was selected for the end-effector.");
		
		return S_OK;
	}

	if(strcmp(_strupr(OLE2T(newVal)),"ASSEMBLY")==0)
	{
		m_sToolType = ASSEMBLY;
		m_bstrError = SysAllocString(L"The Assembly tool was selected for the end-effector.");
		
		return S_OK;
	}

	else
	{
		m_sToolType = EMPTY;
		m_bstrError = SysAllocString(L"Please selected EMPTY or BARRET or ASEEMBLY.");
		
		return S_OK;
	}
}

/*****************************************************************************
* read_PositionType
* User selects what kind of reading configuration we desire when reading positions.
* There are two options:
* 1) XYZ Coordinate frame. It is represented by the string XYZ and the value 0,
* 2) Joint Angles	frame. It is represented by the string ANGLES and the value 1,
*****************************************************************************/
STDMETHODIMP CHP3JC::get_read_PositionType(BSTR *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
	{
		if (m_sReadPositionType == 0)
			*pVal = SysAllocString(L"XYZ");
		if (m_sReadPositionType == 1)
			*pVal = SysAllocString(L"ANGLES");
	}
	return S_OK;
}

STDMETHODIMP CHP3JC::put_read_PositionType(BSTR newVal)
{
	// TODO: Add your implementation code here
	USES_CONVERSION;

	// make lower case letters before comparing
	if(strcmp(_strupr(OLE2T(newVal)),"XYZ")==0)
	{
		m_sReadPositionType = 0;
		m_cReadPositionType = "XYZ";
		m_bstrError = SysAllocString(L"Cartesian coordinate system was selected.");
		
		return S_OK;
	}

	else if(strcmp(_strupr(OLE2T(newVal)),"ANGLES")==0)
	{
		m_sReadPositionType = 1;
		m_cReadPositionType = "ANGLES";
		m_bstrError = SysAllocString(L"Joint coordinate system was selected.");
		
		return S_OK;
	}

	else
	{
		m_sReadPositionType = 0;
		m_cReadPositionType = "XYZ";

		m_bstrError   = SysAllocString(L"Type XYZ or ANGLES.");
		
		return S_OK;
	}
}

/*****************************************************************************
* MotionType()
* Gets from the user the type of motion that the manipulator should engage in.
* MOVL: moves the end-effector always parallel to the robot axis 
*       (a few joints are active at the same time to ensure this motion).
* MOVJ: moves the end-effector in non-linear ways.
* IMOV: moves the current position by a value amount.
*****************************************************************************/
STDMETHODIMP CHP3JC::get_MotionType(BSTR *pVal)
{
	// TODO: Add your implementation code here
	if(pVal != NULL)
	{
		if (m_sMotionType == 0)
			*pVal = SysAllocString(L"MOVL");
		else if (m_sMotionType == 1)
			*pVal = SysAllocString(L"MOVJ");
		else if (m_sMotionType == 2)
			*pVal = SysAllocString(L"IMOV");
		else
			*pVal = SysAllocString(L"MOVL");
	}

	return S_OK;
}

STDMETHODIMP CHP3JC::put_MotionType(BSTR newVal)
{
	// TODO: Add your implementation code here
	USES_CONVERSION;

	// make lower case letters before comparing
	if(strcmp(_strupr(OLE2T(newVal)),"MOVL")==0)
	{
		m_sMotionType = 0;
		m_cMotionType = "MOVL";
		m_bstrError = SysAllocString(L"Speed is in mm/s");
		
//		return S_OK;
	}

	else if(strcmp(_strupr(OLE2T(newVal)),"MOVJ")==0)
	{
		m_sMotionType = 1;
		m_cMotionType = "MOVJ";
		m_bstrError = SysAllocString(L"Speed is percentage-wise");
		
//		return S_OK;
	}

	else if(strcmp(_strupr(OLE2T(newVal)),"IMOV")==0)
	{
		m_sMotionType = 2;
		m_cMotionType = "IMOV";
		m_bstrError = SysAllocString(L"Speed is in mm/s");
		
//		return S_OK;
	}

	else
	{
		m_sMotionType = 1;		// If user types in wrong answer default to linear motion
		m_cMotionType = "MOVL";
		m_bstrError   = SysAllocString(L"Type MOVJ, MOVL, or IMOV.");
		

//		return S_OK;
	}

		
	return S_OK;
}

/*****************************************************************************
* Speed()
* The robot can move only at certain speeds. Look at manual for more.
*****************************************************************************/
STDMETHODIMP CHP3JC::get_Speed(double *pVal)
{
	// TODO: Add your implementation code here
	if (pVal != NULL)
		*pVal = m_dSpeed;
	return S_OK;
}

STDMETHODIMP CHP3JC::put_Speed(double newVal)
{
	// TODO: Add your implementation code here
	if (newVal >= 0.12 && newVal <= 100)
	{
		m_dSpeed = newVal;
		m_bstrError = SysAllocString(L"MOVJ speed is in percentage, others are in mm/s.");
	}
	return S_OK;
}

/*****************************************************************************
* Frame()
* A detailed explanation is found at M:\Documenation\Controller\Relative Function Manual.pdf
* It helps the trajectory planner to decide on a path. Particularly important
* when facing singularities. 
*****************************************************************************/
STDMETHODIMP CHP3JC::get_EndToolForm(long *pVal)
{
	// TODO: Add your implementation code here
	*pVal = (long)m_sRconf;
	return S_OK;
}

STDMETHODIMP CHP3JC::put_EndToolForm(long newVal)
{
	// TODO: Add your implementation code here
	m_sRconf = (short)newVal;
	return S_OK;
}

/*****************************************************************************
* JobName()
* This property gets/puts job names that are saved in the NX100 memory.
* The type of incoming/outgoing param is BSTR.
* I have experienced particular dificulties converting from BSTR's to char*
* in this project. The problem was not so much the difficulty but a linkage 
* error when using a CSTring class. The problem is related to MFC and linking order.
* Perhaps future users can figure out why the linkage error occurs.
*
* In the mean time, a hard coded work-around is being used. This works as long
* as you know the names of jobs saved in the NX100.
*****************************************************************************/
STDMETHODIMP CHP3JC::get_JobName(BSTR *pVal)
{
	// Work-around. We will check for specific names saved in the NX100.
	// If they match, we will create a char* manually for it.
	if(strcmp(_strupr(m_cJobName),"HOME.JBI")==0)
		*pVal = SysAllocString(L"HOME.JBI");
	else if(strcmp(_strupr(m_cJobName),"ASINTPOS.JBI")==0)		// Assembly initial position
		*pVal = SysAllocString(L"ASINTPOS.JBI");
	else if(strcmp(_strupr(m_cJobName),"UPNDOWN.JBI")==0)		// Moves up and down
		*pVal = SysAllocString(L"UPNDOWN.JBI");
	else if(strcmp(_strupr(m_cJobName),"LT2RT.JBI")==0)			// Left to right (in a ciruclar motion)
		*pVal = SysAllocString(L"LT2RT.JBI");
	else if(strcmp(_strupr(m_cJobName),"CIRCLE.JBI")==0)		// Moves in circles
		*pVal = SysAllocString(L"CIRCLE.JBI");
	else if(strcmp(_strupr(m_cJobName),"LT2RTS.JBI")==0)		// Moves left to right in a straight line
		*pVal = SysAllocString(L"LT2RTS.JBI");
	else
		*pVal = SysAllocString(L"Wrong name");

	// Free String
	

	return S_OK;
}

STDMETHODIMP CHP3JC::put_JobName(BSTR newVal)
{
	USES_CONVERSION;

	// make lower case letters before comparing
	if(strcmp(_strupr(OLE2T(newVal)),"HOME.JBI")==0)
		strcpy(m_cJobName,"HOME.JBI");

	else if(strcmp(_strupr(OLE2T(newVal)),"ASINTPOS.JBI")==0)
		strcpy(m_cJobName,"ASINTPOS.JBI");

	else if(strcmp(_strupr(OLE2T(newVal)),"UPNDOWN.JBI")==0)
		strcpy(m_cJobName,"UPNDOWN.JBI");

	else if(strcmp(_strupr(OLE2T(newVal)),"LT2RT.JBI")==0)
		strcpy(m_cJobName,"LT2RT.JBI");

	else if(strcmp(_strupr(OLE2T(newVal)),"CIRCLE.JBI")==0)
		strcpy(m_cJobName,"CIRCLE.JBI");

	else if(strcmp(_strupr(OLE2T(newVal)),"LT2RTS.JBI")==0)
		strcpy(m_cJobName,"LT2RTS.JBI");

	else
	{
		strcpy(m_cJobName,"HOME");
		m_bstrError   = SysAllocString(L"Choose a job name that is saved in the NX100, including the extension.");
		
	}

	return S_OK;
}


// Will write to a file the values passed to the input argument.
void CHP3JC::Write2File(char * title, double * positions , char * textfile)
{
	int i;
	USES_CONVERSION;

	/* String concatenation to allow for different file names*/
	char path[200] = "O:\\Agents\\TestAgents\\ControlBasis\\MotomanPositionCB\\Files\\";

	strcat(path,textfile);
	

	// Open the file
	stream = fopen(path,"w+t");

	// Write result to the file

	// Title of data
	fprintf(stream, "%s\t", title);

	// Data
	for(i=0;i<NUM_AXES;i++)
		fprintf(stream,"%.2f ", positions[i]);

	// Newline
	fprintf(stream, "\n");

	// Close the file
	fclose(stream);
	stream = NULL;

}


