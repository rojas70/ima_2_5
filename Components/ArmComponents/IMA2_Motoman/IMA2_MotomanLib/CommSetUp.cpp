// CommSetUp.cpp : Implementation of CCommSetUp
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A note about this template:
// This template is autogenerated. The template code can be found in \ProgramFiles\MicrosoftVisualStudio\Common\MSDev\Templates\ATL
// Specifically customized for an IMA 2.5 component.
// Created by Juan Rojas. Jan 08.
//
// You can also look at an example compenent created by Christina Campbell at O:\Components\ExampleComp
// If you are just learning look at that component to see more details than those included in this template.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "IMA2_MotomanLib.h"
#include "CommSetUp.h"

/////////////////////////////////////////////////////////////////////////////
// CCommSetUp
// 
// Include Class comments.
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
// CCommSetUp::OnConstruct() 
// OnConstruct() is called when the component is created. In addition to putting in
// whatever initialization code you need, If you are going to connect to another
// component anywhere in your code, you need to set up bindings. 
//
// The following code will create one binding. Change "DescriptiveName" to some
// appropriate string. This string will be visible as the name of the binding from
// DAD. It is *not* the name of the component you will bind to. The name of the
// specific component on the other end of the binding is determined at runtime (in DAD).
//
// If you wish to allow only one component to connect to this binding, make the BindType
// BT_Default. If you wish to allow several components, make the BindType BT_Collection.
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCommSetUp::OnConstruct()
{
// TODO: Bindings. Personalize the binding of your component. 
	int numiids;
	IMA2_BindingInfo	BindInf;
	numiids=1;
	// **START**
	// 1. DesiredPosition
	BindInf.Name		= SysAllocString(L"DesiredPosition");				// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);		// Create and empty string array
	m_ConfigureBindings->Add(&BindInf);										// Set up the clients bindings array.	

	// 2. Communcation Paramaters
	BindInf.Name		= SysAllocString(L"CommParams");					// Assign name to object
	BindInf.BindType	= BT_Collection;									// Condition to accept multiple targets. Could be BT_Default.
	BindInf.Path		= SysAllocString(L"");								// This must be the path of our component
	BindInf.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);		// Create and empty string array
	BindInf.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);		// Create and empty string array
	m_ConfigureBindings->Add(&BindInf);



	// Deallocate storage
	SysFreeString(BindInf.Name);
	SysFreeString(BindInf.Path);
	SafeArrayDestroy(BindInf.PIDs);
	SafeArrayDestroy(BindInf.IIDs);
  return S_OK;
}
STDMETHODIMP CCommSetUp::OnDestruct() {	return S_OK; }
//////////////////////////////////////////////////////////////////////////////////////////
// CCommSetUp::Save(VARIANT *pData)
// This method is called by DAD when a component is saved. Items that should be saved are the
// ones that are important to the setup of the code, or user options that should hold over
// from one use of an agent to another. (Example: size of data, filenames, etc.) 
//
// For each variable to be saved, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to GetPropertyBag). Change the
// term "DescriptiveName" to something descriptive of the item you are saving, and make
// sure not to reuse names. In the next line of code, change "m_MyPrivateVariable" to the variable
// you are saving and VarType to the VarType of that value. Valid types and VarTypes are:
// (Note: These are limited by VB/OLE compatibility, not by the list of things that Variants can be.)
// int:		VT_I4
// float:	VT_R4
// double:	VT_R8
// BSTR:	VT_BSTR
// char:	VT_BYTE
// All strings (char*) should be converted to BSTR (see BSTR documentation).
// A CString can be converted to a BSTR using the member function AllocSysString (see CString documentation)
//
// If you want to save an array, you have to assign a SAFEARRAY to the Variant. (Do NOT just
// use a pointer, it will save just one value). replace the line starting "ItemValue =" with the following 
// code (substituting your pointer for "variable", the array length for "numelem", int/float/double, etc. 
// for "Type", and using the VarType of one element of the array--BSTR arrays are not allowed.):
//
//	ItemValue = new variant_t;
//	ItemValue->vt=VT_ARRAY|VarType;
//	ItemValue->parray=SafeArrayCreateVector(VarType,0,numelem);
//  memcpy(ItemValue->parray->pvData,variable,numelem*sizeof(Type));
//
// Note: "delete ItemValue" will take care of destroying the safearray (do *not* call SafeArrayDestroy).
// Because of the nature of a SafeArray, you do not have to explicitly save the length of the array.
// However, due to the nature of property bags, you must call the array version of the Add function:
//
//  hRes = pIPB->AddArrayToPropertyBag(&ItemName, ItemValue);
//
// (See Load comments for how to extract arrays from the propertybag).
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCommSetUp::Save(VARIANT *pData) {
	// Variables
	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	variant_t				*ItemValue;
	_PropertyBagWrapper		*pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		if (pIPB == NULL)	
			return !S_OK;
/*		
		// **START**
		// Create string names for items to be saved
		// Number of Elements
		ItemName = SysAllocString(L"DescriptiveName");
		// Store the data and the type of data into a variant_t type
 		ItemValue = new variant_t(m_YourPrivateVariableName,VT_I4);
		// Add an item to the property bag via the wrapper class.
		hRes = pIPB->AddToPropertyBag(&ItemName, ItemValue);
		// Free the strings memory location
		SysFreeString(ItemName);
		// Delete our variants
		delete ItemValue;
		// **FINISH**
		// Returns a pointer to the PropertyBag as a VARIANT
		hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
		
		// Copy the contents of the property bag to the pData VARIANT
		VariantCopy(pData, &m_VBPropertyBag);
		// Save the size of the data 
		m_lDataSize = pData->parray->rgsabound[0].cElements;		
		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);
*/
		// Release
		pIPB->Release();
	return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////
// CCommSetUp::Load(VARIANT Data)
// This function will load in all the data you just saved in the Save function.
// 
// For each variable to be loaded, make a copy of the code between **START** and **FINISH**
// (and paste them so that they all appear before the call to VariantClear). Change the
// term "NameUsedToSave" to the name you gave this item in Save.
// On the line beginning "variable = ", change "variable" to the variable that you saved
// the value from, and change "Type" to the type of that variable (use "long" for "int")
// A CString can be directly set to a BSTR, but in order to get a char* back, you have to 
// use strcpy (I think).
//
// If you made an array, you have to load it back in now.
// Just like in the save function, you must call the array version of the Get function:
//
//  pIPB->GetArrayFromPropertyBag(&ItemName, ItemValue);
//
// If your variable is dynamically allocated, make sure to delete and reallocate it:
//
//  if(variable!=NULL)
//		delete variable;
//  variable=new Type[ItemValue->parray->rgsabound->cElements];	
//
// Then just copy the values from the parray (replace the "variable =" line with this):
//
//  memcpy(variable,ItemValue->parray->pvData,ItemValue->parray->rgsabound->cElements*sizeof(Type));
//
// Note that this means you do not have to separately save the length of the array, although if
// you have a variable that keeps track of the array length you should also set it at this point:
//
//  numelem=ItemValue->parray->rgsabound->cElements;
//
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCommSetUp::Load(VARIANT Data) {
	
	// Variables
	BSTR					ItemName = NULL;// The string holding the name of the item to write into the property bag.
	_PropertyBagWrapper*	pIPB;			// COM Interface Pointer to the PropertyBag _Wrapper_ Class
	HRESULT					hRes;			// The HRESULT value we get back from COM calls.
	variant_t				*ItemValue;
	// (1) Create the property bag wrapper class
	// (2) Have the class point to the interface 
	hRes = CoCreateInstance(CLSID_PropertyBagWrapper, NULL, CLSCTX_INPROC_SERVER, IID__PropertyBagWrapper, (LPVOID*)&pIPB);
		if (pIPB == NULL)	
			return !S_OK;
		// Get the pointer to the real VB property bag (the VB object (defined in msvbvm60.dll (aka VBRUN)) that our wrapper class created)
		// hRes = pIPB->GetPropertyBag(&m_VBPropertyBag);
/*		
		// Pass Data to PropertyBag
		hRes = pIPB->SetPropertyBag(&Data);
		// **START**
		// Variable m_lNumElements
		// Define strings
		ItemName		= SysAllocString(L"NameUsedToSave");
		ItemValue		= new variant_t;
		// Read Data from the property bag
		pIPB->GetFromPropertyBag(&ItemName,ItemValue);  //2nd argument is return value (look retval for help)
		m_YourPrivateVariableName	= (long)*ItemValue;
		// Deallocate
		SysFreeString(ItemName);
		delete ItemValue;
		// **FINISH**
		// Decrement the pointer reference count from our member variable. 
		VariantClear(&m_VBPropertyBag);
*/		
		// Release
		pIPB->Release();
		
return S_OK;
}



/*****************************************************************************
* SerialConnect()
* This function will call four Motoman BSC functions to start communication.
* See. p 191/217 of the MotocomSDK manual to see definitions. 
* 
* Methods called in the following order:
* BscOpen:			Gets a communication handler.
* BscSetCom:		Sets communications parameters of the serial port.
* BscSetCondBSC		Sets a communication control timer or retry counter.
* BscConnect:		Connects communications lines.
*
*---------------------------------------------------------------------------------
* short BscOpen(char *path,short mode);
* In: *path:	Communication current directory storage pointer
*     mode:		Communication type:
*
* Out (Return): None
* Return value: -1 = Acquisition Failure; Others = Communication handler ID number
*---------------------------------------------------------------------------------
* short BscSetCom(short nCid, short port,DWORD baud, short parity, short clen, short stp);
* In:	nCid:	Communication handler ID number
*		port:	Communication port number 1:COM1,2:COM2,3:COM3,4:COM4,...,255:COM255
*		baud:	Baud rate 150, 300, 600, 1200, 2400, 4800, 9600, 19200
*		parity:	Parity 0: None, 1: Odd, 2: Even
*		Clen:	Data length 7: 7 bits, 8: 8 bits
*		Stp:	Stop bit 0: 1 bit, 1: 1.5 bits, 2: 2 bits
* 
* Out (Return): None
* Return value: 0 = Error; 1 = Normal Completion
*---------------------------------------------------------------------------------
* short BscSetCondBSC(short nCid,short timerA,short timerB,short rtyR,short rtyW)
* In:	nCid:	Communication handler ID number
*		timerA:	Timer A (control timer, unit: msec)
*		timerB:	Timer B (text timer, unit: msec)
*		rtyR:	Sequence retry counter
*		rtyW:	Text retry counter
*
* Out (Return): None
* Return value: -1 = Error; 0 = Normal completion
*---------------------------------------------------------------------------------
* short BscConnect(short nCid););
* In:	nCid:	Communication handler ID number
*
* Out (Return): None
* Return value: 0 = Error; 1 = Normal Completion
*****************************************************************************/
STDMETHODIMP CCommSetUp::SerialConnect()
{

	// Create a string with the path where the local .dll is located.
	strcpy(m_cTempBuffer,"O:\\Components\\ArmComponents\\IMA2_Motoman\\IMA2_MotomanLib"/*"C:\\IMA2\\Components","O:\\Components"*/); 
	
	// If we have not connected before, proceed:
	if (m_bConnected == 0)
	{
	

		try {
			// **Call BscOpen**
			m_sComHandle = BscOpen(m_cTempBuffer, m_sComType);

			
			if (m_sComHandle != -1)			// BscOpen: success is other than -1, error is -1
			{
				// For Serial Communications
				// **Call BscSetCom**
				if(m_sComType == 1)
					m_sSuccess=BscSetCom(m_sComHandle,m_sPort,m_dwBaud,m_sParity,m_sDataLen,m_sStopBit);
				
				// For Ethernet Communications
				//else
					//Set Ethernet Conditions (currently has not been set-up. Feb 08)
					//m_sSuccess=BscSetEther(m_sComHandle,cIpAddr,sEtherMode,m_hWnd);
			}
			else
			{
				ATLTRACE(_T("BscOpen failed"));
				return !S_OK;
			}

			
			if(m_sSuccess != 0)				// BscSetCom: success is 1, error is 0
			{	
				// **Call BscSetCond**
				m_sSuccess = BscSetCondBSC(m_sComHandle,3000,20000,3,3); // Could be (10000,30000) or (3000,20000)
				
				
				if (m_sSuccess != -1)		// BscSetCondBSC: success is 0, error is -1
				{	
					// ***Call BscConnect***
					// Connect communication lines
					m_sSuccess = BscConnect(m_sComHandle);

					// If Connection fails:
					if(m_sSuccess == 0)
					{
						ATLTRACE(_T("\nBscConnect failed\n"));
						return !S_OK;
					}

					// If communication succeeds
					else
					{
						m_bConnected = true;

						// test
						 //m_sSuccess = BscServoOff(m_sComHandle);
						 m_sSuccess = BscServoOn(m_sComHandle);
						 double m_pdDesPos[12]={20.0,0,0,0,0,0,0,0,0,0,0,0};
						 m_sSuccess = BscImov(m_sComHandle,"V",0.23,"ROBOT",0,m_pdDesPos);

						// Set communication parameters in array
						// Paramter 1: Comm Handle
						// Paramter 2: Flag that connection succeeded (needed by other components to know that we have a connection)
						m_pdCommParams[0] = m_sComHandle;
						m_pdCommParams[1] = (double)m_bConnected;

						// Send out communication parameters to the VS.
						SAFEARRAY*		 mysa;
						IVectorSignal*	 pIVSCommParams = NULL;	

						// Get object and interface pointer
						m_Bindings->get_Pointers(SysAllocString(L"CommParams"),&m_pIUnkCommunicationParameters);	

						if(m_pIUnkCommunicationParameters != NULL)	
							m_pIUnkCommunicationParameters->QueryInterface(IID_IVectorSignal,(void **)&pIVSCommParams);
							
						if (pIVSCommParams != NULL)
						{

							mysa = SafeArrayCreateVector(VT_R8,0,2);			// Need a total of 2 inputs
							memcpy(mysa->pvData,m_pdCommParams,sizeof(double)*2);
							pIVSCommParams->SetCurrentVector(mysa);	
							// Destroy SafeArray
							SafeArrayDestroy(mysa);
							pIVSCommParams->Release();
						}
					}
				}


				else	// BscSetCond
				{
					ATLTRACE(_T("\n**BscSetCond failed**\n"));
					return !S_OK;
				}
				
			}

			// Set serial communication or ethernet communication to failure
			else	// BscOpen
			{
				ATLTRACE(_T("BscOpen failed"));
				return !S_OK;
			}

		}	// End try

		catch(char *)	// need to change this paramter
		{
			ATLTRACE(_T("BscOpen threw an exception"));
		}

	}	// End m_bConnected

	return S_OK;
}

// Call BscDisconnect BscClose
STDMETHODIMP CCommSetUp::SerialDisconnect()
{
	// If connected, proceed:
	if (m_bConnected)
	{
		// **Call BscDisConnect**
		m_sSuccess = BscDisConnect(m_sComHandle);

		// **Call BscClose**
		if (m_sSuccess != 0)			// BscDisConnect: success is 0, error is !0
		{
			m_sSuccess=BscClose(m_sComHandle);
			m_bConnected = 0;
			ATLTRACE(_T("SerialDisconnect was a success"));
		}
			
		else
		{
			ATLTRACE(_T("SerialDisconnect failed"));
			return !S_OK;
		}
	}

	return S_OK;
}


