// ComputePosition.cpp : Implementation of CComputePosition
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A note about this template:
// This template is autogenerated. The template code can be found in \ProgramFiles\MicrosoftVisualStudio\Common\MSDev\Templates\ATL
// Specifically customized for an IMA 2.5 component.
// Created by Juan Rojas. Jan 08.
//
// You can also look at an example compenent created by Christina Campbell at O:\Components\ExampleComp
// If you are just learning look at that component to see more details than those included in this template.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "IMA2_3DPositionLib.h"
#include "ComputePosition.h"
#include "math.h"

// Define PI and conversion from radians to degrees and vice-versa
#ifndef PI
#define PI	3.14159
#define R2D	(180.0/PI)
#define D2R (PI/180.0)
#endif 
/////////////////////////////////////////////////////////////////////////////
// CComputePosition
// 
// Include Class comments.
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
// CComputePosition::OnConstruct() 
// OnConstruct() is called when the component is created. If you are going to connect 
// another component anywhere in your code, you need to set up bindings. 
//
// The following code will create one binding. Change "DescriptiveName" to some
// appropriate string. This string will be visible as the name of the binding from
// DAD. It is *not* the name of the component you will bind to. The name of the
// specific component on the other end of the binding is determined at runtime (in DAD).
//
// If you wish to allow only one component to connect to this binding, make the BindType
// BT_Default. If you wish to allow several components, make the BindType BT_Collection.
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComputePosition::OnConstruct()
{
// Input Binding
	int numiids;
	long x[1];
	IMA2_BindingInfo	m_Binding;

	numiids=1;
	x[0]=0; //specifies first element

	m_Binding.Name		= SysAllocString(L"CameraAngleInput");				// Assign name to object
	m_Binding.BindType	= BT_Default;											// Condition to accept a single binding
	m_Binding.Path		= SysAllocString(L"");									// This is the path of the component you are connecting to
	m_Binding.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, 1);					// Create an empty string array
	m_Binding.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);			// Create an empty string array
	SafeArrayPutElement(m_Binding.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&m_Binding);										// Set up the clients bindings array.	

	// Free Binding Info
	SysFreeString(m_Binding.Name);
	SysFreeString(m_Binding.Path);
	SafeArrayDestroy(m_Binding.PIDs);
	SafeArrayDestroy(m_Binding.IIDs);


	m_Binding.Name		= SysAllocString(L"CartesianPosition");			// Assign name to object
	m_Binding.BindType	= BT_Default;											// Condition to accept a single binding
	m_Binding.Path		= SysAllocString(L"");									// This is the path of the component you are connecting to
	m_Binding.PIDs		= SafeArrayCreateVector(VT_BSTR, 0, 1);					// Create an empty string array
	m_Binding.IIDs		= SafeArrayCreateVector(VT_BSTR, 0, numiids);			// Create an empty string array
	SafeArrayPutElement(m_Binding.IIDs,x,(void *)SysAllocString(L"IVectorSignal"));
	m_ConfigureBindings->Add(&m_Binding);										// Set up the clients bindings array.	

	// Free Binding Info
	SysFreeString(m_Binding.Name);
	SysFreeString(m_Binding.Path);
	SafeArrayDestroy(m_Binding.PIDs);
	SafeArrayDestroy(m_Binding.IIDs);

  return S_OK;
}
STDMETHODIMP CComputePosition::OnDestruct() { return S_OK; }
STDMETHODIMP CComputePosition::Save(VARIANT *pData) { return S_OK; }
STDMETHODIMP CComputePosition::Load(VARIANT Data) { return S_OK; }


/**************************************************************************
/* FindCartesianCoordinates()
/* 
/* This function does the following:
/* 1) Read the current angles of the Pan-Tilt system
/* 2) Compute the 3D Position for the object of interest: X, Y, Z
/* All the information for the derivation of the trigonometric derivation can be found at:
/* O:\Documentation\Component Description\Head\Head Change\Compute3DPosition.doc
/*
/* 3) Average the results
/* 4) Send them out to the Vector Signal 
/**************************************************************************/
STDMETHODIMP CComputePosition::FindCartesianCoordinates()
{
	// Local Variables
	int i;
	IVectorSignal	*ptr = NULL;
	SAFEARRAY * mysa;

	// Retrieve pointer of Input VS
	m_Bindings->get_Pointers(SysAllocString(L"CameraAngleInput"),&m_pHeadInput);	
	
	// Retrieve pointer to VS Interface
	if(m_pHeadInput != NULL)
	{
		m_pHeadInput->QueryInterface(IID_IVectorSignal,(void **)&ptr);		
		if(ptr != NULL)
		{
			// Retrieve the 4 head angles
			mysa=SafeArrayCreateVector(VT_R8,0,4);
			ptr->GetCurrentVector( mysa );
			memcpy(m_dIncomingAngles,mysa->pvData,sizeof(double)*4);
			SafeArrayDestroy(mysa);
			
			// Relase the pointer, and decrement AddRef() by 1.
			ptr->Release();
			ptr = NULL;
		}
	}
	
	else 
	{
		MessageBox(NULL, "Could not bind to CameraAngleInput", "Error", MB_ICONERROR);
		return S_OK;
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////
	// 2) Compute the positions generate by pan and tilt angles
	// Please refer to: O:\Documentation\Component Description\Head\Head Change\Compute3DPosition.doc
	// For an accurate description of the computations found in this function.
	/////////////////////////////////////////////////////////////////////////////////////////////////////

	/*** Section 1 ***/
	// Save the pan angles and parametrize them
	dtempL = 90 - m_dIncomingAngles[0];
	dtempR = 90 + m_dIncomingAngles[2];

	// Converting angles from degrees to radians and parametrize pan angles
	thetaL	= D2R*(dtempL);						// Pan Angles
	thetaR	= D2R*(dtempR);
	PhiLeft	= D2R*m_dIncomingAngles[1];			// Tilt Angles
	PhiRight= D2R*m_dIncomingAngles[3];

	// Average tilt angle for both cameras
	PhiTilt		= (PhiLeft + PhiRight) / 2;			

	// Find X:
	// First use sine law to compute hypoteneuse of triangle
	t = (A * sin(thetaL)) / sin(thetaL + thetaR);
	X = t * sin(thetaR);

	// Find Y
	// Y represents the horizontal direction
	Y = (A/2) - t * cos(thetaR);	

	// Find Z
	// Z can easily be found 1) using Pytahgorean thorem and 2) using the tangent of the average of the tilt angles
	// The algebraic expression between X and Y is more complicated and is shown below:
	// Depth  = sqrt( pow(t,2) + pow(A,2)/4 - t * A * cos(thetaR) );
	Hyp = sqrt (pow(X,2) + pow(Y,2));
	
	// To find the height = Z:
	Z = Hyp * tan(PhiTilt);

	// According to our cartesian axis setup, x-axis represents the depth.
	// Depth = sqrt ( pow(Depth,2) + pow(height,2));  
	// Z = Depth_Tilt*sin(PhiTilt); 

	m_dPosition[0] = (-1.0)*X;							// Inserted the -ve sign to match coordinate axis of arms.
	m_dPosition[1] = (-1.0)*Y;							// Juan Rojas. Nov. 2006
	m_dPosition[2] = Z;									// This function was generated by Li Sun 2003 based on trial and error. + 69.89 - 63.5*(1-cos(PhiTilt));

	/*** Section 2 ***/

	// Compute the intrinsic angles in radians (this is a negative angle given that the tilt is down)
	intrinsic_angle = -1.0*atan2(length,height);

	// For left camera

	// Tilt angles
	// Compute the overal tilt angle and hypotenuse
	tot_tilt_angle = PhiLeft + intrinsic_angle;
	tilt_hyp = sqrt(pow(length,2) + pow(height,2) );

	// Compute X and Z for the tilt
	X_tilt = tilt_hyp * sin(tot_tilt_angle);
	Z_tilt = tilt_hyp * cos(tot_tilt_angle);

	// Compute the hypotenuse for the pan
	pan_hyp = fabs(X_tilt);

	//  Compute X and Y for the pan
	X_pan = pan_hyp * cos(m_dIncomingAngles[0]*D2R);
	Y_pan = pan_hyp * sin(m_dIncomingAngles[0]*D2R);

	// Pass these results to the overall X, Y, Z
	X_hat = X_pan;
	Y_hat = Y_pan;
	Z_hat = Z_tilt;

	// Right camera
	// Compute the overal tilt angle and hypotenuse
	tot_tilt_angle = PhiRight + intrinsic_angle;

	// Compute X and Z for the tilt
	X_tilt = tilt_hyp * sin(tot_tilt_angle);
	Z_tilt = tilt_hyp * cos(tot_tilt_angle);

	// Compute the hypotenuse for the pan
	pan_hyp = fabs(X_tilt);

	//  Compute X and Y for the pan
	X_pan = pan_hyp * cos(m_dIncomingAngles[2]*D2R);
	Y_pan = pan_hyp * sin(m_dIncomingAngles[2]*D2R);

	// Average results for both cameras
	X_hat = (X_hat + X_pan)/2;
	Y_hat = (Y_hat + Y_pan)/2;
	Z_hat = (Z_hat + Z_tilt)/2;

	// Add the results to those computed in Section 1.
	m_dPosition[0] += X_hat;		
	m_dPosition[1] += Y_hat;		
	m_dPosition[2] -= (height - Z_hat);

	//** Note: When working with the arm, it is necessary to pass 3D cartesian coordinates in a 
	//         consistent manner. If this method is used, then the base transform for the arm, needs
	//         to be updated with this information. This could be a little more challenging. 
	//		   Developpers need to try both and see which one suits them best.

	// 3) Average the positions
	for(i=0; i<3; i++)
	{
		m_dAveragePositions[i] = (1-alpha)*m_dPosition[i] + alpha*m_dPreviousPositions[i];
		m_dPreviousPositions[i] = m_dAveragePositions[i];
	}

	// 4) Send the VS out
	// Retrieve pointer of Input VS
	m_Bindings->get_Pointers(SysAllocString(L"CartesianPosition"),&m_pCartesianPosition);

	// Retrive pointer for IVS
	if(m_pCartesianPosition != NULL)
	{
		m_pCartesianPosition->QueryInterface(IID_IVectorSignal,(void **)&ptr);	
		if(ptr != NULL)
		{
			// Write data 
			mysa=SafeArrayCreateVector(VT_R8,0,4);
			memcpy(mysa->pvData,m_dAveragePositions,sizeof(double)*3);
			ptr->SetCurrentVector(mysa);			
			SafeArrayDestroy(mysa);

			//ptr->SetCurrentVector(4,m_dEstPos);	
			ptr->Release();
			ptr = NULL;
		}
	}
	
	else 
	{
		MessageBox(NULL, "Could not bind to CartesianPosition", "Error", MB_ICONERROR);
		return !S_OK;

	}

	return S_OK;
}
